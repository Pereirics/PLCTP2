Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declist start funlist entrypoint stmtlist
Rule 2     start -> <empty>
Rule 3     entrypoint -> <empty>
Rule 4     fun -> DEF fun_name ( idlist ) block
Rule 5     fun -> DEF fun_name ( ) block
Rule 6     fun_name -> ID
Rule 7     stmt -> PRINT ( expr ) ;
Rule 8     stmt -> PRINTLN ( ) ;
Rule 9     stmt -> WHILE new_label ( expr ) jz block
Rule 10    stmt -> IF ( expr ) jz block
Rule 11    stmt -> IF ( expr ) jz block ELSE jmp jz_label block
Rule 12    jmp -> <empty>
Rule 13    jz -> <empty>
Rule 14    jz_label -> <empty>
Rule 15    new_label -> <empty>
Rule 16    var_declare -> VAR ID = expr ;
Rule 17    var_declare -> VAR ID ;
Rule 18    var_declare -> VAR ID [ NUM ] ;
Rule 19    stmt -> ID = expr ;
Rule 20    stmt -> arr_id [ expr ] add = expr ;
Rule 21    add -> <empty>
Rule 22    arr_id -> ID
Rule 23    stmt -> RETURN expr ;
Rule 24    stmt -> RETURN ;
Rule 25    stmt -> PRINTI ( expr ) ;
Rule 26    stmt -> expr ;
Rule 27    expr -> INPUT ( )
Rule 28    expr -> STR ( expr )
Rule 29    expr -> ATOI ( expr )
Rule 30    expr -> expr + expr
Rule 31    expr -> expr - expr
Rule 32    expr -> expr * expr
Rule 33    expr -> expr / expr
Rule 34    expr -> expr % expr
Rule 35    expr -> expr OR expr
Rule 36    expr -> expr AND expr
Rule 37    expr -> expr > expr
Rule 38    expr -> expr < expr
Rule 39    expr -> expr GTE expr
Rule 40    expr -> expr LTE expr
Rule 41    expr -> expr EQ expr
Rule 42    expr -> expr NEQ expr
Rule 43    expr -> expr $ expr
Rule 44    expr -> ! expr
Rule 45    expr -> - expr
Rule 46    expr -> ID
Rule 47    expr -> arr_id [ expr ]
Rule 48    expr -> STRING
Rule 49    expr -> NUM
Rule 50    expr -> TRUE
Rule 51    expr -> FALSE
Rule 52    expr -> ID ( exprlist )
Rule 53    expr -> ID ( )
Rule 54    expr -> ( expr )
Rule 55    declist -> declist var_declare
Rule 56    declist -> <empty>
Rule 57    funlist -> funlist fun
Rule 58    funlist -> <empty>
Rule 59    stmtlist -> stmtlist stmt
Rule 60    stmtlist -> <empty>
Rule 61    idlist -> idlist , ID
Rule 62    idlist -> ID
Rule 63    exprlist -> exprlist , expr
Rule 64    exprlist -> expr
Rule 65    block -> { stmtlist }
Rule 66    block -> stmt

Terminals, with rules where they appear

!                    : 44
$                    : 43
%                    : 34
(                    : 4 5 7 8 9 10 11 25 27 28 29 52 53 54
)                    : 4 5 7 8 9 10 11 25 27 28 29 52 53 54
*                    : 32
+                    : 30
,                    : 61 63
-                    : 31 45
/                    : 33
;                    : 7 8 16 17 18 19 20 23 24 25 26
<                    : 38
=                    : 16 19 20
>                    : 37
AND                  : 36
ATOI                 : 29
DEF                  : 4 5
ELSE                 : 11
EQ                   : 41
FALSE                : 51
GTE                  : 39
ID                   : 6 16 17 18 19 22 46 52 53 61 62
IF                   : 10 11
INPUT                : 27
LTE                  : 40
NEQ                  : 42
NUM                  : 18 49
OR                   : 35
PRINT                : 7
PRINTI               : 25
PRINTLN              : 8
RETURN               : 23 24
STR                  : 28
STRING               : 48
TRUE                 : 50
VAR                  : 16 17 18
WHILE                : 9
[                    : 18 20 47
]                    : 18 20 47
error                : 
{                    : 65
}                    : 65

Nonterminals, with rules where they appear

add                  : 20
arr_id               : 20 47
block                : 4 5 9 10 11 11
declist              : 1 55
entrypoint           : 1
expr                 : 7 9 10 11 16 19 20 20 23 25 26 28 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 45 47 54 63 64
exprlist             : 52 63
fun                  : 57
fun_name             : 4 5
funlist              : 1 57
idlist               : 4 61
jmp                  : 11
jz                   : 9 10 11
jz_label             : 11
new_label            : 9
program              : 0
start                : 1
stmt                 : 59 66
stmtlist             : 1 59 65
var_declare          : 55

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declist start funlist entrypoint stmtlist
    (55) declist -> . declist var_declare
    (56) declist -> .

    VAR             reduce using rule 56 (declist -> .)
    DEF             reduce using rule 56 (declist -> .)
    PRINT           reduce using rule 56 (declist -> .)
    PRINTLN         reduce using rule 56 (declist -> .)
    WHILE           reduce using rule 56 (declist -> .)
    IF              reduce using rule 56 (declist -> .)
    ID              reduce using rule 56 (declist -> .)
    RETURN          reduce using rule 56 (declist -> .)
    PRINTI          reduce using rule 56 (declist -> .)
    INPUT           reduce using rule 56 (declist -> .)
    STR             reduce using rule 56 (declist -> .)
    ATOI            reduce using rule 56 (declist -> .)
    !               reduce using rule 56 (declist -> .)
    -               reduce using rule 56 (declist -> .)
    STRING          reduce using rule 56 (declist -> .)
    NUM             reduce using rule 56 (declist -> .)
    TRUE            reduce using rule 56 (declist -> .)
    FALSE           reduce using rule 56 (declist -> .)
    (               reduce using rule 56 (declist -> .)
    $end            reduce using rule 56 (declist -> .)

    program                        shift and go to state 1
    declist                        shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> declist . start funlist entrypoint stmtlist
    (55) declist -> declist . var_declare
    (2) start -> .
    (16) var_declare -> . VAR ID = expr ;
    (17) var_declare -> . VAR ID ;
    (18) var_declare -> . VAR ID [ NUM ] ;

    DEF             reduce using rule 2 (start -> .)
    PRINT           reduce using rule 2 (start -> .)
    PRINTLN         reduce using rule 2 (start -> .)
    WHILE           reduce using rule 2 (start -> .)
    IF              reduce using rule 2 (start -> .)
    ID              reduce using rule 2 (start -> .)
    RETURN          reduce using rule 2 (start -> .)
    PRINTI          reduce using rule 2 (start -> .)
    INPUT           reduce using rule 2 (start -> .)
    STR             reduce using rule 2 (start -> .)
    ATOI            reduce using rule 2 (start -> .)
    !               reduce using rule 2 (start -> .)
    -               reduce using rule 2 (start -> .)
    STRING          reduce using rule 2 (start -> .)
    NUM             reduce using rule 2 (start -> .)
    TRUE            reduce using rule 2 (start -> .)
    FALSE           reduce using rule 2 (start -> .)
    (               reduce using rule 2 (start -> .)
    $end            reduce using rule 2 (start -> .)
    VAR             shift and go to state 5

    start                          shift and go to state 3
    var_declare                    shift and go to state 4

state 3

    (1) program -> declist start . funlist entrypoint stmtlist
    (57) funlist -> . funlist fun
    (58) funlist -> .

    DEF             reduce using rule 58 (funlist -> .)
    PRINT           reduce using rule 58 (funlist -> .)
    PRINTLN         reduce using rule 58 (funlist -> .)
    WHILE           reduce using rule 58 (funlist -> .)
    IF              reduce using rule 58 (funlist -> .)
    ID              reduce using rule 58 (funlist -> .)
    RETURN          reduce using rule 58 (funlist -> .)
    PRINTI          reduce using rule 58 (funlist -> .)
    INPUT           reduce using rule 58 (funlist -> .)
    STR             reduce using rule 58 (funlist -> .)
    ATOI            reduce using rule 58 (funlist -> .)
    !               reduce using rule 58 (funlist -> .)
    -               reduce using rule 58 (funlist -> .)
    STRING          reduce using rule 58 (funlist -> .)
    NUM             reduce using rule 58 (funlist -> .)
    TRUE            reduce using rule 58 (funlist -> .)
    FALSE           reduce using rule 58 (funlist -> .)
    (               reduce using rule 58 (funlist -> .)
    $end            reduce using rule 58 (funlist -> .)

    funlist                        shift and go to state 6

state 4

    (55) declist -> declist var_declare .

    VAR             reduce using rule 55 (declist -> declist var_declare .)
    DEF             reduce using rule 55 (declist -> declist var_declare .)
    PRINT           reduce using rule 55 (declist -> declist var_declare .)
    PRINTLN         reduce using rule 55 (declist -> declist var_declare .)
    WHILE           reduce using rule 55 (declist -> declist var_declare .)
    IF              reduce using rule 55 (declist -> declist var_declare .)
    ID              reduce using rule 55 (declist -> declist var_declare .)
    RETURN          reduce using rule 55 (declist -> declist var_declare .)
    PRINTI          reduce using rule 55 (declist -> declist var_declare .)
    INPUT           reduce using rule 55 (declist -> declist var_declare .)
    STR             reduce using rule 55 (declist -> declist var_declare .)
    ATOI            reduce using rule 55 (declist -> declist var_declare .)
    !               reduce using rule 55 (declist -> declist var_declare .)
    -               reduce using rule 55 (declist -> declist var_declare .)
    STRING          reduce using rule 55 (declist -> declist var_declare .)
    NUM             reduce using rule 55 (declist -> declist var_declare .)
    TRUE            reduce using rule 55 (declist -> declist var_declare .)
    FALSE           reduce using rule 55 (declist -> declist var_declare .)
    (               reduce using rule 55 (declist -> declist var_declare .)
    $end            reduce using rule 55 (declist -> declist var_declare .)


state 5

    (16) var_declare -> VAR . ID = expr ;
    (17) var_declare -> VAR . ID ;
    (18) var_declare -> VAR . ID [ NUM ] ;

    ID              shift and go to state 7


state 6

    (1) program -> declist start funlist . entrypoint stmtlist
    (57) funlist -> funlist . fun
    (3) entrypoint -> .
    (4) fun -> . DEF fun_name ( idlist ) block
    (5) fun -> . DEF fun_name ( ) block

    PRINT           reduce using rule 3 (entrypoint -> .)
    PRINTLN         reduce using rule 3 (entrypoint -> .)
    WHILE           reduce using rule 3 (entrypoint -> .)
    IF              reduce using rule 3 (entrypoint -> .)
    ID              reduce using rule 3 (entrypoint -> .)
    RETURN          reduce using rule 3 (entrypoint -> .)
    PRINTI          reduce using rule 3 (entrypoint -> .)
    INPUT           reduce using rule 3 (entrypoint -> .)
    STR             reduce using rule 3 (entrypoint -> .)
    ATOI            reduce using rule 3 (entrypoint -> .)
    !               reduce using rule 3 (entrypoint -> .)
    -               reduce using rule 3 (entrypoint -> .)
    STRING          reduce using rule 3 (entrypoint -> .)
    NUM             reduce using rule 3 (entrypoint -> .)
    TRUE            reduce using rule 3 (entrypoint -> .)
    FALSE           reduce using rule 3 (entrypoint -> .)
    (               reduce using rule 3 (entrypoint -> .)
    $end            reduce using rule 3 (entrypoint -> .)
    DEF             shift and go to state 10

    entrypoint                     shift and go to state 8
    fun                            shift and go to state 9

state 7

    (16) var_declare -> VAR ID . = expr ;
    (17) var_declare -> VAR ID . ;
    (18) var_declare -> VAR ID . [ NUM ] ;

    =               shift and go to state 11
    ;               shift and go to state 12
    [               shift and go to state 13


state 8

    (1) program -> declist start funlist entrypoint . stmtlist
    (59) stmtlist -> . stmtlist stmt
    (60) stmtlist -> .

    PRINT           reduce using rule 60 (stmtlist -> .)
    PRINTLN         reduce using rule 60 (stmtlist -> .)
    WHILE           reduce using rule 60 (stmtlist -> .)
    IF              reduce using rule 60 (stmtlist -> .)
    ID              reduce using rule 60 (stmtlist -> .)
    RETURN          reduce using rule 60 (stmtlist -> .)
    PRINTI          reduce using rule 60 (stmtlist -> .)
    INPUT           reduce using rule 60 (stmtlist -> .)
    STR             reduce using rule 60 (stmtlist -> .)
    ATOI            reduce using rule 60 (stmtlist -> .)
    !               reduce using rule 60 (stmtlist -> .)
    -               reduce using rule 60 (stmtlist -> .)
    STRING          reduce using rule 60 (stmtlist -> .)
    NUM             reduce using rule 60 (stmtlist -> .)
    TRUE            reduce using rule 60 (stmtlist -> .)
    FALSE           reduce using rule 60 (stmtlist -> .)
    (               reduce using rule 60 (stmtlist -> .)
    $end            reduce using rule 60 (stmtlist -> .)

    stmtlist                       shift and go to state 14

state 9

    (57) funlist -> funlist fun .

    DEF             reduce using rule 57 (funlist -> funlist fun .)
    PRINT           reduce using rule 57 (funlist -> funlist fun .)
    PRINTLN         reduce using rule 57 (funlist -> funlist fun .)
    WHILE           reduce using rule 57 (funlist -> funlist fun .)
    IF              reduce using rule 57 (funlist -> funlist fun .)
    ID              reduce using rule 57 (funlist -> funlist fun .)
    RETURN          reduce using rule 57 (funlist -> funlist fun .)
    PRINTI          reduce using rule 57 (funlist -> funlist fun .)
    INPUT           reduce using rule 57 (funlist -> funlist fun .)
    STR             reduce using rule 57 (funlist -> funlist fun .)
    ATOI            reduce using rule 57 (funlist -> funlist fun .)
    !               reduce using rule 57 (funlist -> funlist fun .)
    -               reduce using rule 57 (funlist -> funlist fun .)
    STRING          reduce using rule 57 (funlist -> funlist fun .)
    NUM             reduce using rule 57 (funlist -> funlist fun .)
    TRUE            reduce using rule 57 (funlist -> funlist fun .)
    FALSE           reduce using rule 57 (funlist -> funlist fun .)
    (               reduce using rule 57 (funlist -> funlist fun .)
    $end            reduce using rule 57 (funlist -> funlist fun .)


state 10

    (4) fun -> DEF . fun_name ( idlist ) block
    (5) fun -> DEF . fun_name ( ) block
    (6) fun_name -> . ID

    ID              shift and go to state 16

    fun_name                       shift and go to state 15

state 11

    (16) var_declare -> VAR ID = . expr ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 18
    arr_id                         shift and go to state 25

state 12

    (17) var_declare -> VAR ID ; .

    VAR             reduce using rule 17 (var_declare -> VAR ID ; .)
    DEF             reduce using rule 17 (var_declare -> VAR ID ; .)
    PRINT           reduce using rule 17 (var_declare -> VAR ID ; .)
    PRINTLN         reduce using rule 17 (var_declare -> VAR ID ; .)
    WHILE           reduce using rule 17 (var_declare -> VAR ID ; .)
    IF              reduce using rule 17 (var_declare -> VAR ID ; .)
    ID              reduce using rule 17 (var_declare -> VAR ID ; .)
    RETURN          reduce using rule 17 (var_declare -> VAR ID ; .)
    PRINTI          reduce using rule 17 (var_declare -> VAR ID ; .)
    INPUT           reduce using rule 17 (var_declare -> VAR ID ; .)
    STR             reduce using rule 17 (var_declare -> VAR ID ; .)
    ATOI            reduce using rule 17 (var_declare -> VAR ID ; .)
    !               reduce using rule 17 (var_declare -> VAR ID ; .)
    -               reduce using rule 17 (var_declare -> VAR ID ; .)
    STRING          reduce using rule 17 (var_declare -> VAR ID ; .)
    NUM             reduce using rule 17 (var_declare -> VAR ID ; .)
    TRUE            reduce using rule 17 (var_declare -> VAR ID ; .)
    FALSE           reduce using rule 17 (var_declare -> VAR ID ; .)
    (               reduce using rule 17 (var_declare -> VAR ID ; .)
    $end            reduce using rule 17 (var_declare -> VAR ID ; .)


state 13

    (18) var_declare -> VAR ID [ . NUM ] ;

    NUM             shift and go to state 30


state 14

    (1) program -> declist start funlist entrypoint stmtlist .
    (59) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . arr_id [ expr ] add = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )

    $end            reduce using rule 1 (program -> declist start funlist entrypoint stmtlist .)
    PRINT           shift and go to state 32
    PRINTLN         shift and go to state 34
    WHILE           shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    stmt                           shift and go to state 31
    expr                           shift and go to state 33
    arr_id                         shift and go to state 38

state 15

    (4) fun -> DEF fun_name . ( idlist ) block
    (5) fun -> DEF fun_name . ( ) block

    (               shift and go to state 41


state 16

    (6) fun_name -> ID .

    (               reduce using rule 6 (fun_name -> ID .)


state 17

    (46) expr -> ID .
    (52) expr -> ID . ( exprlist )
    (53) expr -> ID . ( )
    (22) arr_id -> ID .

    ;               reduce using rule 46 (expr -> ID .)
    +               reduce using rule 46 (expr -> ID .)
    -               reduce using rule 46 (expr -> ID .)
    *               reduce using rule 46 (expr -> ID .)
    /               reduce using rule 46 (expr -> ID .)
    %               reduce using rule 46 (expr -> ID .)
    OR              reduce using rule 46 (expr -> ID .)
    AND             reduce using rule 46 (expr -> ID .)
    >               reduce using rule 46 (expr -> ID .)
    <               reduce using rule 46 (expr -> ID .)
    GTE             reduce using rule 46 (expr -> ID .)
    LTE             reduce using rule 46 (expr -> ID .)
    EQ              reduce using rule 46 (expr -> ID .)
    NEQ             reduce using rule 46 (expr -> ID .)
    $               reduce using rule 46 (expr -> ID .)
    )               reduce using rule 46 (expr -> ID .)
    ,               reduce using rule 46 (expr -> ID .)
    ]               reduce using rule 46 (expr -> ID .)
    (               shift and go to state 42
    [               reduce using rule 22 (arr_id -> ID .)


state 18

    (16) var_declare -> VAR ID = expr . ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               shift and go to state 43
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 19

    (27) expr -> INPUT . ( )

    (               shift and go to state 58


state 20

    (54) expr -> ( . expr )
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 59
    arr_id                         shift and go to state 25

state 21

    (28) expr -> STR . ( expr )

    (               shift and go to state 60


state 22

    (29) expr -> ATOI . ( expr )

    (               shift and go to state 61


state 23

    (45) expr -> - . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 62
    arr_id                         shift and go to state 25

state 24

    (44) expr -> ! . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 63
    arr_id                         shift and go to state 25

state 25

    (47) expr -> arr_id . [ expr ]

    [               shift and go to state 64


state 26

    (48) expr -> STRING .

    ;               reduce using rule 48 (expr -> STRING .)
    +               reduce using rule 48 (expr -> STRING .)
    -               reduce using rule 48 (expr -> STRING .)
    *               reduce using rule 48 (expr -> STRING .)
    /               reduce using rule 48 (expr -> STRING .)
    %               reduce using rule 48 (expr -> STRING .)
    OR              reduce using rule 48 (expr -> STRING .)
    AND             reduce using rule 48 (expr -> STRING .)
    >               reduce using rule 48 (expr -> STRING .)
    <               reduce using rule 48 (expr -> STRING .)
    GTE             reduce using rule 48 (expr -> STRING .)
    LTE             reduce using rule 48 (expr -> STRING .)
    EQ              reduce using rule 48 (expr -> STRING .)
    NEQ             reduce using rule 48 (expr -> STRING .)
    $               reduce using rule 48 (expr -> STRING .)
    )               reduce using rule 48 (expr -> STRING .)
    ,               reduce using rule 48 (expr -> STRING .)
    ]               reduce using rule 48 (expr -> STRING .)


state 27

    (49) expr -> NUM .

    ;               reduce using rule 49 (expr -> NUM .)
    +               reduce using rule 49 (expr -> NUM .)
    -               reduce using rule 49 (expr -> NUM .)
    *               reduce using rule 49 (expr -> NUM .)
    /               reduce using rule 49 (expr -> NUM .)
    %               reduce using rule 49 (expr -> NUM .)
    OR              reduce using rule 49 (expr -> NUM .)
    AND             reduce using rule 49 (expr -> NUM .)
    >               reduce using rule 49 (expr -> NUM .)
    <               reduce using rule 49 (expr -> NUM .)
    GTE             reduce using rule 49 (expr -> NUM .)
    LTE             reduce using rule 49 (expr -> NUM .)
    EQ              reduce using rule 49 (expr -> NUM .)
    NEQ             reduce using rule 49 (expr -> NUM .)
    $               reduce using rule 49 (expr -> NUM .)
    )               reduce using rule 49 (expr -> NUM .)
    ,               reduce using rule 49 (expr -> NUM .)
    ]               reduce using rule 49 (expr -> NUM .)


state 28

    (50) expr -> TRUE .

    ;               reduce using rule 50 (expr -> TRUE .)
    +               reduce using rule 50 (expr -> TRUE .)
    -               reduce using rule 50 (expr -> TRUE .)
    *               reduce using rule 50 (expr -> TRUE .)
    /               reduce using rule 50 (expr -> TRUE .)
    %               reduce using rule 50 (expr -> TRUE .)
    OR              reduce using rule 50 (expr -> TRUE .)
    AND             reduce using rule 50 (expr -> TRUE .)
    >               reduce using rule 50 (expr -> TRUE .)
    <               reduce using rule 50 (expr -> TRUE .)
    GTE             reduce using rule 50 (expr -> TRUE .)
    LTE             reduce using rule 50 (expr -> TRUE .)
    EQ              reduce using rule 50 (expr -> TRUE .)
    NEQ             reduce using rule 50 (expr -> TRUE .)
    $               reduce using rule 50 (expr -> TRUE .)
    )               reduce using rule 50 (expr -> TRUE .)
    ,               reduce using rule 50 (expr -> TRUE .)
    ]               reduce using rule 50 (expr -> TRUE .)


state 29

    (51) expr -> FALSE .

    ;               reduce using rule 51 (expr -> FALSE .)
    +               reduce using rule 51 (expr -> FALSE .)
    -               reduce using rule 51 (expr -> FALSE .)
    *               reduce using rule 51 (expr -> FALSE .)
    /               reduce using rule 51 (expr -> FALSE .)
    %               reduce using rule 51 (expr -> FALSE .)
    OR              reduce using rule 51 (expr -> FALSE .)
    AND             reduce using rule 51 (expr -> FALSE .)
    >               reduce using rule 51 (expr -> FALSE .)
    <               reduce using rule 51 (expr -> FALSE .)
    GTE             reduce using rule 51 (expr -> FALSE .)
    LTE             reduce using rule 51 (expr -> FALSE .)
    EQ              reduce using rule 51 (expr -> FALSE .)
    NEQ             reduce using rule 51 (expr -> FALSE .)
    $               reduce using rule 51 (expr -> FALSE .)
    )               reduce using rule 51 (expr -> FALSE .)
    ,               reduce using rule 51 (expr -> FALSE .)
    ]               reduce using rule 51 (expr -> FALSE .)


state 30

    (18) var_declare -> VAR ID [ NUM . ] ;

    ]               shift and go to state 65


state 31

    (59) stmtlist -> stmtlist stmt .

    PRINT           reduce using rule 59 (stmtlist -> stmtlist stmt .)
    PRINTLN         reduce using rule 59 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 59 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 59 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 59 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 59 (stmtlist -> stmtlist stmt .)
    PRINTI          reduce using rule 59 (stmtlist -> stmtlist stmt .)
    INPUT           reduce using rule 59 (stmtlist -> stmtlist stmt .)
    STR             reduce using rule 59 (stmtlist -> stmtlist stmt .)
    ATOI            reduce using rule 59 (stmtlist -> stmtlist stmt .)
    !               reduce using rule 59 (stmtlist -> stmtlist stmt .)
    -               reduce using rule 59 (stmtlist -> stmtlist stmt .)
    STRING          reduce using rule 59 (stmtlist -> stmtlist stmt .)
    NUM             reduce using rule 59 (stmtlist -> stmtlist stmt .)
    TRUE            reduce using rule 59 (stmtlist -> stmtlist stmt .)
    FALSE           reduce using rule 59 (stmtlist -> stmtlist stmt .)
    (               reduce using rule 59 (stmtlist -> stmtlist stmt .)
    $end            reduce using rule 59 (stmtlist -> stmtlist stmt .)
    }               reduce using rule 59 (stmtlist -> stmtlist stmt .)


state 32

    (7) stmt -> PRINT . ( expr ) ;

    (               shift and go to state 66


state 33

    (26) stmt -> expr . ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               shift and go to state 67
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 34

    (8) stmt -> PRINTLN . ( ) ;

    (               shift and go to state 68


state 35

    (9) stmt -> WHILE . new_label ( expr ) jz block
    (15) new_label -> .

    (               reduce using rule 15 (new_label -> .)

    new_label                      shift and go to state 69

state 36

    (10) stmt -> IF . ( expr ) jz block
    (11) stmt -> IF . ( expr ) jz block ELSE jmp jz_label block

    (               shift and go to state 70


state 37

    (19) stmt -> ID . = expr ;
    (22) arr_id -> ID .
    (46) expr -> ID .
    (52) expr -> ID . ( exprlist )
    (53) expr -> ID . ( )

    =               shift and go to state 71
    [               reduce using rule 22 (arr_id -> ID .)
    ;               reduce using rule 46 (expr -> ID .)
    +               reduce using rule 46 (expr -> ID .)
    -               reduce using rule 46 (expr -> ID .)
    *               reduce using rule 46 (expr -> ID .)
    /               reduce using rule 46 (expr -> ID .)
    %               reduce using rule 46 (expr -> ID .)
    OR              reduce using rule 46 (expr -> ID .)
    AND             reduce using rule 46 (expr -> ID .)
    >               reduce using rule 46 (expr -> ID .)
    <               reduce using rule 46 (expr -> ID .)
    GTE             reduce using rule 46 (expr -> ID .)
    LTE             reduce using rule 46 (expr -> ID .)
    EQ              reduce using rule 46 (expr -> ID .)
    NEQ             reduce using rule 46 (expr -> ID .)
    $               reduce using rule 46 (expr -> ID .)
    (               shift and go to state 42


state 38

    (20) stmt -> arr_id . [ expr ] add = expr ;
    (47) expr -> arr_id . [ expr ]

    [               shift and go to state 72


state 39

    (23) stmt -> RETURN . expr ;
    (24) stmt -> RETURN . ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    ;               shift and go to state 74
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 73
    arr_id                         shift and go to state 25

state 40

    (25) stmt -> PRINTI . ( expr ) ;

    (               shift and go to state 75


state 41

    (4) fun -> DEF fun_name ( . idlist ) block
    (5) fun -> DEF fun_name ( . ) block
    (61) idlist -> . idlist , ID
    (62) idlist -> . ID

    )               shift and go to state 77
    ID              shift and go to state 78

    idlist                         shift and go to state 76

state 42

    (52) expr -> ID ( . exprlist )
    (53) expr -> ID ( . )
    (63) exprlist -> . exprlist , expr
    (64) exprlist -> . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    )               shift and go to state 80
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    exprlist                       shift and go to state 79
    expr                           shift and go to state 81
    arr_id                         shift and go to state 25

state 43

    (16) var_declare -> VAR ID = expr ; .

    VAR             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    DEF             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    PRINT           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    PRINTLN         reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    WHILE           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    IF              reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    ID              reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    RETURN          reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    PRINTI          reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    INPUT           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    STR             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    ATOI            reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    !               reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    -               reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    STRING          reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    NUM             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    TRUE            reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    FALSE           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    (               reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    $end            reduce using rule 16 (var_declare -> VAR ID = expr ; .)


state 44

    (30) expr -> expr + . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 82
    arr_id                         shift and go to state 25

state 45

    (31) expr -> expr - . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 83
    arr_id                         shift and go to state 25

state 46

    (32) expr -> expr * . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 84
    arr_id                         shift and go to state 25

state 47

    (33) expr -> expr / . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 85
    arr_id                         shift and go to state 25

state 48

    (34) expr -> expr % . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 86
    arr_id                         shift and go to state 25

state 49

    (35) expr -> expr OR . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 87
    arr_id                         shift and go to state 25

state 50

    (36) expr -> expr AND . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 88
    arr_id                         shift and go to state 25

state 51

    (37) expr -> expr > . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 89
    arr_id                         shift and go to state 25

state 52

    (38) expr -> expr < . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 90
    arr_id                         shift and go to state 25

state 53

    (39) expr -> expr GTE . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 91
    arr_id                         shift and go to state 25

state 54

    (40) expr -> expr LTE . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 92
    arr_id                         shift and go to state 25

state 55

    (41) expr -> expr EQ . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 93
    arr_id                         shift and go to state 25

state 56

    (42) expr -> expr NEQ . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 94
    arr_id                         shift and go to state 25

state 57

    (43) expr -> expr $ . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 95
    arr_id                         shift and go to state 25

state 58

    (27) expr -> INPUT ( . )

    )               shift and go to state 96


state 59

    (54) expr -> ( expr . )
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    )               shift and go to state 97
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 60

    (28) expr -> STR ( . expr )
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 98
    arr_id                         shift and go to state 25

state 61

    (29) expr -> ATOI ( . expr )
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 99
    arr_id                         shift and go to state 25

state 62

    (45) expr -> - expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 45 (expr -> - expr .)
    +               reduce using rule 45 (expr -> - expr .)
    -               reduce using rule 45 (expr -> - expr .)
    *               reduce using rule 45 (expr -> - expr .)
    /               reduce using rule 45 (expr -> - expr .)
    %               reduce using rule 45 (expr -> - expr .)
    OR              reduce using rule 45 (expr -> - expr .)
    AND             reduce using rule 45 (expr -> - expr .)
    >               reduce using rule 45 (expr -> - expr .)
    <               reduce using rule 45 (expr -> - expr .)
    GTE             reduce using rule 45 (expr -> - expr .)
    LTE             reduce using rule 45 (expr -> - expr .)
    EQ              reduce using rule 45 (expr -> - expr .)
    NEQ             reduce using rule 45 (expr -> - expr .)
    $               reduce using rule 45 (expr -> - expr .)
    )               reduce using rule 45 (expr -> - expr .)
    ,               reduce using rule 45 (expr -> - expr .)
    ]               reduce using rule 45 (expr -> - expr .)

  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! /               [ shift and go to state 47 ]
  ! %               [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]


state 63

    (44) expr -> ! expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 44 (expr -> ! expr .)
    +               reduce using rule 44 (expr -> ! expr .)
    -               reduce using rule 44 (expr -> ! expr .)
    *               reduce using rule 44 (expr -> ! expr .)
    /               reduce using rule 44 (expr -> ! expr .)
    %               reduce using rule 44 (expr -> ! expr .)
    OR              reduce using rule 44 (expr -> ! expr .)
    AND             reduce using rule 44 (expr -> ! expr .)
    >               reduce using rule 44 (expr -> ! expr .)
    <               reduce using rule 44 (expr -> ! expr .)
    GTE             reduce using rule 44 (expr -> ! expr .)
    LTE             reduce using rule 44 (expr -> ! expr .)
    EQ              reduce using rule 44 (expr -> ! expr .)
    NEQ             reduce using rule 44 (expr -> ! expr .)
    $               reduce using rule 44 (expr -> ! expr .)
    )               reduce using rule 44 (expr -> ! expr .)
    ,               reduce using rule 44 (expr -> ! expr .)
    ]               reduce using rule 44 (expr -> ! expr .)

  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! /               [ shift and go to state 47 ]
  ! %               [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]


state 64

    (47) expr -> arr_id [ . expr ]
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    arr_id                         shift and go to state 25
    expr                           shift and go to state 100

state 65

    (18) var_declare -> VAR ID [ NUM ] . ;

    ;               shift and go to state 101


state 66

    (7) stmt -> PRINT ( . expr ) ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 102
    arr_id                         shift and go to state 25

state 67

    (26) stmt -> expr ; .

    PRINT           reduce using rule 26 (stmt -> expr ; .)
    PRINTLN         reduce using rule 26 (stmt -> expr ; .)
    WHILE           reduce using rule 26 (stmt -> expr ; .)
    IF              reduce using rule 26 (stmt -> expr ; .)
    ID              reduce using rule 26 (stmt -> expr ; .)
    RETURN          reduce using rule 26 (stmt -> expr ; .)
    PRINTI          reduce using rule 26 (stmt -> expr ; .)
    INPUT           reduce using rule 26 (stmt -> expr ; .)
    STR             reduce using rule 26 (stmt -> expr ; .)
    ATOI            reduce using rule 26 (stmt -> expr ; .)
    !               reduce using rule 26 (stmt -> expr ; .)
    -               reduce using rule 26 (stmt -> expr ; .)
    STRING          reduce using rule 26 (stmt -> expr ; .)
    NUM             reduce using rule 26 (stmt -> expr ; .)
    TRUE            reduce using rule 26 (stmt -> expr ; .)
    FALSE           reduce using rule 26 (stmt -> expr ; .)
    (               reduce using rule 26 (stmt -> expr ; .)
    $end            reduce using rule 26 (stmt -> expr ; .)
    DEF             reduce using rule 26 (stmt -> expr ; .)
    }               reduce using rule 26 (stmt -> expr ; .)
    ELSE            reduce using rule 26 (stmt -> expr ; .)


state 68

    (8) stmt -> PRINTLN ( . ) ;

    )               shift and go to state 103


state 69

    (9) stmt -> WHILE new_label . ( expr ) jz block

    (               shift and go to state 104


state 70

    (10) stmt -> IF ( . expr ) jz block
    (11) stmt -> IF ( . expr ) jz block ELSE jmp jz_label block
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 105
    arr_id                         shift and go to state 25

state 71

    (19) stmt -> ID = . expr ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 106
    arr_id                         shift and go to state 25

state 72

    (20) stmt -> arr_id [ . expr ] add = expr ;
    (47) expr -> arr_id [ . expr ]
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    arr_id                         shift and go to state 25
    expr                           shift and go to state 107

state 73

    (23) stmt -> RETURN expr . ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               shift and go to state 108
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 74

    (24) stmt -> RETURN ; .

    PRINT           reduce using rule 24 (stmt -> RETURN ; .)
    PRINTLN         reduce using rule 24 (stmt -> RETURN ; .)
    WHILE           reduce using rule 24 (stmt -> RETURN ; .)
    IF              reduce using rule 24 (stmt -> RETURN ; .)
    ID              reduce using rule 24 (stmt -> RETURN ; .)
    RETURN          reduce using rule 24 (stmt -> RETURN ; .)
    PRINTI          reduce using rule 24 (stmt -> RETURN ; .)
    INPUT           reduce using rule 24 (stmt -> RETURN ; .)
    STR             reduce using rule 24 (stmt -> RETURN ; .)
    ATOI            reduce using rule 24 (stmt -> RETURN ; .)
    !               reduce using rule 24 (stmt -> RETURN ; .)
    -               reduce using rule 24 (stmt -> RETURN ; .)
    STRING          reduce using rule 24 (stmt -> RETURN ; .)
    NUM             reduce using rule 24 (stmt -> RETURN ; .)
    TRUE            reduce using rule 24 (stmt -> RETURN ; .)
    FALSE           reduce using rule 24 (stmt -> RETURN ; .)
    (               reduce using rule 24 (stmt -> RETURN ; .)
    $end            reduce using rule 24 (stmt -> RETURN ; .)
    DEF             reduce using rule 24 (stmt -> RETURN ; .)
    }               reduce using rule 24 (stmt -> RETURN ; .)
    ELSE            reduce using rule 24 (stmt -> RETURN ; .)


state 75

    (25) stmt -> PRINTI ( . expr ) ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 109
    arr_id                         shift and go to state 25

state 76

    (4) fun -> DEF fun_name ( idlist . ) block
    (61) idlist -> idlist . , ID

    )               shift and go to state 110
    ,               shift and go to state 111


state 77

    (5) fun -> DEF fun_name ( ) . block
    (65) block -> . { stmtlist }
    (66) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . arr_id [ expr ] add = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )

    {               shift and go to state 113
    PRINT           shift and go to state 32
    PRINTLN         shift and go to state 34
    WHILE           shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    block                          shift and go to state 112
    stmt                           shift and go to state 114
    expr                           shift and go to state 33
    arr_id                         shift and go to state 38

state 78

    (62) idlist -> ID .

    )               reduce using rule 62 (idlist -> ID .)
    ,               reduce using rule 62 (idlist -> ID .)


state 79

    (52) expr -> ID ( exprlist . )
    (63) exprlist -> exprlist . , expr

    )               shift and go to state 115
    ,               shift and go to state 116


state 80

    (53) expr -> ID ( ) .

    ;               reduce using rule 53 (expr -> ID ( ) .)
    +               reduce using rule 53 (expr -> ID ( ) .)
    -               reduce using rule 53 (expr -> ID ( ) .)
    *               reduce using rule 53 (expr -> ID ( ) .)
    /               reduce using rule 53 (expr -> ID ( ) .)
    %               reduce using rule 53 (expr -> ID ( ) .)
    OR              reduce using rule 53 (expr -> ID ( ) .)
    AND             reduce using rule 53 (expr -> ID ( ) .)
    >               reduce using rule 53 (expr -> ID ( ) .)
    <               reduce using rule 53 (expr -> ID ( ) .)
    GTE             reduce using rule 53 (expr -> ID ( ) .)
    LTE             reduce using rule 53 (expr -> ID ( ) .)
    EQ              reduce using rule 53 (expr -> ID ( ) .)
    NEQ             reduce using rule 53 (expr -> ID ( ) .)
    $               reduce using rule 53 (expr -> ID ( ) .)
    )               reduce using rule 53 (expr -> ID ( ) .)
    ,               reduce using rule 53 (expr -> ID ( ) .)
    ]               reduce using rule 53 (expr -> ID ( ) .)


state 81

    (64) exprlist -> expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    )               reduce using rule 64 (exprlist -> expr .)
    ,               reduce using rule 64 (exprlist -> expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 82

    (30) expr -> expr + expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 30 (expr -> expr + expr .)
    +               reduce using rule 30 (expr -> expr + expr .)
    -               reduce using rule 30 (expr -> expr + expr .)
    OR              reduce using rule 30 (expr -> expr + expr .)
    AND             reduce using rule 30 (expr -> expr + expr .)
    >               reduce using rule 30 (expr -> expr + expr .)
    <               reduce using rule 30 (expr -> expr + expr .)
    GTE             reduce using rule 30 (expr -> expr + expr .)
    LTE             reduce using rule 30 (expr -> expr + expr .)
    EQ              reduce using rule 30 (expr -> expr + expr .)
    NEQ             reduce using rule 30 (expr -> expr + expr .)
    $               reduce using rule 30 (expr -> expr + expr .)
    )               reduce using rule 30 (expr -> expr + expr .)
    ,               reduce using rule 30 (expr -> expr + expr .)
    ]               reduce using rule 30 (expr -> expr + expr .)
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48

  ! *               [ reduce using rule 30 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 30 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 30 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]


state 83

    (31) expr -> expr - expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 31 (expr -> expr - expr .)
    +               reduce using rule 31 (expr -> expr - expr .)
    -               reduce using rule 31 (expr -> expr - expr .)
    OR              reduce using rule 31 (expr -> expr - expr .)
    AND             reduce using rule 31 (expr -> expr - expr .)
    >               reduce using rule 31 (expr -> expr - expr .)
    <               reduce using rule 31 (expr -> expr - expr .)
    GTE             reduce using rule 31 (expr -> expr - expr .)
    LTE             reduce using rule 31 (expr -> expr - expr .)
    EQ              reduce using rule 31 (expr -> expr - expr .)
    NEQ             reduce using rule 31 (expr -> expr - expr .)
    $               reduce using rule 31 (expr -> expr - expr .)
    )               reduce using rule 31 (expr -> expr - expr .)
    ,               reduce using rule 31 (expr -> expr - expr .)
    ]               reduce using rule 31 (expr -> expr - expr .)
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48

  ! *               [ reduce using rule 31 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 31 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 31 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]


state 84

    (32) expr -> expr * expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 32 (expr -> expr * expr .)
    +               reduce using rule 32 (expr -> expr * expr .)
    -               reduce using rule 32 (expr -> expr * expr .)
    *               reduce using rule 32 (expr -> expr * expr .)
    /               reduce using rule 32 (expr -> expr * expr .)
    %               reduce using rule 32 (expr -> expr * expr .)
    OR              reduce using rule 32 (expr -> expr * expr .)
    AND             reduce using rule 32 (expr -> expr * expr .)
    >               reduce using rule 32 (expr -> expr * expr .)
    <               reduce using rule 32 (expr -> expr * expr .)
    GTE             reduce using rule 32 (expr -> expr * expr .)
    LTE             reduce using rule 32 (expr -> expr * expr .)
    EQ              reduce using rule 32 (expr -> expr * expr .)
    NEQ             reduce using rule 32 (expr -> expr * expr .)
    $               reduce using rule 32 (expr -> expr * expr .)
    )               reduce using rule 32 (expr -> expr * expr .)
    ,               reduce using rule 32 (expr -> expr * expr .)
    ]               reduce using rule 32 (expr -> expr * expr .)

  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! /               [ shift and go to state 47 ]
  ! %               [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]


state 85

    (33) expr -> expr / expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 33 (expr -> expr / expr .)
    +               reduce using rule 33 (expr -> expr / expr .)
    -               reduce using rule 33 (expr -> expr / expr .)
    *               reduce using rule 33 (expr -> expr / expr .)
    /               reduce using rule 33 (expr -> expr / expr .)
    %               reduce using rule 33 (expr -> expr / expr .)
    OR              reduce using rule 33 (expr -> expr / expr .)
    AND             reduce using rule 33 (expr -> expr / expr .)
    >               reduce using rule 33 (expr -> expr / expr .)
    <               reduce using rule 33 (expr -> expr / expr .)
    GTE             reduce using rule 33 (expr -> expr / expr .)
    LTE             reduce using rule 33 (expr -> expr / expr .)
    EQ              reduce using rule 33 (expr -> expr / expr .)
    NEQ             reduce using rule 33 (expr -> expr / expr .)
    $               reduce using rule 33 (expr -> expr / expr .)
    )               reduce using rule 33 (expr -> expr / expr .)
    ,               reduce using rule 33 (expr -> expr / expr .)
    ]               reduce using rule 33 (expr -> expr / expr .)

  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! /               [ shift and go to state 47 ]
  ! %               [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]


state 86

    (34) expr -> expr % expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 34 (expr -> expr % expr .)
    +               reduce using rule 34 (expr -> expr % expr .)
    -               reduce using rule 34 (expr -> expr % expr .)
    *               reduce using rule 34 (expr -> expr % expr .)
    /               reduce using rule 34 (expr -> expr % expr .)
    %               reduce using rule 34 (expr -> expr % expr .)
    OR              reduce using rule 34 (expr -> expr % expr .)
    AND             reduce using rule 34 (expr -> expr % expr .)
    >               reduce using rule 34 (expr -> expr % expr .)
    <               reduce using rule 34 (expr -> expr % expr .)
    GTE             reduce using rule 34 (expr -> expr % expr .)
    LTE             reduce using rule 34 (expr -> expr % expr .)
    EQ              reduce using rule 34 (expr -> expr % expr .)
    NEQ             reduce using rule 34 (expr -> expr % expr .)
    $               reduce using rule 34 (expr -> expr % expr .)
    )               reduce using rule 34 (expr -> expr % expr .)
    ,               reduce using rule 34 (expr -> expr % expr .)
    ]               reduce using rule 34 (expr -> expr % expr .)

  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! /               [ shift and go to state 47 ]
  ! %               [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]


state 87

    (35) expr -> expr OR expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 35 (expr -> expr OR expr .)
    OR              reduce using rule 35 (expr -> expr OR expr .)
    AND             reduce using rule 35 (expr -> expr OR expr .)
    EQ              reduce using rule 35 (expr -> expr OR expr .)
    NEQ             reduce using rule 35 (expr -> expr OR expr .)
    )               reduce using rule 35 (expr -> expr OR expr .)
    ,               reduce using rule 35 (expr -> expr OR expr .)
    ]               reduce using rule 35 (expr -> expr OR expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    $               shift and go to state 57

  ! +               [ reduce using rule 35 (expr -> expr OR expr .) ]
  ! -               [ reduce using rule 35 (expr -> expr OR expr .) ]
  ! *               [ reduce using rule 35 (expr -> expr OR expr .) ]
  ! /               [ reduce using rule 35 (expr -> expr OR expr .) ]
  ! %               [ reduce using rule 35 (expr -> expr OR expr .) ]
  ! >               [ reduce using rule 35 (expr -> expr OR expr .) ]
  ! <               [ reduce using rule 35 (expr -> expr OR expr .) ]
  ! GTE             [ reduce using rule 35 (expr -> expr OR expr .) ]
  ! LTE             [ reduce using rule 35 (expr -> expr OR expr .) ]
  ! $               [ reduce using rule 35 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]


state 88

    (36) expr -> expr AND expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 36 (expr -> expr AND expr .)
    OR              reduce using rule 36 (expr -> expr AND expr .)
    AND             reduce using rule 36 (expr -> expr AND expr .)
    EQ              reduce using rule 36 (expr -> expr AND expr .)
    NEQ             reduce using rule 36 (expr -> expr AND expr .)
    )               reduce using rule 36 (expr -> expr AND expr .)
    ,               reduce using rule 36 (expr -> expr AND expr .)
    ]               reduce using rule 36 (expr -> expr AND expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    $               shift and go to state 57

  ! +               [ reduce using rule 36 (expr -> expr AND expr .) ]
  ! -               [ reduce using rule 36 (expr -> expr AND expr .) ]
  ! *               [ reduce using rule 36 (expr -> expr AND expr .) ]
  ! /               [ reduce using rule 36 (expr -> expr AND expr .) ]
  ! %               [ reduce using rule 36 (expr -> expr AND expr .) ]
  ! >               [ reduce using rule 36 (expr -> expr AND expr .) ]
  ! <               [ reduce using rule 36 (expr -> expr AND expr .) ]
  ! GTE             [ reduce using rule 36 (expr -> expr AND expr .) ]
  ! LTE             [ reduce using rule 36 (expr -> expr AND expr .) ]
  ! $               [ reduce using rule 36 (expr -> expr AND expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]


state 89

    (37) expr -> expr > expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 37 (expr -> expr > expr .)
    OR              reduce using rule 37 (expr -> expr > expr .)
    AND             reduce using rule 37 (expr -> expr > expr .)
    >               reduce using rule 37 (expr -> expr > expr .)
    <               reduce using rule 37 (expr -> expr > expr .)
    GTE             reduce using rule 37 (expr -> expr > expr .)
    LTE             reduce using rule 37 (expr -> expr > expr .)
    EQ              reduce using rule 37 (expr -> expr > expr .)
    NEQ             reduce using rule 37 (expr -> expr > expr .)
    )               reduce using rule 37 (expr -> expr > expr .)
    ,               reduce using rule 37 (expr -> expr > expr .)
    ]               reduce using rule 37 (expr -> expr > expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    $               shift and go to state 57

  ! +               [ reduce using rule 37 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 37 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 37 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 37 (expr -> expr > expr .) ]
  ! %               [ reduce using rule 37 (expr -> expr > expr .) ]
  ! $               [ reduce using rule 37 (expr -> expr > expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]


state 90

    (38) expr -> expr < expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 38 (expr -> expr < expr .)
    OR              reduce using rule 38 (expr -> expr < expr .)
    AND             reduce using rule 38 (expr -> expr < expr .)
    >               reduce using rule 38 (expr -> expr < expr .)
    <               reduce using rule 38 (expr -> expr < expr .)
    GTE             reduce using rule 38 (expr -> expr < expr .)
    LTE             reduce using rule 38 (expr -> expr < expr .)
    EQ              reduce using rule 38 (expr -> expr < expr .)
    NEQ             reduce using rule 38 (expr -> expr < expr .)
    )               reduce using rule 38 (expr -> expr < expr .)
    ,               reduce using rule 38 (expr -> expr < expr .)
    ]               reduce using rule 38 (expr -> expr < expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    $               shift and go to state 57

  ! +               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! %               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! $               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]


state 91

    (39) expr -> expr GTE expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 39 (expr -> expr GTE expr .)
    OR              reduce using rule 39 (expr -> expr GTE expr .)
    AND             reduce using rule 39 (expr -> expr GTE expr .)
    >               reduce using rule 39 (expr -> expr GTE expr .)
    <               reduce using rule 39 (expr -> expr GTE expr .)
    GTE             reduce using rule 39 (expr -> expr GTE expr .)
    LTE             reduce using rule 39 (expr -> expr GTE expr .)
    EQ              reduce using rule 39 (expr -> expr GTE expr .)
    NEQ             reduce using rule 39 (expr -> expr GTE expr .)
    )               reduce using rule 39 (expr -> expr GTE expr .)
    ,               reduce using rule 39 (expr -> expr GTE expr .)
    ]               reduce using rule 39 (expr -> expr GTE expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    $               shift and go to state 57

  ! +               [ reduce using rule 39 (expr -> expr GTE expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr GTE expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr GTE expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr GTE expr .) ]
  ! %               [ reduce using rule 39 (expr -> expr GTE expr .) ]
  ! $               [ reduce using rule 39 (expr -> expr GTE expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]


state 92

    (40) expr -> expr LTE expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 40 (expr -> expr LTE expr .)
    OR              reduce using rule 40 (expr -> expr LTE expr .)
    AND             reduce using rule 40 (expr -> expr LTE expr .)
    >               reduce using rule 40 (expr -> expr LTE expr .)
    <               reduce using rule 40 (expr -> expr LTE expr .)
    GTE             reduce using rule 40 (expr -> expr LTE expr .)
    LTE             reduce using rule 40 (expr -> expr LTE expr .)
    EQ              reduce using rule 40 (expr -> expr LTE expr .)
    NEQ             reduce using rule 40 (expr -> expr LTE expr .)
    )               reduce using rule 40 (expr -> expr LTE expr .)
    ,               reduce using rule 40 (expr -> expr LTE expr .)
    ]               reduce using rule 40 (expr -> expr LTE expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    $               shift and go to state 57

  ! +               [ reduce using rule 40 (expr -> expr LTE expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr LTE expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr LTE expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr LTE expr .) ]
  ! %               [ reduce using rule 40 (expr -> expr LTE expr .) ]
  ! $               [ reduce using rule 40 (expr -> expr LTE expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]


state 93

    (41) expr -> expr EQ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 41 (expr -> expr EQ expr .)
    OR              reduce using rule 41 (expr -> expr EQ expr .)
    AND             reduce using rule 41 (expr -> expr EQ expr .)
    EQ              reduce using rule 41 (expr -> expr EQ expr .)
    NEQ             reduce using rule 41 (expr -> expr EQ expr .)
    )               reduce using rule 41 (expr -> expr EQ expr .)
    ,               reduce using rule 41 (expr -> expr EQ expr .)
    ]               reduce using rule 41 (expr -> expr EQ expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    $               shift and go to state 57

  ! +               [ reduce using rule 41 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 41 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 41 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr EQ expr .) ]
  ! %               [ reduce using rule 41 (expr -> expr EQ expr .) ]
  ! >               [ reduce using rule 41 (expr -> expr EQ expr .) ]
  ! <               [ reduce using rule 41 (expr -> expr EQ expr .) ]
  ! GTE             [ reduce using rule 41 (expr -> expr EQ expr .) ]
  ! LTE             [ reduce using rule 41 (expr -> expr EQ expr .) ]
  ! $               [ reduce using rule 41 (expr -> expr EQ expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]


state 94

    (42) expr -> expr NEQ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 42 (expr -> expr NEQ expr .)
    OR              reduce using rule 42 (expr -> expr NEQ expr .)
    AND             reduce using rule 42 (expr -> expr NEQ expr .)
    EQ              reduce using rule 42 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 42 (expr -> expr NEQ expr .)
    )               reduce using rule 42 (expr -> expr NEQ expr .)
    ,               reduce using rule 42 (expr -> expr NEQ expr .)
    ]               reduce using rule 42 (expr -> expr NEQ expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    $               shift and go to state 57

  ! +               [ reduce using rule 42 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 42 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 42 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 42 (expr -> expr NEQ expr .) ]
  ! %               [ reduce using rule 42 (expr -> expr NEQ expr .) ]
  ! >               [ reduce using rule 42 (expr -> expr NEQ expr .) ]
  ! <               [ reduce using rule 42 (expr -> expr NEQ expr .) ]
  ! GTE             [ reduce using rule 42 (expr -> expr NEQ expr .) ]
  ! LTE             [ reduce using rule 42 (expr -> expr NEQ expr .) ]
  ! $               [ reduce using rule 42 (expr -> expr NEQ expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]


state 95

    (43) expr -> expr $ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               reduce using rule 43 (expr -> expr $ expr .)
    +               reduce using rule 43 (expr -> expr $ expr .)
    -               reduce using rule 43 (expr -> expr $ expr .)
    OR              reduce using rule 43 (expr -> expr $ expr .)
    AND             reduce using rule 43 (expr -> expr $ expr .)
    >               reduce using rule 43 (expr -> expr $ expr .)
    <               reduce using rule 43 (expr -> expr $ expr .)
    GTE             reduce using rule 43 (expr -> expr $ expr .)
    LTE             reduce using rule 43 (expr -> expr $ expr .)
    EQ              reduce using rule 43 (expr -> expr $ expr .)
    NEQ             reduce using rule 43 (expr -> expr $ expr .)
    $               reduce using rule 43 (expr -> expr $ expr .)
    )               reduce using rule 43 (expr -> expr $ expr .)
    ,               reduce using rule 43 (expr -> expr $ expr .)
    ]               reduce using rule 43 (expr -> expr $ expr .)
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48

  ! *               [ reduce using rule 43 (expr -> expr $ expr .) ]
  ! /               [ reduce using rule 43 (expr -> expr $ expr .) ]
  ! %               [ reduce using rule 43 (expr -> expr $ expr .) ]
  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]


state 96

    (27) expr -> INPUT ( ) .

    ;               reduce using rule 27 (expr -> INPUT ( ) .)
    +               reduce using rule 27 (expr -> INPUT ( ) .)
    -               reduce using rule 27 (expr -> INPUT ( ) .)
    *               reduce using rule 27 (expr -> INPUT ( ) .)
    /               reduce using rule 27 (expr -> INPUT ( ) .)
    %               reduce using rule 27 (expr -> INPUT ( ) .)
    OR              reduce using rule 27 (expr -> INPUT ( ) .)
    AND             reduce using rule 27 (expr -> INPUT ( ) .)
    >               reduce using rule 27 (expr -> INPUT ( ) .)
    <               reduce using rule 27 (expr -> INPUT ( ) .)
    GTE             reduce using rule 27 (expr -> INPUT ( ) .)
    LTE             reduce using rule 27 (expr -> INPUT ( ) .)
    EQ              reduce using rule 27 (expr -> INPUT ( ) .)
    NEQ             reduce using rule 27 (expr -> INPUT ( ) .)
    $               reduce using rule 27 (expr -> INPUT ( ) .)
    )               reduce using rule 27 (expr -> INPUT ( ) .)
    ,               reduce using rule 27 (expr -> INPUT ( ) .)
    ]               reduce using rule 27 (expr -> INPUT ( ) .)


state 97

    (54) expr -> ( expr ) .

    ;               reduce using rule 54 (expr -> ( expr ) .)
    +               reduce using rule 54 (expr -> ( expr ) .)
    -               reduce using rule 54 (expr -> ( expr ) .)
    *               reduce using rule 54 (expr -> ( expr ) .)
    /               reduce using rule 54 (expr -> ( expr ) .)
    %               reduce using rule 54 (expr -> ( expr ) .)
    OR              reduce using rule 54 (expr -> ( expr ) .)
    AND             reduce using rule 54 (expr -> ( expr ) .)
    >               reduce using rule 54 (expr -> ( expr ) .)
    <               reduce using rule 54 (expr -> ( expr ) .)
    GTE             reduce using rule 54 (expr -> ( expr ) .)
    LTE             reduce using rule 54 (expr -> ( expr ) .)
    EQ              reduce using rule 54 (expr -> ( expr ) .)
    NEQ             reduce using rule 54 (expr -> ( expr ) .)
    $               reduce using rule 54 (expr -> ( expr ) .)
    )               reduce using rule 54 (expr -> ( expr ) .)
    ,               reduce using rule 54 (expr -> ( expr ) .)
    ]               reduce using rule 54 (expr -> ( expr ) .)


state 98

    (28) expr -> STR ( expr . )
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    )               shift and go to state 117
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 99

    (29) expr -> ATOI ( expr . )
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    )               shift and go to state 118
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 100

    (47) expr -> arr_id [ expr . ]
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ]               shift and go to state 119
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 101

    (18) var_declare -> VAR ID [ NUM ] ; .

    VAR             reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    DEF             reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    PRINT           reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    PRINTLN         reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    WHILE           reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    IF              reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    ID              reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    RETURN          reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    PRINTI          reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    INPUT           reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    STR             reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    ATOI            reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    !               reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    -               reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    STRING          reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    NUM             reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    TRUE            reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    FALSE           reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    (               reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    $end            reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)


state 102

    (7) stmt -> PRINT ( expr . ) ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    )               shift and go to state 120
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 103

    (8) stmt -> PRINTLN ( ) . ;

    ;               shift and go to state 121


state 104

    (9) stmt -> WHILE new_label ( . expr ) jz block
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 122
    arr_id                         shift and go to state 25

state 105

    (10) stmt -> IF ( expr . ) jz block
    (11) stmt -> IF ( expr . ) jz block ELSE jmp jz_label block
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    )               shift and go to state 123
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 106

    (19) stmt -> ID = expr . ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               shift and go to state 124
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 107

    (20) stmt -> arr_id [ expr . ] add = expr ;
    (47) expr -> arr_id [ expr . ]
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ]               shift and go to state 125
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 108

    (23) stmt -> RETURN expr ; .

    PRINT           reduce using rule 23 (stmt -> RETURN expr ; .)
    PRINTLN         reduce using rule 23 (stmt -> RETURN expr ; .)
    WHILE           reduce using rule 23 (stmt -> RETURN expr ; .)
    IF              reduce using rule 23 (stmt -> RETURN expr ; .)
    ID              reduce using rule 23 (stmt -> RETURN expr ; .)
    RETURN          reduce using rule 23 (stmt -> RETURN expr ; .)
    PRINTI          reduce using rule 23 (stmt -> RETURN expr ; .)
    INPUT           reduce using rule 23 (stmt -> RETURN expr ; .)
    STR             reduce using rule 23 (stmt -> RETURN expr ; .)
    ATOI            reduce using rule 23 (stmt -> RETURN expr ; .)
    !               reduce using rule 23 (stmt -> RETURN expr ; .)
    -               reduce using rule 23 (stmt -> RETURN expr ; .)
    STRING          reduce using rule 23 (stmt -> RETURN expr ; .)
    NUM             reduce using rule 23 (stmt -> RETURN expr ; .)
    TRUE            reduce using rule 23 (stmt -> RETURN expr ; .)
    FALSE           reduce using rule 23 (stmt -> RETURN expr ; .)
    (               reduce using rule 23 (stmt -> RETURN expr ; .)
    $end            reduce using rule 23 (stmt -> RETURN expr ; .)
    DEF             reduce using rule 23 (stmt -> RETURN expr ; .)
    }               reduce using rule 23 (stmt -> RETURN expr ; .)
    ELSE            reduce using rule 23 (stmt -> RETURN expr ; .)


state 109

    (25) stmt -> PRINTI ( expr . ) ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    )               shift and go to state 126
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 110

    (4) fun -> DEF fun_name ( idlist ) . block
    (65) block -> . { stmtlist }
    (66) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . arr_id [ expr ] add = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )

    {               shift and go to state 113
    PRINT           shift and go to state 32
    PRINTLN         shift and go to state 34
    WHILE           shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    block                          shift and go to state 127
    stmt                           shift and go to state 114
    expr                           shift and go to state 33
    arr_id                         shift and go to state 38

state 111

    (61) idlist -> idlist , . ID

    ID              shift and go to state 128


state 112

    (5) fun -> DEF fun_name ( ) block .

    DEF             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINT           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINTLN         reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    WHILE           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    IF              reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    ID              reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    RETURN          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINTI          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    INPUT           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    STR             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    ATOI            reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    !               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    -               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    STRING          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    NUM             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    TRUE            reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    FALSE           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    (               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    $end            reduce using rule 5 (fun -> DEF fun_name ( ) block .)


state 113

    (65) block -> { . stmtlist }
    (59) stmtlist -> . stmtlist stmt
    (60) stmtlist -> .

    }               reduce using rule 60 (stmtlist -> .)
    PRINT           reduce using rule 60 (stmtlist -> .)
    PRINTLN         reduce using rule 60 (stmtlist -> .)
    WHILE           reduce using rule 60 (stmtlist -> .)
    IF              reduce using rule 60 (stmtlist -> .)
    ID              reduce using rule 60 (stmtlist -> .)
    RETURN          reduce using rule 60 (stmtlist -> .)
    PRINTI          reduce using rule 60 (stmtlist -> .)
    INPUT           reduce using rule 60 (stmtlist -> .)
    STR             reduce using rule 60 (stmtlist -> .)
    ATOI            reduce using rule 60 (stmtlist -> .)
    !               reduce using rule 60 (stmtlist -> .)
    -               reduce using rule 60 (stmtlist -> .)
    STRING          reduce using rule 60 (stmtlist -> .)
    NUM             reduce using rule 60 (stmtlist -> .)
    TRUE            reduce using rule 60 (stmtlist -> .)
    FALSE           reduce using rule 60 (stmtlist -> .)
    (               reduce using rule 60 (stmtlist -> .)

    stmtlist                       shift and go to state 129

state 114

    (66) block -> stmt .

    DEF             reduce using rule 66 (block -> stmt .)
    PRINT           reduce using rule 66 (block -> stmt .)
    PRINTLN         reduce using rule 66 (block -> stmt .)
    WHILE           reduce using rule 66 (block -> stmt .)
    IF              reduce using rule 66 (block -> stmt .)
    ID              reduce using rule 66 (block -> stmt .)
    RETURN          reduce using rule 66 (block -> stmt .)
    PRINTI          reduce using rule 66 (block -> stmt .)
    INPUT           reduce using rule 66 (block -> stmt .)
    STR             reduce using rule 66 (block -> stmt .)
    ATOI            reduce using rule 66 (block -> stmt .)
    !               reduce using rule 66 (block -> stmt .)
    -               reduce using rule 66 (block -> stmt .)
    STRING          reduce using rule 66 (block -> stmt .)
    NUM             reduce using rule 66 (block -> stmt .)
    TRUE            reduce using rule 66 (block -> stmt .)
    FALSE           reduce using rule 66 (block -> stmt .)
    (               reduce using rule 66 (block -> stmt .)
    $end            reduce using rule 66 (block -> stmt .)
    ELSE            reduce using rule 66 (block -> stmt .)
    }               reduce using rule 66 (block -> stmt .)


state 115

    (52) expr -> ID ( exprlist ) .

    ;               reduce using rule 52 (expr -> ID ( exprlist ) .)
    +               reduce using rule 52 (expr -> ID ( exprlist ) .)
    -               reduce using rule 52 (expr -> ID ( exprlist ) .)
    *               reduce using rule 52 (expr -> ID ( exprlist ) .)
    /               reduce using rule 52 (expr -> ID ( exprlist ) .)
    %               reduce using rule 52 (expr -> ID ( exprlist ) .)
    OR              reduce using rule 52 (expr -> ID ( exprlist ) .)
    AND             reduce using rule 52 (expr -> ID ( exprlist ) .)
    >               reduce using rule 52 (expr -> ID ( exprlist ) .)
    <               reduce using rule 52 (expr -> ID ( exprlist ) .)
    GTE             reduce using rule 52 (expr -> ID ( exprlist ) .)
    LTE             reduce using rule 52 (expr -> ID ( exprlist ) .)
    EQ              reduce using rule 52 (expr -> ID ( exprlist ) .)
    NEQ             reduce using rule 52 (expr -> ID ( exprlist ) .)
    $               reduce using rule 52 (expr -> ID ( exprlist ) .)
    )               reduce using rule 52 (expr -> ID ( exprlist ) .)
    ,               reduce using rule 52 (expr -> ID ( exprlist ) .)
    ]               reduce using rule 52 (expr -> ID ( exprlist ) .)


state 116

    (63) exprlist -> exprlist , . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 130
    arr_id                         shift and go to state 25

state 117

    (28) expr -> STR ( expr ) .

    ;               reduce using rule 28 (expr -> STR ( expr ) .)
    +               reduce using rule 28 (expr -> STR ( expr ) .)
    -               reduce using rule 28 (expr -> STR ( expr ) .)
    *               reduce using rule 28 (expr -> STR ( expr ) .)
    /               reduce using rule 28 (expr -> STR ( expr ) .)
    %               reduce using rule 28 (expr -> STR ( expr ) .)
    OR              reduce using rule 28 (expr -> STR ( expr ) .)
    AND             reduce using rule 28 (expr -> STR ( expr ) .)
    >               reduce using rule 28 (expr -> STR ( expr ) .)
    <               reduce using rule 28 (expr -> STR ( expr ) .)
    GTE             reduce using rule 28 (expr -> STR ( expr ) .)
    LTE             reduce using rule 28 (expr -> STR ( expr ) .)
    EQ              reduce using rule 28 (expr -> STR ( expr ) .)
    NEQ             reduce using rule 28 (expr -> STR ( expr ) .)
    $               reduce using rule 28 (expr -> STR ( expr ) .)
    )               reduce using rule 28 (expr -> STR ( expr ) .)
    ,               reduce using rule 28 (expr -> STR ( expr ) .)
    ]               reduce using rule 28 (expr -> STR ( expr ) .)


state 118

    (29) expr -> ATOI ( expr ) .

    ;               reduce using rule 29 (expr -> ATOI ( expr ) .)
    +               reduce using rule 29 (expr -> ATOI ( expr ) .)
    -               reduce using rule 29 (expr -> ATOI ( expr ) .)
    *               reduce using rule 29 (expr -> ATOI ( expr ) .)
    /               reduce using rule 29 (expr -> ATOI ( expr ) .)
    %               reduce using rule 29 (expr -> ATOI ( expr ) .)
    OR              reduce using rule 29 (expr -> ATOI ( expr ) .)
    AND             reduce using rule 29 (expr -> ATOI ( expr ) .)
    >               reduce using rule 29 (expr -> ATOI ( expr ) .)
    <               reduce using rule 29 (expr -> ATOI ( expr ) .)
    GTE             reduce using rule 29 (expr -> ATOI ( expr ) .)
    LTE             reduce using rule 29 (expr -> ATOI ( expr ) .)
    EQ              reduce using rule 29 (expr -> ATOI ( expr ) .)
    NEQ             reduce using rule 29 (expr -> ATOI ( expr ) .)
    $               reduce using rule 29 (expr -> ATOI ( expr ) .)
    )               reduce using rule 29 (expr -> ATOI ( expr ) .)
    ,               reduce using rule 29 (expr -> ATOI ( expr ) .)
    ]               reduce using rule 29 (expr -> ATOI ( expr ) .)


state 119

    (47) expr -> arr_id [ expr ] .

    ;               reduce using rule 47 (expr -> arr_id [ expr ] .)
    +               reduce using rule 47 (expr -> arr_id [ expr ] .)
    -               reduce using rule 47 (expr -> arr_id [ expr ] .)
    *               reduce using rule 47 (expr -> arr_id [ expr ] .)
    /               reduce using rule 47 (expr -> arr_id [ expr ] .)
    %               reduce using rule 47 (expr -> arr_id [ expr ] .)
    OR              reduce using rule 47 (expr -> arr_id [ expr ] .)
    AND             reduce using rule 47 (expr -> arr_id [ expr ] .)
    >               reduce using rule 47 (expr -> arr_id [ expr ] .)
    <               reduce using rule 47 (expr -> arr_id [ expr ] .)
    GTE             reduce using rule 47 (expr -> arr_id [ expr ] .)
    LTE             reduce using rule 47 (expr -> arr_id [ expr ] .)
    EQ              reduce using rule 47 (expr -> arr_id [ expr ] .)
    NEQ             reduce using rule 47 (expr -> arr_id [ expr ] .)
    $               reduce using rule 47 (expr -> arr_id [ expr ] .)
    )               reduce using rule 47 (expr -> arr_id [ expr ] .)
    ,               reduce using rule 47 (expr -> arr_id [ expr ] .)
    ]               reduce using rule 47 (expr -> arr_id [ expr ] .)


state 120

    (7) stmt -> PRINT ( expr ) . ;

    ;               shift and go to state 131


state 121

    (8) stmt -> PRINTLN ( ) ; .

    PRINT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    PRINTLN         reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    WHILE           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    IF              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ID              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    RETURN          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    PRINTI          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    INPUT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STR             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ATOI            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    !               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    -               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STRING          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    NUM             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    TRUE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    FALSE           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    (               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    $end            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    DEF             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    }               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ELSE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)


state 122

    (9) stmt -> WHILE new_label ( expr . ) jz block
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    )               shift and go to state 132
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 123

    (10) stmt -> IF ( expr ) . jz block
    (11) stmt -> IF ( expr ) . jz block ELSE jmp jz_label block
    (13) jz -> .

    {               reduce using rule 13 (jz -> .)
    PRINT           reduce using rule 13 (jz -> .)
    PRINTLN         reduce using rule 13 (jz -> .)
    WHILE           reduce using rule 13 (jz -> .)
    IF              reduce using rule 13 (jz -> .)
    ID              reduce using rule 13 (jz -> .)
    RETURN          reduce using rule 13 (jz -> .)
    PRINTI          reduce using rule 13 (jz -> .)
    INPUT           reduce using rule 13 (jz -> .)
    STR             reduce using rule 13 (jz -> .)
    ATOI            reduce using rule 13 (jz -> .)
    !               reduce using rule 13 (jz -> .)
    -               reduce using rule 13 (jz -> .)
    STRING          reduce using rule 13 (jz -> .)
    NUM             reduce using rule 13 (jz -> .)
    TRUE            reduce using rule 13 (jz -> .)
    FALSE           reduce using rule 13 (jz -> .)
    (               reduce using rule 13 (jz -> .)

    jz                             shift and go to state 133

state 124

    (19) stmt -> ID = expr ; .

    PRINT           reduce using rule 19 (stmt -> ID = expr ; .)
    PRINTLN         reduce using rule 19 (stmt -> ID = expr ; .)
    WHILE           reduce using rule 19 (stmt -> ID = expr ; .)
    IF              reduce using rule 19 (stmt -> ID = expr ; .)
    ID              reduce using rule 19 (stmt -> ID = expr ; .)
    RETURN          reduce using rule 19 (stmt -> ID = expr ; .)
    PRINTI          reduce using rule 19 (stmt -> ID = expr ; .)
    INPUT           reduce using rule 19 (stmt -> ID = expr ; .)
    STR             reduce using rule 19 (stmt -> ID = expr ; .)
    ATOI            reduce using rule 19 (stmt -> ID = expr ; .)
    !               reduce using rule 19 (stmt -> ID = expr ; .)
    -               reduce using rule 19 (stmt -> ID = expr ; .)
    STRING          reduce using rule 19 (stmt -> ID = expr ; .)
    NUM             reduce using rule 19 (stmt -> ID = expr ; .)
    TRUE            reduce using rule 19 (stmt -> ID = expr ; .)
    FALSE           reduce using rule 19 (stmt -> ID = expr ; .)
    (               reduce using rule 19 (stmt -> ID = expr ; .)
    $end            reduce using rule 19 (stmt -> ID = expr ; .)
    DEF             reduce using rule 19 (stmt -> ID = expr ; .)
    }               reduce using rule 19 (stmt -> ID = expr ; .)
    ELSE            reduce using rule 19 (stmt -> ID = expr ; .)


state 125

    (20) stmt -> arr_id [ expr ] . add = expr ;
    (47) expr -> arr_id [ expr ] .
    (21) add -> .

    ;               reduce using rule 47 (expr -> arr_id [ expr ] .)
    +               reduce using rule 47 (expr -> arr_id [ expr ] .)
    -               reduce using rule 47 (expr -> arr_id [ expr ] .)
    *               reduce using rule 47 (expr -> arr_id [ expr ] .)
    /               reduce using rule 47 (expr -> arr_id [ expr ] .)
    %               reduce using rule 47 (expr -> arr_id [ expr ] .)
    OR              reduce using rule 47 (expr -> arr_id [ expr ] .)
    AND             reduce using rule 47 (expr -> arr_id [ expr ] .)
    >               reduce using rule 47 (expr -> arr_id [ expr ] .)
    <               reduce using rule 47 (expr -> arr_id [ expr ] .)
    GTE             reduce using rule 47 (expr -> arr_id [ expr ] .)
    LTE             reduce using rule 47 (expr -> arr_id [ expr ] .)
    EQ              reduce using rule 47 (expr -> arr_id [ expr ] .)
    NEQ             reduce using rule 47 (expr -> arr_id [ expr ] .)
    $               reduce using rule 47 (expr -> arr_id [ expr ] .)
    =               reduce using rule 21 (add -> .)

    add                            shift and go to state 134

state 126

    (25) stmt -> PRINTI ( expr ) . ;

    ;               shift and go to state 135


state 127

    (4) fun -> DEF fun_name ( idlist ) block .

    DEF             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINT           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINTLN         reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    WHILE           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    IF              reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    ID              reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    RETURN          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINTI          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    INPUT           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    STR             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    ATOI            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    !               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    -               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    STRING          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    NUM             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    TRUE            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    FALSE           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    (               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    $end            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)


state 128

    (61) idlist -> idlist , ID .

    )               reduce using rule 61 (idlist -> idlist , ID .)
    ,               reduce using rule 61 (idlist -> idlist , ID .)


state 129

    (65) block -> { stmtlist . }
    (59) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . arr_id [ expr ] add = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )

    }               shift and go to state 136
    PRINT           shift and go to state 32
    PRINTLN         shift and go to state 34
    WHILE           shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    stmt                           shift and go to state 31
    expr                           shift and go to state 33
    arr_id                         shift and go to state 38

state 130

    (63) exprlist -> exprlist , expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    )               reduce using rule 63 (exprlist -> exprlist , expr .)
    ,               reduce using rule 63 (exprlist -> exprlist , expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 131

    (7) stmt -> PRINT ( expr ) ; .

    PRINT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    PRINTLN         reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    WHILE           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    IF              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ID              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    RETURN          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    PRINTI          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    INPUT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STR             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ATOI            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    !               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    -               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STRING          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    NUM             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    TRUE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    FALSE           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    (               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    $end            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    DEF             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    }               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ELSE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)


state 132

    (9) stmt -> WHILE new_label ( expr ) . jz block
    (13) jz -> .

    {               reduce using rule 13 (jz -> .)
    PRINT           reduce using rule 13 (jz -> .)
    PRINTLN         reduce using rule 13 (jz -> .)
    WHILE           reduce using rule 13 (jz -> .)
    IF              reduce using rule 13 (jz -> .)
    ID              reduce using rule 13 (jz -> .)
    RETURN          reduce using rule 13 (jz -> .)
    PRINTI          reduce using rule 13 (jz -> .)
    INPUT           reduce using rule 13 (jz -> .)
    STR             reduce using rule 13 (jz -> .)
    ATOI            reduce using rule 13 (jz -> .)
    !               reduce using rule 13 (jz -> .)
    -               reduce using rule 13 (jz -> .)
    STRING          reduce using rule 13 (jz -> .)
    NUM             reduce using rule 13 (jz -> .)
    TRUE            reduce using rule 13 (jz -> .)
    FALSE           reduce using rule 13 (jz -> .)
    (               reduce using rule 13 (jz -> .)

    jz                             shift and go to state 137

state 133

    (10) stmt -> IF ( expr ) jz . block
    (11) stmt -> IF ( expr ) jz . block ELSE jmp jz_label block
    (65) block -> . { stmtlist }
    (66) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . arr_id [ expr ] add = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )

    {               shift and go to state 113
    PRINT           shift and go to state 32
    PRINTLN         shift and go to state 34
    WHILE           shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 33
    block                          shift and go to state 138
    stmt                           shift and go to state 114
    arr_id                         shift and go to state 38

state 134

    (20) stmt -> arr_id [ expr ] add . = expr ;

    =               shift and go to state 139


state 135

    (25) stmt -> PRINTI ( expr ) ; .

    PRINT           reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    PRINTLN         reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    WHILE           reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    IF              reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    ID              reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    RETURN          reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    PRINTI          reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    INPUT           reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    STR             reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    ATOI            reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    !               reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    -               reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    STRING          reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    NUM             reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    TRUE            reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    FALSE           reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    (               reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    $end            reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    DEF             reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    }               reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    ELSE            reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)


state 136

    (65) block -> { stmtlist } .

    DEF             reduce using rule 65 (block -> { stmtlist } .)
    PRINT           reduce using rule 65 (block -> { stmtlist } .)
    PRINTLN         reduce using rule 65 (block -> { stmtlist } .)
    WHILE           reduce using rule 65 (block -> { stmtlist } .)
    IF              reduce using rule 65 (block -> { stmtlist } .)
    ID              reduce using rule 65 (block -> { stmtlist } .)
    RETURN          reduce using rule 65 (block -> { stmtlist } .)
    PRINTI          reduce using rule 65 (block -> { stmtlist } .)
    INPUT           reduce using rule 65 (block -> { stmtlist } .)
    STR             reduce using rule 65 (block -> { stmtlist } .)
    ATOI            reduce using rule 65 (block -> { stmtlist } .)
    !               reduce using rule 65 (block -> { stmtlist } .)
    -               reduce using rule 65 (block -> { stmtlist } .)
    STRING          reduce using rule 65 (block -> { stmtlist } .)
    NUM             reduce using rule 65 (block -> { stmtlist } .)
    TRUE            reduce using rule 65 (block -> { stmtlist } .)
    FALSE           reduce using rule 65 (block -> { stmtlist } .)
    (               reduce using rule 65 (block -> { stmtlist } .)
    $end            reduce using rule 65 (block -> { stmtlist } .)
    ELSE            reduce using rule 65 (block -> { stmtlist } .)
    }               reduce using rule 65 (block -> { stmtlist } .)


state 137

    (9) stmt -> WHILE new_label ( expr ) jz . block
    (65) block -> . { stmtlist }
    (66) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . arr_id [ expr ] add = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )

    {               shift and go to state 113
    PRINT           shift and go to state 32
    PRINTLN         shift and go to state 34
    WHILE           shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 33
    block                          shift and go to state 140
    stmt                           shift and go to state 114
    arr_id                         shift and go to state 38

state 138

    (10) stmt -> IF ( expr ) jz block .
    (11) stmt -> IF ( expr ) jz block . ELSE jmp jz_label block

  ! shift/reduce conflict for ELSE resolved as shift
    PRINT           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    PRINTLN         reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    WHILE           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    IF              reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ID              reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    RETURN          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    PRINTI          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    INPUT           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    STR             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ATOI            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    !               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    -               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    STRING          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    NUM             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    TRUE            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    FALSE           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    (               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    $end            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    DEF             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    }               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ELSE            shift and go to state 141

  ! ELSE            [ reduce using rule 10 (stmt -> IF ( expr ) jz block .) ]


state 139

    (20) stmt -> arr_id [ expr ] add = . expr ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )
    (22) arr_id -> . ID

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    arr_id                         shift and go to state 25
    expr                           shift and go to state 142

state 140

    (9) stmt -> WHILE new_label ( expr ) jz block .

    PRINT           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    PRINTLN         reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    WHILE           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    IF              reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ID              reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    RETURN          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    PRINTI          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    INPUT           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    STR             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ATOI            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    !               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    -               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    STRING          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    NUM             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    TRUE            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    FALSE           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    (               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    $end            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    DEF             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    }               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ELSE            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)


state 141

    (11) stmt -> IF ( expr ) jz block ELSE . jmp jz_label block
    (12) jmp -> .

    {               reduce using rule 12 (jmp -> .)
    PRINT           reduce using rule 12 (jmp -> .)
    PRINTLN         reduce using rule 12 (jmp -> .)
    WHILE           reduce using rule 12 (jmp -> .)
    IF              reduce using rule 12 (jmp -> .)
    ID              reduce using rule 12 (jmp -> .)
    RETURN          reduce using rule 12 (jmp -> .)
    PRINTI          reduce using rule 12 (jmp -> .)
    INPUT           reduce using rule 12 (jmp -> .)
    STR             reduce using rule 12 (jmp -> .)
    ATOI            reduce using rule 12 (jmp -> .)
    !               reduce using rule 12 (jmp -> .)
    -               reduce using rule 12 (jmp -> .)
    STRING          reduce using rule 12 (jmp -> .)
    NUM             reduce using rule 12 (jmp -> .)
    TRUE            reduce using rule 12 (jmp -> .)
    FALSE           reduce using rule 12 (jmp -> .)
    (               reduce using rule 12 (jmp -> .)

    jmp                            shift and go to state 143

state 142

    (20) stmt -> arr_id [ expr ] add = expr . ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . % expr
    (35) expr -> expr . OR expr
    (36) expr -> expr . AND expr
    (37) expr -> expr . > expr
    (38) expr -> expr . < expr
    (39) expr -> expr . GTE expr
    (40) expr -> expr . LTE expr
    (41) expr -> expr . EQ expr
    (42) expr -> expr . NEQ expr
    (43) expr -> expr . $ expr

    ;               shift and go to state 144
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57


state 143

    (11) stmt -> IF ( expr ) jz block ELSE jmp . jz_label block
    (14) jz_label -> .

    {               reduce using rule 14 (jz_label -> .)
    PRINT           reduce using rule 14 (jz_label -> .)
    PRINTLN         reduce using rule 14 (jz_label -> .)
    WHILE           reduce using rule 14 (jz_label -> .)
    IF              reduce using rule 14 (jz_label -> .)
    ID              reduce using rule 14 (jz_label -> .)
    RETURN          reduce using rule 14 (jz_label -> .)
    PRINTI          reduce using rule 14 (jz_label -> .)
    INPUT           reduce using rule 14 (jz_label -> .)
    STR             reduce using rule 14 (jz_label -> .)
    ATOI            reduce using rule 14 (jz_label -> .)
    !               reduce using rule 14 (jz_label -> .)
    -               reduce using rule 14 (jz_label -> .)
    STRING          reduce using rule 14 (jz_label -> .)
    NUM             reduce using rule 14 (jz_label -> .)
    TRUE            reduce using rule 14 (jz_label -> .)
    FALSE           reduce using rule 14 (jz_label -> .)
    (               reduce using rule 14 (jz_label -> .)

    jz_label                       shift and go to state 145

state 144

    (20) stmt -> arr_id [ expr ] add = expr ; .

    PRINT           reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    PRINTLN         reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    WHILE           reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    IF              reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    ID              reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    RETURN          reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    PRINTI          reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    INPUT           reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    STR             reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    ATOI            reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    !               reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    -               reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    STRING          reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    NUM             reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    TRUE            reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    FALSE           reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    (               reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    $end            reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    DEF             reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    }               reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)
    ELSE            reduce using rule 20 (stmt -> arr_id [ expr ] add = expr ; .)


state 145

    (11) stmt -> IF ( expr ) jz block ELSE jmp jz_label . block
    (65) block -> . { stmtlist }
    (66) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . arr_id [ expr ] add = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr % expr
    (35) expr -> . expr OR expr
    (36) expr -> . expr AND expr
    (37) expr -> . expr > expr
    (38) expr -> . expr < expr
    (39) expr -> . expr GTE expr
    (40) expr -> . expr LTE expr
    (41) expr -> . expr EQ expr
    (42) expr -> . expr NEQ expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . arr_id [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . TRUE
    (51) expr -> . FALSE
    (52) expr -> . ID ( exprlist )
    (53) expr -> . ID ( )
    (54) expr -> . ( expr )

    {               shift and go to state 113
    PRINT           shift and go to state 32
    PRINTLN         shift and go to state 34
    WHILE           shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 26
    NUM             shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    (               shift and go to state 20

    expr                           shift and go to state 33
    block                          shift and go to state 146
    stmt                           shift and go to state 114
    arr_id                         shift and go to state 38

state 146

    (11) stmt -> IF ( expr ) jz block ELSE jmp jz_label block .

    PRINT           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    PRINTLN         reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    WHILE           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    IF              reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ID              reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    RETURN          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    PRINTI          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    INPUT           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STR             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ATOI            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    !               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    -               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STRING          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    NUM             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    TRUE            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    FALSE           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    (               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    $end            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    DEF             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    }               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ELSE            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 138 resolved as shift
