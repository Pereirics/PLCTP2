Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declist start funlist entrypoint stmtlist
Rule 2     start -> <empty>
Rule 3     entrypoint -> <empty>
Rule 4     fun -> DEF fun_name ( idlist ) block
Rule 5     fun -> DEF fun_name ( ) block
Rule 6     fun_name -> ID
Rule 7     stmt -> PRINT ( expr ) ;
Rule 8     stmt -> PRINTLN ( ) ;
Rule 9     stmt -> WHILE new_label ( expr ) jz block
Rule 10    stmt -> IF ( expr ) jz block
Rule 11    stmt -> IF ( expr ) jz block ELSE jmp jz_label block
Rule 12    jmp -> <empty>
Rule 13    jz -> <empty>
Rule 14    jz_label -> <empty>
Rule 15    new_label -> <empty>
Rule 16    var_declare -> VAR ID = expr ;
Rule 17    var_declare -> VAR ID ;
Rule 18    stmt -> ID = expr ;
Rule 19    stmt -> expr [ expr ] = expr ;
Rule 20    stmt -> RETURN expr ;
Rule 21    stmt -> RETURN ;
Rule 22    stmt -> PRINTI ( expr ) ;
Rule 23    stmt -> expr ;
Rule 24    stmt -> FREE ( expr ) ;
Rule 25    expr -> ALLOC ( NUM )
Rule 26    expr -> INPUT ( )
Rule 27    expr -> STR ( expr )
Rule 28    expr -> ATOI ( expr )
Rule 29    expr -> expr + expr
Rule 30    expr -> expr - expr
Rule 31    expr -> expr * expr
Rule 32    expr -> expr / expr
Rule 33    expr -> expr % expr
Rule 34    expr -> expr OR expr
Rule 35    expr -> expr AND expr
Rule 36    expr -> expr > expr
Rule 37    expr -> expr < expr
Rule 38    expr -> expr GTE expr
Rule 39    expr -> expr LTE expr
Rule 40    expr -> expr EQ expr
Rule 41    expr -> expr NEQ expr
Rule 42    expr -> expr $ expr
Rule 43    expr -> ! expr
Rule 44    expr -> - expr
Rule 45    expr -> ID
Rule 46    expr -> expr [ expr ]
Rule 47    expr -> STRING
Rule 48    expr -> NUM
Rule 49    expr -> TRUE
Rule 50    expr -> FALSE
Rule 51    expr -> ID ( exprlist )
Rule 52    expr -> ID ( )
Rule 53    expr -> ( expr )
Rule 54    declist -> declist var_declare
Rule 55    declist -> <empty>
Rule 56    funlist -> funlist fun
Rule 57    funlist -> <empty>
Rule 58    stmtlist -> stmtlist stmt
Rule 59    stmtlist -> <empty>
Rule 60    idlist -> idlist , ID
Rule 61    idlist -> ID
Rule 62    exprlist -> exprlist , expr
Rule 63    exprlist -> expr
Rule 64    block -> { stmtlist }
Rule 65    block -> stmt

Terminals, with rules where they appear

!                    : 43
$                    : 42
%                    : 33
(                    : 4 5 7 8 9 10 11 22 24 25 26 27 28 51 52 53
)                    : 4 5 7 8 9 10 11 22 24 25 26 27 28 51 52 53
*                    : 31
+                    : 29
,                    : 60 62
-                    : 30 44
/                    : 32
;                    : 7 8 16 17 18 19 20 21 22 23 24
<                    : 37
=                    : 16 18 19
>                    : 36
ALLOC                : 25
AND                  : 35
ATOI                 : 28
DEF                  : 4 5
ELSE                 : 11
EQ                   : 40
FALSE                : 50
FREE                 : 24
GTE                  : 38
ID                   : 6 16 17 18 45 51 52 60 61
IF                   : 10 11
INPUT                : 26
LTE                  : 39
NEQ                  : 41
NUM                  : 25 48
OR                   : 34
PRINT                : 7
PRINTI               : 22
PRINTLN              : 8
RETURN               : 20 21
STR                  : 27
STRING               : 47
TRUE                 : 49
VAR                  : 16 17
WHILE                : 9
[                    : 19 46
]                    : 19 46
error                : 
{                    : 64
}                    : 64

Nonterminals, with rules where they appear

block                : 4 5 9 10 11 11
declist              : 1 54
entrypoint           : 1
expr                 : 7 9 10 11 16 18 19 19 19 20 22 23 24 27 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 44 46 46 53 62 63
exprlist             : 51 62
fun                  : 56
fun_name             : 4 5
funlist              : 1 56
idlist               : 4 60
jmp                  : 11
jz                   : 9 10 11
jz_label             : 11
new_label            : 9
program              : 0
start                : 1
stmt                 : 58 65
stmtlist             : 1 58 64
var_declare          : 54

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declist start funlist entrypoint stmtlist
    (54) declist -> . declist var_declare
    (55) declist -> .

    VAR             reduce using rule 55 (declist -> .)
    DEF             reduce using rule 55 (declist -> .)
    PRINT           reduce using rule 55 (declist -> .)
    PRINTLN         reduce using rule 55 (declist -> .)
    WHILE           reduce using rule 55 (declist -> .)
    IF              reduce using rule 55 (declist -> .)
    ID              reduce using rule 55 (declist -> .)
    RETURN          reduce using rule 55 (declist -> .)
    PRINTI          reduce using rule 55 (declist -> .)
    FREE            reduce using rule 55 (declist -> .)
    ALLOC           reduce using rule 55 (declist -> .)
    INPUT           reduce using rule 55 (declist -> .)
    STR             reduce using rule 55 (declist -> .)
    ATOI            reduce using rule 55 (declist -> .)
    !               reduce using rule 55 (declist -> .)
    -               reduce using rule 55 (declist -> .)
    STRING          reduce using rule 55 (declist -> .)
    NUM             reduce using rule 55 (declist -> .)
    TRUE            reduce using rule 55 (declist -> .)
    FALSE           reduce using rule 55 (declist -> .)
    (               reduce using rule 55 (declist -> .)
    $end            reduce using rule 55 (declist -> .)

    program                        shift and go to state 1
    declist                        shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> declist . start funlist entrypoint stmtlist
    (54) declist -> declist . var_declare
    (2) start -> .
    (16) var_declare -> . VAR ID = expr ;
    (17) var_declare -> . VAR ID ;

    DEF             reduce using rule 2 (start -> .)
    PRINT           reduce using rule 2 (start -> .)
    PRINTLN         reduce using rule 2 (start -> .)
    WHILE           reduce using rule 2 (start -> .)
    IF              reduce using rule 2 (start -> .)
    ID              reduce using rule 2 (start -> .)
    RETURN          reduce using rule 2 (start -> .)
    PRINTI          reduce using rule 2 (start -> .)
    FREE            reduce using rule 2 (start -> .)
    ALLOC           reduce using rule 2 (start -> .)
    INPUT           reduce using rule 2 (start -> .)
    STR             reduce using rule 2 (start -> .)
    ATOI            reduce using rule 2 (start -> .)
    !               reduce using rule 2 (start -> .)
    -               reduce using rule 2 (start -> .)
    STRING          reduce using rule 2 (start -> .)
    NUM             reduce using rule 2 (start -> .)
    TRUE            reduce using rule 2 (start -> .)
    FALSE           reduce using rule 2 (start -> .)
    (               reduce using rule 2 (start -> .)
    $end            reduce using rule 2 (start -> .)
    VAR             shift and go to state 5

    start                          shift and go to state 3
    var_declare                    shift and go to state 4

state 3

    (1) program -> declist start . funlist entrypoint stmtlist
    (56) funlist -> . funlist fun
    (57) funlist -> .

    DEF             reduce using rule 57 (funlist -> .)
    PRINT           reduce using rule 57 (funlist -> .)
    PRINTLN         reduce using rule 57 (funlist -> .)
    WHILE           reduce using rule 57 (funlist -> .)
    IF              reduce using rule 57 (funlist -> .)
    ID              reduce using rule 57 (funlist -> .)
    RETURN          reduce using rule 57 (funlist -> .)
    PRINTI          reduce using rule 57 (funlist -> .)
    FREE            reduce using rule 57 (funlist -> .)
    ALLOC           reduce using rule 57 (funlist -> .)
    INPUT           reduce using rule 57 (funlist -> .)
    STR             reduce using rule 57 (funlist -> .)
    ATOI            reduce using rule 57 (funlist -> .)
    !               reduce using rule 57 (funlist -> .)
    -               reduce using rule 57 (funlist -> .)
    STRING          reduce using rule 57 (funlist -> .)
    NUM             reduce using rule 57 (funlist -> .)
    TRUE            reduce using rule 57 (funlist -> .)
    FALSE           reduce using rule 57 (funlist -> .)
    (               reduce using rule 57 (funlist -> .)
    $end            reduce using rule 57 (funlist -> .)

    funlist                        shift and go to state 6

state 4

    (54) declist -> declist var_declare .

    VAR             reduce using rule 54 (declist -> declist var_declare .)
    DEF             reduce using rule 54 (declist -> declist var_declare .)
    PRINT           reduce using rule 54 (declist -> declist var_declare .)
    PRINTLN         reduce using rule 54 (declist -> declist var_declare .)
    WHILE           reduce using rule 54 (declist -> declist var_declare .)
    IF              reduce using rule 54 (declist -> declist var_declare .)
    ID              reduce using rule 54 (declist -> declist var_declare .)
    RETURN          reduce using rule 54 (declist -> declist var_declare .)
    PRINTI          reduce using rule 54 (declist -> declist var_declare .)
    FREE            reduce using rule 54 (declist -> declist var_declare .)
    ALLOC           reduce using rule 54 (declist -> declist var_declare .)
    INPUT           reduce using rule 54 (declist -> declist var_declare .)
    STR             reduce using rule 54 (declist -> declist var_declare .)
    ATOI            reduce using rule 54 (declist -> declist var_declare .)
    !               reduce using rule 54 (declist -> declist var_declare .)
    -               reduce using rule 54 (declist -> declist var_declare .)
    STRING          reduce using rule 54 (declist -> declist var_declare .)
    NUM             reduce using rule 54 (declist -> declist var_declare .)
    TRUE            reduce using rule 54 (declist -> declist var_declare .)
    FALSE           reduce using rule 54 (declist -> declist var_declare .)
    (               reduce using rule 54 (declist -> declist var_declare .)
    $end            reduce using rule 54 (declist -> declist var_declare .)


state 5

    (16) var_declare -> VAR . ID = expr ;
    (17) var_declare -> VAR . ID ;

    ID              shift and go to state 7


state 6

    (1) program -> declist start funlist . entrypoint stmtlist
    (56) funlist -> funlist . fun
    (3) entrypoint -> .
    (4) fun -> . DEF fun_name ( idlist ) block
    (5) fun -> . DEF fun_name ( ) block

    PRINT           reduce using rule 3 (entrypoint -> .)
    PRINTLN         reduce using rule 3 (entrypoint -> .)
    WHILE           reduce using rule 3 (entrypoint -> .)
    IF              reduce using rule 3 (entrypoint -> .)
    ID              reduce using rule 3 (entrypoint -> .)
    RETURN          reduce using rule 3 (entrypoint -> .)
    PRINTI          reduce using rule 3 (entrypoint -> .)
    FREE            reduce using rule 3 (entrypoint -> .)
    ALLOC           reduce using rule 3 (entrypoint -> .)
    INPUT           reduce using rule 3 (entrypoint -> .)
    STR             reduce using rule 3 (entrypoint -> .)
    ATOI            reduce using rule 3 (entrypoint -> .)
    !               reduce using rule 3 (entrypoint -> .)
    -               reduce using rule 3 (entrypoint -> .)
    STRING          reduce using rule 3 (entrypoint -> .)
    NUM             reduce using rule 3 (entrypoint -> .)
    TRUE            reduce using rule 3 (entrypoint -> .)
    FALSE           reduce using rule 3 (entrypoint -> .)
    (               reduce using rule 3 (entrypoint -> .)
    $end            reduce using rule 3 (entrypoint -> .)
    DEF             shift and go to state 10

    entrypoint                     shift and go to state 8
    fun                            shift and go to state 9

state 7

    (16) var_declare -> VAR ID . = expr ;
    (17) var_declare -> VAR ID . ;

    =               shift and go to state 11
    ;               shift and go to state 12


state 8

    (1) program -> declist start funlist entrypoint . stmtlist
    (58) stmtlist -> . stmtlist stmt
    (59) stmtlist -> .

    PRINT           reduce using rule 59 (stmtlist -> .)
    PRINTLN         reduce using rule 59 (stmtlist -> .)
    WHILE           reduce using rule 59 (stmtlist -> .)
    IF              reduce using rule 59 (stmtlist -> .)
    ID              reduce using rule 59 (stmtlist -> .)
    RETURN          reduce using rule 59 (stmtlist -> .)
    PRINTI          reduce using rule 59 (stmtlist -> .)
    FREE            reduce using rule 59 (stmtlist -> .)
    ALLOC           reduce using rule 59 (stmtlist -> .)
    INPUT           reduce using rule 59 (stmtlist -> .)
    STR             reduce using rule 59 (stmtlist -> .)
    ATOI            reduce using rule 59 (stmtlist -> .)
    !               reduce using rule 59 (stmtlist -> .)
    -               reduce using rule 59 (stmtlist -> .)
    STRING          reduce using rule 59 (stmtlist -> .)
    NUM             reduce using rule 59 (stmtlist -> .)
    TRUE            reduce using rule 59 (stmtlist -> .)
    FALSE           reduce using rule 59 (stmtlist -> .)
    (               reduce using rule 59 (stmtlist -> .)
    $end            reduce using rule 59 (stmtlist -> .)

    stmtlist                       shift and go to state 13

state 9

    (56) funlist -> funlist fun .

    DEF             reduce using rule 56 (funlist -> funlist fun .)
    PRINT           reduce using rule 56 (funlist -> funlist fun .)
    PRINTLN         reduce using rule 56 (funlist -> funlist fun .)
    WHILE           reduce using rule 56 (funlist -> funlist fun .)
    IF              reduce using rule 56 (funlist -> funlist fun .)
    ID              reduce using rule 56 (funlist -> funlist fun .)
    RETURN          reduce using rule 56 (funlist -> funlist fun .)
    PRINTI          reduce using rule 56 (funlist -> funlist fun .)
    FREE            reduce using rule 56 (funlist -> funlist fun .)
    ALLOC           reduce using rule 56 (funlist -> funlist fun .)
    INPUT           reduce using rule 56 (funlist -> funlist fun .)
    STR             reduce using rule 56 (funlist -> funlist fun .)
    ATOI            reduce using rule 56 (funlist -> funlist fun .)
    !               reduce using rule 56 (funlist -> funlist fun .)
    -               reduce using rule 56 (funlist -> funlist fun .)
    STRING          reduce using rule 56 (funlist -> funlist fun .)
    NUM             reduce using rule 56 (funlist -> funlist fun .)
    TRUE            reduce using rule 56 (funlist -> funlist fun .)
    FALSE           reduce using rule 56 (funlist -> funlist fun .)
    (               reduce using rule 56 (funlist -> funlist fun .)
    $end            reduce using rule 56 (funlist -> funlist fun .)


state 10

    (4) fun -> DEF . fun_name ( idlist ) block
    (5) fun -> DEF . fun_name ( ) block
    (6) fun_name -> . ID

    ID              shift and go to state 15

    fun_name                       shift and go to state 14

state 11

    (16) var_declare -> VAR ID = . expr ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 17

state 12

    (17) var_declare -> VAR ID ; .

    VAR             reduce using rule 17 (var_declare -> VAR ID ; .)
    DEF             reduce using rule 17 (var_declare -> VAR ID ; .)
    PRINT           reduce using rule 17 (var_declare -> VAR ID ; .)
    PRINTLN         reduce using rule 17 (var_declare -> VAR ID ; .)
    WHILE           reduce using rule 17 (var_declare -> VAR ID ; .)
    IF              reduce using rule 17 (var_declare -> VAR ID ; .)
    ID              reduce using rule 17 (var_declare -> VAR ID ; .)
    RETURN          reduce using rule 17 (var_declare -> VAR ID ; .)
    PRINTI          reduce using rule 17 (var_declare -> VAR ID ; .)
    FREE            reduce using rule 17 (var_declare -> VAR ID ; .)
    ALLOC           reduce using rule 17 (var_declare -> VAR ID ; .)
    INPUT           reduce using rule 17 (var_declare -> VAR ID ; .)
    STR             reduce using rule 17 (var_declare -> VAR ID ; .)
    ATOI            reduce using rule 17 (var_declare -> VAR ID ; .)
    !               reduce using rule 17 (var_declare -> VAR ID ; .)
    -               reduce using rule 17 (var_declare -> VAR ID ; .)
    STRING          reduce using rule 17 (var_declare -> VAR ID ; .)
    NUM             reduce using rule 17 (var_declare -> VAR ID ; .)
    TRUE            reduce using rule 17 (var_declare -> VAR ID ; .)
    FALSE           reduce using rule 17 (var_declare -> VAR ID ; .)
    (               reduce using rule 17 (var_declare -> VAR ID ; .)
    $end            reduce using rule 17 (var_declare -> VAR ID ; .)


state 13

    (1) program -> declist start funlist entrypoint stmtlist .
    (58) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (18) stmt -> . ID = expr ;
    (19) stmt -> . expr [ expr ] = expr ;
    (20) stmt -> . RETURN expr ;
    (21) stmt -> . RETURN ;
    (22) stmt -> . PRINTI ( expr ) ;
    (23) stmt -> . expr ;
    (24) stmt -> . FREE ( expr ) ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    $end            reduce using rule 1 (program -> declist start funlist entrypoint stmtlist .)
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    IF              shift and go to state 34
    ID              shift and go to state 35
    RETURN          shift and go to state 36
    PRINTI          shift and go to state 37
    FREE            shift and go to state 38
    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    stmt                           shift and go to state 29
    expr                           shift and go to state 31

state 14

    (4) fun -> DEF fun_name . ( idlist ) block
    (5) fun -> DEF fun_name . ( ) block

    (               shift and go to state 39


state 15

    (6) fun_name -> ID .

    (               reduce using rule 6 (fun_name -> ID .)


state 16

    (45) expr -> ID .
    (51) expr -> ID . ( exprlist )
    (52) expr -> ID . ( )

    ;               reduce using rule 45 (expr -> ID .)
    +               reduce using rule 45 (expr -> ID .)
    -               reduce using rule 45 (expr -> ID .)
    *               reduce using rule 45 (expr -> ID .)
    /               reduce using rule 45 (expr -> ID .)
    %               reduce using rule 45 (expr -> ID .)
    OR              reduce using rule 45 (expr -> ID .)
    AND             reduce using rule 45 (expr -> ID .)
    >               reduce using rule 45 (expr -> ID .)
    <               reduce using rule 45 (expr -> ID .)
    GTE             reduce using rule 45 (expr -> ID .)
    LTE             reduce using rule 45 (expr -> ID .)
    EQ              reduce using rule 45 (expr -> ID .)
    NEQ             reduce using rule 45 (expr -> ID .)
    $               reduce using rule 45 (expr -> ID .)
    [               reduce using rule 45 (expr -> ID .)
    )               reduce using rule 45 (expr -> ID .)
    ,               reduce using rule 45 (expr -> ID .)
    ]               reduce using rule 45 (expr -> ID .)
    (               shift and go to state 40


state 17

    (16) var_declare -> VAR ID = expr . ;
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               shift and go to state 41
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 18

    (25) expr -> ALLOC . ( NUM )

    (               shift and go to state 57


state 19

    (53) expr -> ( . expr )
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 58

state 20

    (48) expr -> NUM .

    ;               reduce using rule 48 (expr -> NUM .)
    +               reduce using rule 48 (expr -> NUM .)
    -               reduce using rule 48 (expr -> NUM .)
    *               reduce using rule 48 (expr -> NUM .)
    /               reduce using rule 48 (expr -> NUM .)
    %               reduce using rule 48 (expr -> NUM .)
    OR              reduce using rule 48 (expr -> NUM .)
    AND             reduce using rule 48 (expr -> NUM .)
    >               reduce using rule 48 (expr -> NUM .)
    <               reduce using rule 48 (expr -> NUM .)
    GTE             reduce using rule 48 (expr -> NUM .)
    LTE             reduce using rule 48 (expr -> NUM .)
    EQ              reduce using rule 48 (expr -> NUM .)
    NEQ             reduce using rule 48 (expr -> NUM .)
    $               reduce using rule 48 (expr -> NUM .)
    [               reduce using rule 48 (expr -> NUM .)
    )               reduce using rule 48 (expr -> NUM .)
    ,               reduce using rule 48 (expr -> NUM .)
    ]               reduce using rule 48 (expr -> NUM .)


state 21

    (26) expr -> INPUT . ( )

    (               shift and go to state 59


state 22

    (27) expr -> STR . ( expr )

    (               shift and go to state 60


state 23

    (28) expr -> ATOI . ( expr )

    (               shift and go to state 61


state 24

    (44) expr -> - . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 62

state 25

    (43) expr -> ! . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 63

state 26

    (47) expr -> STRING .

    ;               reduce using rule 47 (expr -> STRING .)
    +               reduce using rule 47 (expr -> STRING .)
    -               reduce using rule 47 (expr -> STRING .)
    *               reduce using rule 47 (expr -> STRING .)
    /               reduce using rule 47 (expr -> STRING .)
    %               reduce using rule 47 (expr -> STRING .)
    OR              reduce using rule 47 (expr -> STRING .)
    AND             reduce using rule 47 (expr -> STRING .)
    >               reduce using rule 47 (expr -> STRING .)
    <               reduce using rule 47 (expr -> STRING .)
    GTE             reduce using rule 47 (expr -> STRING .)
    LTE             reduce using rule 47 (expr -> STRING .)
    EQ              reduce using rule 47 (expr -> STRING .)
    NEQ             reduce using rule 47 (expr -> STRING .)
    $               reduce using rule 47 (expr -> STRING .)
    [               reduce using rule 47 (expr -> STRING .)
    )               reduce using rule 47 (expr -> STRING .)
    ,               reduce using rule 47 (expr -> STRING .)
    ]               reduce using rule 47 (expr -> STRING .)


state 27

    (49) expr -> TRUE .

    ;               reduce using rule 49 (expr -> TRUE .)
    +               reduce using rule 49 (expr -> TRUE .)
    -               reduce using rule 49 (expr -> TRUE .)
    *               reduce using rule 49 (expr -> TRUE .)
    /               reduce using rule 49 (expr -> TRUE .)
    %               reduce using rule 49 (expr -> TRUE .)
    OR              reduce using rule 49 (expr -> TRUE .)
    AND             reduce using rule 49 (expr -> TRUE .)
    >               reduce using rule 49 (expr -> TRUE .)
    <               reduce using rule 49 (expr -> TRUE .)
    GTE             reduce using rule 49 (expr -> TRUE .)
    LTE             reduce using rule 49 (expr -> TRUE .)
    EQ              reduce using rule 49 (expr -> TRUE .)
    NEQ             reduce using rule 49 (expr -> TRUE .)
    $               reduce using rule 49 (expr -> TRUE .)
    [               reduce using rule 49 (expr -> TRUE .)
    )               reduce using rule 49 (expr -> TRUE .)
    ,               reduce using rule 49 (expr -> TRUE .)
    ]               reduce using rule 49 (expr -> TRUE .)


state 28

    (50) expr -> FALSE .

    ;               reduce using rule 50 (expr -> FALSE .)
    +               reduce using rule 50 (expr -> FALSE .)
    -               reduce using rule 50 (expr -> FALSE .)
    *               reduce using rule 50 (expr -> FALSE .)
    /               reduce using rule 50 (expr -> FALSE .)
    %               reduce using rule 50 (expr -> FALSE .)
    OR              reduce using rule 50 (expr -> FALSE .)
    AND             reduce using rule 50 (expr -> FALSE .)
    >               reduce using rule 50 (expr -> FALSE .)
    <               reduce using rule 50 (expr -> FALSE .)
    GTE             reduce using rule 50 (expr -> FALSE .)
    LTE             reduce using rule 50 (expr -> FALSE .)
    EQ              reduce using rule 50 (expr -> FALSE .)
    NEQ             reduce using rule 50 (expr -> FALSE .)
    $               reduce using rule 50 (expr -> FALSE .)
    [               reduce using rule 50 (expr -> FALSE .)
    )               reduce using rule 50 (expr -> FALSE .)
    ,               reduce using rule 50 (expr -> FALSE .)
    ]               reduce using rule 50 (expr -> FALSE .)


state 29

    (58) stmtlist -> stmtlist stmt .

    PRINT           reduce using rule 58 (stmtlist -> stmtlist stmt .)
    PRINTLN         reduce using rule 58 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 58 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 58 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 58 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 58 (stmtlist -> stmtlist stmt .)
    PRINTI          reduce using rule 58 (stmtlist -> stmtlist stmt .)
    FREE            reduce using rule 58 (stmtlist -> stmtlist stmt .)
    ALLOC           reduce using rule 58 (stmtlist -> stmtlist stmt .)
    INPUT           reduce using rule 58 (stmtlist -> stmtlist stmt .)
    STR             reduce using rule 58 (stmtlist -> stmtlist stmt .)
    ATOI            reduce using rule 58 (stmtlist -> stmtlist stmt .)
    !               reduce using rule 58 (stmtlist -> stmtlist stmt .)
    -               reduce using rule 58 (stmtlist -> stmtlist stmt .)
    STRING          reduce using rule 58 (stmtlist -> stmtlist stmt .)
    NUM             reduce using rule 58 (stmtlist -> stmtlist stmt .)
    TRUE            reduce using rule 58 (stmtlist -> stmtlist stmt .)
    FALSE           reduce using rule 58 (stmtlist -> stmtlist stmt .)
    (               reduce using rule 58 (stmtlist -> stmtlist stmt .)
    $end            reduce using rule 58 (stmtlist -> stmtlist stmt .)
    }               reduce using rule 58 (stmtlist -> stmtlist stmt .)


state 30

    (7) stmt -> PRINT . ( expr ) ;

    (               shift and go to state 64


state 31

    (19) stmt -> expr . [ expr ] = expr ;
    (23) stmt -> expr . ;
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    [               shift and go to state 65
    ;               shift and go to state 66
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55


state 32

    (8) stmt -> PRINTLN . ( ) ;

    (               shift and go to state 67


state 33

    (9) stmt -> WHILE . new_label ( expr ) jz block
    (15) new_label -> .

    (               reduce using rule 15 (new_label -> .)

    new_label                      shift and go to state 68

state 34

    (10) stmt -> IF . ( expr ) jz block
    (11) stmt -> IF . ( expr ) jz block ELSE jmp jz_label block

    (               shift and go to state 69


state 35

    (18) stmt -> ID . = expr ;
    (45) expr -> ID .
    (51) expr -> ID . ( exprlist )
    (52) expr -> ID . ( )

    =               shift and go to state 70
    [               reduce using rule 45 (expr -> ID .)
    ;               reduce using rule 45 (expr -> ID .)
    +               reduce using rule 45 (expr -> ID .)
    -               reduce using rule 45 (expr -> ID .)
    *               reduce using rule 45 (expr -> ID .)
    /               reduce using rule 45 (expr -> ID .)
    %               reduce using rule 45 (expr -> ID .)
    OR              reduce using rule 45 (expr -> ID .)
    AND             reduce using rule 45 (expr -> ID .)
    >               reduce using rule 45 (expr -> ID .)
    <               reduce using rule 45 (expr -> ID .)
    GTE             reduce using rule 45 (expr -> ID .)
    LTE             reduce using rule 45 (expr -> ID .)
    EQ              reduce using rule 45 (expr -> ID .)
    NEQ             reduce using rule 45 (expr -> ID .)
    $               reduce using rule 45 (expr -> ID .)
    (               shift and go to state 40


state 36

    (20) stmt -> RETURN . expr ;
    (21) stmt -> RETURN . ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ;               shift and go to state 72
    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 71

state 37

    (22) stmt -> PRINTI . ( expr ) ;

    (               shift and go to state 73


state 38

    (24) stmt -> FREE . ( expr ) ;

    (               shift and go to state 74


state 39

    (4) fun -> DEF fun_name ( . idlist ) block
    (5) fun -> DEF fun_name ( . ) block
    (60) idlist -> . idlist , ID
    (61) idlist -> . ID

    )               shift and go to state 76
    ID              shift and go to state 77

    idlist                         shift and go to state 75

state 40

    (51) expr -> ID ( . exprlist )
    (52) expr -> ID ( . )
    (62) exprlist -> . exprlist , expr
    (63) exprlist -> . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    )               shift and go to state 79
    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    exprlist                       shift and go to state 78
    expr                           shift and go to state 80

state 41

    (16) var_declare -> VAR ID = expr ; .

    VAR             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    DEF             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    PRINT           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    PRINTLN         reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    WHILE           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    IF              reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    ID              reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    RETURN          reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    PRINTI          reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    FREE            reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    ALLOC           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    INPUT           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    STR             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    ATOI            reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    !               reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    -               reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    STRING          reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    NUM             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    TRUE            reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    FALSE           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    (               reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    $end            reduce using rule 16 (var_declare -> VAR ID = expr ; .)


state 42

    (29) expr -> expr + . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 81

state 43

    (30) expr -> expr - . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 82

state 44

    (31) expr -> expr * . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 83

state 45

    (32) expr -> expr / . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 84

state 46

    (33) expr -> expr % . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 85

state 47

    (34) expr -> expr OR . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 86

state 48

    (35) expr -> expr AND . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 87

state 49

    (36) expr -> expr > . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 88

state 50

    (37) expr -> expr < . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 89

state 51

    (38) expr -> expr GTE . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 90

state 52

    (39) expr -> expr LTE . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 91

state 53

    (40) expr -> expr EQ . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 92

state 54

    (41) expr -> expr NEQ . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 93

state 55

    (42) expr -> expr $ . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 94

state 56

    (46) expr -> expr [ . expr ]
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 95

state 57

    (25) expr -> ALLOC ( . NUM )

    NUM             shift and go to state 96


state 58

    (53) expr -> ( expr . )
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    )               shift and go to state 97
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 59

    (26) expr -> INPUT ( . )

    )               shift and go to state 98


state 60

    (27) expr -> STR ( . expr )
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 99

state 61

    (28) expr -> ATOI ( . expr )
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 100

state 62

    (44) expr -> - expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 44 (expr -> - expr .)
    +               reduce using rule 44 (expr -> - expr .)
    -               reduce using rule 44 (expr -> - expr .)
    *               reduce using rule 44 (expr -> - expr .)
    /               reduce using rule 44 (expr -> - expr .)
    %               reduce using rule 44 (expr -> - expr .)
    OR              reduce using rule 44 (expr -> - expr .)
    AND             reduce using rule 44 (expr -> - expr .)
    >               reduce using rule 44 (expr -> - expr .)
    <               reduce using rule 44 (expr -> - expr .)
    GTE             reduce using rule 44 (expr -> - expr .)
    LTE             reduce using rule 44 (expr -> - expr .)
    EQ              reduce using rule 44 (expr -> - expr .)
    NEQ             reduce using rule 44 (expr -> - expr .)
    $               reduce using rule 44 (expr -> - expr .)
    [               reduce using rule 44 (expr -> - expr .)
    )               reduce using rule 44 (expr -> - expr .)
    ,               reduce using rule 44 (expr -> - expr .)
    ]               reduce using rule 44 (expr -> - expr .)

  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! %               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 63

    (43) expr -> ! expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 43 (expr -> ! expr .)
    +               reduce using rule 43 (expr -> ! expr .)
    -               reduce using rule 43 (expr -> ! expr .)
    *               reduce using rule 43 (expr -> ! expr .)
    /               reduce using rule 43 (expr -> ! expr .)
    %               reduce using rule 43 (expr -> ! expr .)
    OR              reduce using rule 43 (expr -> ! expr .)
    AND             reduce using rule 43 (expr -> ! expr .)
    >               reduce using rule 43 (expr -> ! expr .)
    <               reduce using rule 43 (expr -> ! expr .)
    GTE             reduce using rule 43 (expr -> ! expr .)
    LTE             reduce using rule 43 (expr -> ! expr .)
    EQ              reduce using rule 43 (expr -> ! expr .)
    NEQ             reduce using rule 43 (expr -> ! expr .)
    $               reduce using rule 43 (expr -> ! expr .)
    [               reduce using rule 43 (expr -> ! expr .)
    )               reduce using rule 43 (expr -> ! expr .)
    ,               reduce using rule 43 (expr -> ! expr .)
    ]               reduce using rule 43 (expr -> ! expr .)

  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! %               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 64

    (7) stmt -> PRINT ( . expr ) ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 101

state 65

    (19) stmt -> expr [ . expr ] = expr ;
    (46) expr -> expr [ . expr ]
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 102

state 66

    (23) stmt -> expr ; .

    PRINT           reduce using rule 23 (stmt -> expr ; .)
    PRINTLN         reduce using rule 23 (stmt -> expr ; .)
    WHILE           reduce using rule 23 (stmt -> expr ; .)
    IF              reduce using rule 23 (stmt -> expr ; .)
    ID              reduce using rule 23 (stmt -> expr ; .)
    RETURN          reduce using rule 23 (stmt -> expr ; .)
    PRINTI          reduce using rule 23 (stmt -> expr ; .)
    FREE            reduce using rule 23 (stmt -> expr ; .)
    ALLOC           reduce using rule 23 (stmt -> expr ; .)
    INPUT           reduce using rule 23 (stmt -> expr ; .)
    STR             reduce using rule 23 (stmt -> expr ; .)
    ATOI            reduce using rule 23 (stmt -> expr ; .)
    !               reduce using rule 23 (stmt -> expr ; .)
    -               reduce using rule 23 (stmt -> expr ; .)
    STRING          reduce using rule 23 (stmt -> expr ; .)
    NUM             reduce using rule 23 (stmt -> expr ; .)
    TRUE            reduce using rule 23 (stmt -> expr ; .)
    FALSE           reduce using rule 23 (stmt -> expr ; .)
    (               reduce using rule 23 (stmt -> expr ; .)
    $end            reduce using rule 23 (stmt -> expr ; .)
    DEF             reduce using rule 23 (stmt -> expr ; .)
    }               reduce using rule 23 (stmt -> expr ; .)
    ELSE            reduce using rule 23 (stmt -> expr ; .)


state 67

    (8) stmt -> PRINTLN ( . ) ;

    )               shift and go to state 103


state 68

    (9) stmt -> WHILE new_label . ( expr ) jz block

    (               shift and go to state 104


state 69

    (10) stmt -> IF ( . expr ) jz block
    (11) stmt -> IF ( . expr ) jz block ELSE jmp jz_label block
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 105

state 70

    (18) stmt -> ID = . expr ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 106

state 71

    (20) stmt -> RETURN expr . ;
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               shift and go to state 107
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 72

    (21) stmt -> RETURN ; .

    PRINT           reduce using rule 21 (stmt -> RETURN ; .)
    PRINTLN         reduce using rule 21 (stmt -> RETURN ; .)
    WHILE           reduce using rule 21 (stmt -> RETURN ; .)
    IF              reduce using rule 21 (stmt -> RETURN ; .)
    ID              reduce using rule 21 (stmt -> RETURN ; .)
    RETURN          reduce using rule 21 (stmt -> RETURN ; .)
    PRINTI          reduce using rule 21 (stmt -> RETURN ; .)
    FREE            reduce using rule 21 (stmt -> RETURN ; .)
    ALLOC           reduce using rule 21 (stmt -> RETURN ; .)
    INPUT           reduce using rule 21 (stmt -> RETURN ; .)
    STR             reduce using rule 21 (stmt -> RETURN ; .)
    ATOI            reduce using rule 21 (stmt -> RETURN ; .)
    !               reduce using rule 21 (stmt -> RETURN ; .)
    -               reduce using rule 21 (stmt -> RETURN ; .)
    STRING          reduce using rule 21 (stmt -> RETURN ; .)
    NUM             reduce using rule 21 (stmt -> RETURN ; .)
    TRUE            reduce using rule 21 (stmt -> RETURN ; .)
    FALSE           reduce using rule 21 (stmt -> RETURN ; .)
    (               reduce using rule 21 (stmt -> RETURN ; .)
    $end            reduce using rule 21 (stmt -> RETURN ; .)
    DEF             reduce using rule 21 (stmt -> RETURN ; .)
    }               reduce using rule 21 (stmt -> RETURN ; .)
    ELSE            reduce using rule 21 (stmt -> RETURN ; .)


state 73

    (22) stmt -> PRINTI ( . expr ) ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 108

state 74

    (24) stmt -> FREE ( . expr ) ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 109

state 75

    (4) fun -> DEF fun_name ( idlist . ) block
    (60) idlist -> idlist . , ID

    )               shift and go to state 110
    ,               shift and go to state 111


state 76

    (5) fun -> DEF fun_name ( ) . block
    (64) block -> . { stmtlist }
    (65) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (18) stmt -> . ID = expr ;
    (19) stmt -> . expr [ expr ] = expr ;
    (20) stmt -> . RETURN expr ;
    (21) stmt -> . RETURN ;
    (22) stmt -> . PRINTI ( expr ) ;
    (23) stmt -> . expr ;
    (24) stmt -> . FREE ( expr ) ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    {               shift and go to state 113
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    IF              shift and go to state 34
    ID              shift and go to state 35
    RETURN          shift and go to state 36
    PRINTI          shift and go to state 37
    FREE            shift and go to state 38
    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    block                          shift and go to state 112
    stmt                           shift and go to state 114
    expr                           shift and go to state 31

state 77

    (61) idlist -> ID .

    )               reduce using rule 61 (idlist -> ID .)
    ,               reduce using rule 61 (idlist -> ID .)


state 78

    (51) expr -> ID ( exprlist . )
    (62) exprlist -> exprlist . , expr

    )               shift and go to state 115
    ,               shift and go to state 116


state 79

    (52) expr -> ID ( ) .

    ;               reduce using rule 52 (expr -> ID ( ) .)
    +               reduce using rule 52 (expr -> ID ( ) .)
    -               reduce using rule 52 (expr -> ID ( ) .)
    *               reduce using rule 52 (expr -> ID ( ) .)
    /               reduce using rule 52 (expr -> ID ( ) .)
    %               reduce using rule 52 (expr -> ID ( ) .)
    OR              reduce using rule 52 (expr -> ID ( ) .)
    AND             reduce using rule 52 (expr -> ID ( ) .)
    >               reduce using rule 52 (expr -> ID ( ) .)
    <               reduce using rule 52 (expr -> ID ( ) .)
    GTE             reduce using rule 52 (expr -> ID ( ) .)
    LTE             reduce using rule 52 (expr -> ID ( ) .)
    EQ              reduce using rule 52 (expr -> ID ( ) .)
    NEQ             reduce using rule 52 (expr -> ID ( ) .)
    $               reduce using rule 52 (expr -> ID ( ) .)
    [               reduce using rule 52 (expr -> ID ( ) .)
    )               reduce using rule 52 (expr -> ID ( ) .)
    ,               reduce using rule 52 (expr -> ID ( ) .)
    ]               reduce using rule 52 (expr -> ID ( ) .)


state 80

    (63) exprlist -> expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    )               reduce using rule 63 (exprlist -> expr .)
    ,               reduce using rule 63 (exprlist -> expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 81

    (29) expr -> expr + expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 29 (expr -> expr + expr .)
    +               reduce using rule 29 (expr -> expr + expr .)
    -               reduce using rule 29 (expr -> expr + expr .)
    OR              reduce using rule 29 (expr -> expr + expr .)
    AND             reduce using rule 29 (expr -> expr + expr .)
    >               reduce using rule 29 (expr -> expr + expr .)
    <               reduce using rule 29 (expr -> expr + expr .)
    GTE             reduce using rule 29 (expr -> expr + expr .)
    LTE             reduce using rule 29 (expr -> expr + expr .)
    EQ              reduce using rule 29 (expr -> expr + expr .)
    NEQ             reduce using rule 29 (expr -> expr + expr .)
    $               reduce using rule 29 (expr -> expr + expr .)
    [               reduce using rule 29 (expr -> expr + expr .)
    )               reduce using rule 29 (expr -> expr + expr .)
    ,               reduce using rule 29 (expr -> expr + expr .)
    ]               reduce using rule 29 (expr -> expr + expr .)
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46

  ! *               [ reduce using rule 29 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 29 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 29 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 82

    (30) expr -> expr - expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 30 (expr -> expr - expr .)
    +               reduce using rule 30 (expr -> expr - expr .)
    -               reduce using rule 30 (expr -> expr - expr .)
    OR              reduce using rule 30 (expr -> expr - expr .)
    AND             reduce using rule 30 (expr -> expr - expr .)
    >               reduce using rule 30 (expr -> expr - expr .)
    <               reduce using rule 30 (expr -> expr - expr .)
    GTE             reduce using rule 30 (expr -> expr - expr .)
    LTE             reduce using rule 30 (expr -> expr - expr .)
    EQ              reduce using rule 30 (expr -> expr - expr .)
    NEQ             reduce using rule 30 (expr -> expr - expr .)
    $               reduce using rule 30 (expr -> expr - expr .)
    [               reduce using rule 30 (expr -> expr - expr .)
    )               reduce using rule 30 (expr -> expr - expr .)
    ,               reduce using rule 30 (expr -> expr - expr .)
    ]               reduce using rule 30 (expr -> expr - expr .)
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46

  ! *               [ reduce using rule 30 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 30 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 30 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 83

    (31) expr -> expr * expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 31 (expr -> expr * expr .)
    +               reduce using rule 31 (expr -> expr * expr .)
    -               reduce using rule 31 (expr -> expr * expr .)
    *               reduce using rule 31 (expr -> expr * expr .)
    /               reduce using rule 31 (expr -> expr * expr .)
    %               reduce using rule 31 (expr -> expr * expr .)
    OR              reduce using rule 31 (expr -> expr * expr .)
    AND             reduce using rule 31 (expr -> expr * expr .)
    >               reduce using rule 31 (expr -> expr * expr .)
    <               reduce using rule 31 (expr -> expr * expr .)
    GTE             reduce using rule 31 (expr -> expr * expr .)
    LTE             reduce using rule 31 (expr -> expr * expr .)
    EQ              reduce using rule 31 (expr -> expr * expr .)
    NEQ             reduce using rule 31 (expr -> expr * expr .)
    $               reduce using rule 31 (expr -> expr * expr .)
    [               reduce using rule 31 (expr -> expr * expr .)
    )               reduce using rule 31 (expr -> expr * expr .)
    ,               reduce using rule 31 (expr -> expr * expr .)
    ]               reduce using rule 31 (expr -> expr * expr .)

  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! %               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 84

    (32) expr -> expr / expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 32 (expr -> expr / expr .)
    +               reduce using rule 32 (expr -> expr / expr .)
    -               reduce using rule 32 (expr -> expr / expr .)
    *               reduce using rule 32 (expr -> expr / expr .)
    /               reduce using rule 32 (expr -> expr / expr .)
    %               reduce using rule 32 (expr -> expr / expr .)
    OR              reduce using rule 32 (expr -> expr / expr .)
    AND             reduce using rule 32 (expr -> expr / expr .)
    >               reduce using rule 32 (expr -> expr / expr .)
    <               reduce using rule 32 (expr -> expr / expr .)
    GTE             reduce using rule 32 (expr -> expr / expr .)
    LTE             reduce using rule 32 (expr -> expr / expr .)
    EQ              reduce using rule 32 (expr -> expr / expr .)
    NEQ             reduce using rule 32 (expr -> expr / expr .)
    $               reduce using rule 32 (expr -> expr / expr .)
    [               reduce using rule 32 (expr -> expr / expr .)
    )               reduce using rule 32 (expr -> expr / expr .)
    ,               reduce using rule 32 (expr -> expr / expr .)
    ]               reduce using rule 32 (expr -> expr / expr .)

  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! %               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 85

    (33) expr -> expr % expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 33 (expr -> expr % expr .)
    +               reduce using rule 33 (expr -> expr % expr .)
    -               reduce using rule 33 (expr -> expr % expr .)
    *               reduce using rule 33 (expr -> expr % expr .)
    /               reduce using rule 33 (expr -> expr % expr .)
    %               reduce using rule 33 (expr -> expr % expr .)
    OR              reduce using rule 33 (expr -> expr % expr .)
    AND             reduce using rule 33 (expr -> expr % expr .)
    >               reduce using rule 33 (expr -> expr % expr .)
    <               reduce using rule 33 (expr -> expr % expr .)
    GTE             reduce using rule 33 (expr -> expr % expr .)
    LTE             reduce using rule 33 (expr -> expr % expr .)
    EQ              reduce using rule 33 (expr -> expr % expr .)
    NEQ             reduce using rule 33 (expr -> expr % expr .)
    $               reduce using rule 33 (expr -> expr % expr .)
    [               reduce using rule 33 (expr -> expr % expr .)
    )               reduce using rule 33 (expr -> expr % expr .)
    ,               reduce using rule 33 (expr -> expr % expr .)
    ]               reduce using rule 33 (expr -> expr % expr .)

  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! %               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 86

    (34) expr -> expr OR expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 34 (expr -> expr OR expr .)
    OR              reduce using rule 34 (expr -> expr OR expr .)
    AND             reduce using rule 34 (expr -> expr OR expr .)
    EQ              reduce using rule 34 (expr -> expr OR expr .)
    NEQ             reduce using rule 34 (expr -> expr OR expr .)
    [               reduce using rule 34 (expr -> expr OR expr .)
    )               reduce using rule 34 (expr -> expr OR expr .)
    ,               reduce using rule 34 (expr -> expr OR expr .)
    ]               reduce using rule 34 (expr -> expr OR expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    $               shift and go to state 55

  ! +               [ reduce using rule 34 (expr -> expr OR expr .) ]
  ! -               [ reduce using rule 34 (expr -> expr OR expr .) ]
  ! *               [ reduce using rule 34 (expr -> expr OR expr .) ]
  ! /               [ reduce using rule 34 (expr -> expr OR expr .) ]
  ! %               [ reduce using rule 34 (expr -> expr OR expr .) ]
  ! >               [ reduce using rule 34 (expr -> expr OR expr .) ]
  ! <               [ reduce using rule 34 (expr -> expr OR expr .) ]
  ! GTE             [ reduce using rule 34 (expr -> expr OR expr .) ]
  ! LTE             [ reduce using rule 34 (expr -> expr OR expr .) ]
  ! $               [ reduce using rule 34 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 87

    (35) expr -> expr AND expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 35 (expr -> expr AND expr .)
    OR              reduce using rule 35 (expr -> expr AND expr .)
    AND             reduce using rule 35 (expr -> expr AND expr .)
    EQ              reduce using rule 35 (expr -> expr AND expr .)
    NEQ             reduce using rule 35 (expr -> expr AND expr .)
    [               reduce using rule 35 (expr -> expr AND expr .)
    )               reduce using rule 35 (expr -> expr AND expr .)
    ,               reduce using rule 35 (expr -> expr AND expr .)
    ]               reduce using rule 35 (expr -> expr AND expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    $               shift and go to state 55

  ! +               [ reduce using rule 35 (expr -> expr AND expr .) ]
  ! -               [ reduce using rule 35 (expr -> expr AND expr .) ]
  ! *               [ reduce using rule 35 (expr -> expr AND expr .) ]
  ! /               [ reduce using rule 35 (expr -> expr AND expr .) ]
  ! %               [ reduce using rule 35 (expr -> expr AND expr .) ]
  ! >               [ reduce using rule 35 (expr -> expr AND expr .) ]
  ! <               [ reduce using rule 35 (expr -> expr AND expr .) ]
  ! GTE             [ reduce using rule 35 (expr -> expr AND expr .) ]
  ! LTE             [ reduce using rule 35 (expr -> expr AND expr .) ]
  ! $               [ reduce using rule 35 (expr -> expr AND expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 88

    (36) expr -> expr > expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 36 (expr -> expr > expr .)
    OR              reduce using rule 36 (expr -> expr > expr .)
    AND             reduce using rule 36 (expr -> expr > expr .)
    >               reduce using rule 36 (expr -> expr > expr .)
    <               reduce using rule 36 (expr -> expr > expr .)
    GTE             reduce using rule 36 (expr -> expr > expr .)
    LTE             reduce using rule 36 (expr -> expr > expr .)
    EQ              reduce using rule 36 (expr -> expr > expr .)
    NEQ             reduce using rule 36 (expr -> expr > expr .)
    [               reduce using rule 36 (expr -> expr > expr .)
    )               reduce using rule 36 (expr -> expr > expr .)
    ,               reduce using rule 36 (expr -> expr > expr .)
    ]               reduce using rule 36 (expr -> expr > expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    $               shift and go to state 55

  ! +               [ reduce using rule 36 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 36 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 36 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 36 (expr -> expr > expr .) ]
  ! %               [ reduce using rule 36 (expr -> expr > expr .) ]
  ! $               [ reduce using rule 36 (expr -> expr > expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 89

    (37) expr -> expr < expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 37 (expr -> expr < expr .)
    OR              reduce using rule 37 (expr -> expr < expr .)
    AND             reduce using rule 37 (expr -> expr < expr .)
    >               reduce using rule 37 (expr -> expr < expr .)
    <               reduce using rule 37 (expr -> expr < expr .)
    GTE             reduce using rule 37 (expr -> expr < expr .)
    LTE             reduce using rule 37 (expr -> expr < expr .)
    EQ              reduce using rule 37 (expr -> expr < expr .)
    NEQ             reduce using rule 37 (expr -> expr < expr .)
    [               reduce using rule 37 (expr -> expr < expr .)
    )               reduce using rule 37 (expr -> expr < expr .)
    ,               reduce using rule 37 (expr -> expr < expr .)
    ]               reduce using rule 37 (expr -> expr < expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    $               shift and go to state 55

  ! +               [ reduce using rule 37 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 37 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 37 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 37 (expr -> expr < expr .) ]
  ! %               [ reduce using rule 37 (expr -> expr < expr .) ]
  ! $               [ reduce using rule 37 (expr -> expr < expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 90

    (38) expr -> expr GTE expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 38 (expr -> expr GTE expr .)
    OR              reduce using rule 38 (expr -> expr GTE expr .)
    AND             reduce using rule 38 (expr -> expr GTE expr .)
    >               reduce using rule 38 (expr -> expr GTE expr .)
    <               reduce using rule 38 (expr -> expr GTE expr .)
    GTE             reduce using rule 38 (expr -> expr GTE expr .)
    LTE             reduce using rule 38 (expr -> expr GTE expr .)
    EQ              reduce using rule 38 (expr -> expr GTE expr .)
    NEQ             reduce using rule 38 (expr -> expr GTE expr .)
    [               reduce using rule 38 (expr -> expr GTE expr .)
    )               reduce using rule 38 (expr -> expr GTE expr .)
    ,               reduce using rule 38 (expr -> expr GTE expr .)
    ]               reduce using rule 38 (expr -> expr GTE expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    $               shift and go to state 55

  ! +               [ reduce using rule 38 (expr -> expr GTE expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr GTE expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr GTE expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr GTE expr .) ]
  ! %               [ reduce using rule 38 (expr -> expr GTE expr .) ]
  ! $               [ reduce using rule 38 (expr -> expr GTE expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 91

    (39) expr -> expr LTE expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 39 (expr -> expr LTE expr .)
    OR              reduce using rule 39 (expr -> expr LTE expr .)
    AND             reduce using rule 39 (expr -> expr LTE expr .)
    >               reduce using rule 39 (expr -> expr LTE expr .)
    <               reduce using rule 39 (expr -> expr LTE expr .)
    GTE             reduce using rule 39 (expr -> expr LTE expr .)
    LTE             reduce using rule 39 (expr -> expr LTE expr .)
    EQ              reduce using rule 39 (expr -> expr LTE expr .)
    NEQ             reduce using rule 39 (expr -> expr LTE expr .)
    [               reduce using rule 39 (expr -> expr LTE expr .)
    )               reduce using rule 39 (expr -> expr LTE expr .)
    ,               reduce using rule 39 (expr -> expr LTE expr .)
    ]               reduce using rule 39 (expr -> expr LTE expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    $               shift and go to state 55

  ! +               [ reduce using rule 39 (expr -> expr LTE expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr LTE expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr LTE expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr LTE expr .) ]
  ! %               [ reduce using rule 39 (expr -> expr LTE expr .) ]
  ! $               [ reduce using rule 39 (expr -> expr LTE expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 92

    (40) expr -> expr EQ expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 40 (expr -> expr EQ expr .)
    OR              reduce using rule 40 (expr -> expr EQ expr .)
    AND             reduce using rule 40 (expr -> expr EQ expr .)
    EQ              reduce using rule 40 (expr -> expr EQ expr .)
    NEQ             reduce using rule 40 (expr -> expr EQ expr .)
    [               reduce using rule 40 (expr -> expr EQ expr .)
    )               reduce using rule 40 (expr -> expr EQ expr .)
    ,               reduce using rule 40 (expr -> expr EQ expr .)
    ]               reduce using rule 40 (expr -> expr EQ expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    $               shift and go to state 55

  ! +               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! %               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! >               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! <               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! GTE             [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! LTE             [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! $               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 93

    (41) expr -> expr NEQ expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 41 (expr -> expr NEQ expr .)
    OR              reduce using rule 41 (expr -> expr NEQ expr .)
    AND             reduce using rule 41 (expr -> expr NEQ expr .)
    EQ              reduce using rule 41 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 41 (expr -> expr NEQ expr .)
    [               reduce using rule 41 (expr -> expr NEQ expr .)
    )               reduce using rule 41 (expr -> expr NEQ expr .)
    ,               reduce using rule 41 (expr -> expr NEQ expr .)
    ]               reduce using rule 41 (expr -> expr NEQ expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    $               shift and go to state 55

  ! +               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! %               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! >               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! <               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! GTE             [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! LTE             [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! $               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 94

    (42) expr -> expr $ expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               reduce using rule 42 (expr -> expr $ expr .)
    +               reduce using rule 42 (expr -> expr $ expr .)
    -               reduce using rule 42 (expr -> expr $ expr .)
    OR              reduce using rule 42 (expr -> expr $ expr .)
    AND             reduce using rule 42 (expr -> expr $ expr .)
    >               reduce using rule 42 (expr -> expr $ expr .)
    <               reduce using rule 42 (expr -> expr $ expr .)
    GTE             reduce using rule 42 (expr -> expr $ expr .)
    LTE             reduce using rule 42 (expr -> expr $ expr .)
    EQ              reduce using rule 42 (expr -> expr $ expr .)
    NEQ             reduce using rule 42 (expr -> expr $ expr .)
    $               reduce using rule 42 (expr -> expr $ expr .)
    [               reduce using rule 42 (expr -> expr $ expr .)
    )               reduce using rule 42 (expr -> expr $ expr .)
    ,               reduce using rule 42 (expr -> expr $ expr .)
    ]               reduce using rule 42 (expr -> expr $ expr .)
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46

  ! *               [ reduce using rule 42 (expr -> expr $ expr .) ]
  ! /               [ reduce using rule 42 (expr -> expr $ expr .) ]
  ! %               [ reduce using rule 42 (expr -> expr $ expr .) ]
  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 95

    (46) expr -> expr [ expr . ]
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ]               shift and go to state 117
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 96

    (25) expr -> ALLOC ( NUM . )

    )               shift and go to state 118


state 97

    (53) expr -> ( expr ) .

    ;               reduce using rule 53 (expr -> ( expr ) .)
    +               reduce using rule 53 (expr -> ( expr ) .)
    -               reduce using rule 53 (expr -> ( expr ) .)
    *               reduce using rule 53 (expr -> ( expr ) .)
    /               reduce using rule 53 (expr -> ( expr ) .)
    %               reduce using rule 53 (expr -> ( expr ) .)
    OR              reduce using rule 53 (expr -> ( expr ) .)
    AND             reduce using rule 53 (expr -> ( expr ) .)
    >               reduce using rule 53 (expr -> ( expr ) .)
    <               reduce using rule 53 (expr -> ( expr ) .)
    GTE             reduce using rule 53 (expr -> ( expr ) .)
    LTE             reduce using rule 53 (expr -> ( expr ) .)
    EQ              reduce using rule 53 (expr -> ( expr ) .)
    NEQ             reduce using rule 53 (expr -> ( expr ) .)
    $               reduce using rule 53 (expr -> ( expr ) .)
    [               reduce using rule 53 (expr -> ( expr ) .)
    )               reduce using rule 53 (expr -> ( expr ) .)
    ,               reduce using rule 53 (expr -> ( expr ) .)
    ]               reduce using rule 53 (expr -> ( expr ) .)


state 98

    (26) expr -> INPUT ( ) .

    ;               reduce using rule 26 (expr -> INPUT ( ) .)
    +               reduce using rule 26 (expr -> INPUT ( ) .)
    -               reduce using rule 26 (expr -> INPUT ( ) .)
    *               reduce using rule 26 (expr -> INPUT ( ) .)
    /               reduce using rule 26 (expr -> INPUT ( ) .)
    %               reduce using rule 26 (expr -> INPUT ( ) .)
    OR              reduce using rule 26 (expr -> INPUT ( ) .)
    AND             reduce using rule 26 (expr -> INPUT ( ) .)
    >               reduce using rule 26 (expr -> INPUT ( ) .)
    <               reduce using rule 26 (expr -> INPUT ( ) .)
    GTE             reduce using rule 26 (expr -> INPUT ( ) .)
    LTE             reduce using rule 26 (expr -> INPUT ( ) .)
    EQ              reduce using rule 26 (expr -> INPUT ( ) .)
    NEQ             reduce using rule 26 (expr -> INPUT ( ) .)
    $               reduce using rule 26 (expr -> INPUT ( ) .)
    [               reduce using rule 26 (expr -> INPUT ( ) .)
    )               reduce using rule 26 (expr -> INPUT ( ) .)
    ,               reduce using rule 26 (expr -> INPUT ( ) .)
    ]               reduce using rule 26 (expr -> INPUT ( ) .)


state 99

    (27) expr -> STR ( expr . )
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    )               shift and go to state 119
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 100

    (28) expr -> ATOI ( expr . )
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    )               shift and go to state 120
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 101

    (7) stmt -> PRINT ( expr . ) ;
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    )               shift and go to state 121
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 102

    (19) stmt -> expr [ expr . ] = expr ;
    (46) expr -> expr [ expr . ]
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ]               shift and go to state 122
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 103

    (8) stmt -> PRINTLN ( ) . ;

    ;               shift and go to state 123


state 104

    (9) stmt -> WHILE new_label ( . expr ) jz block
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 124

state 105

    (10) stmt -> IF ( expr . ) jz block
    (11) stmt -> IF ( expr . ) jz block ELSE jmp jz_label block
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    )               shift and go to state 125
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 106

    (18) stmt -> ID = expr . ;
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               shift and go to state 126
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 107

    (20) stmt -> RETURN expr ; .

    PRINT           reduce using rule 20 (stmt -> RETURN expr ; .)
    PRINTLN         reduce using rule 20 (stmt -> RETURN expr ; .)
    WHILE           reduce using rule 20 (stmt -> RETURN expr ; .)
    IF              reduce using rule 20 (stmt -> RETURN expr ; .)
    ID              reduce using rule 20 (stmt -> RETURN expr ; .)
    RETURN          reduce using rule 20 (stmt -> RETURN expr ; .)
    PRINTI          reduce using rule 20 (stmt -> RETURN expr ; .)
    FREE            reduce using rule 20 (stmt -> RETURN expr ; .)
    ALLOC           reduce using rule 20 (stmt -> RETURN expr ; .)
    INPUT           reduce using rule 20 (stmt -> RETURN expr ; .)
    STR             reduce using rule 20 (stmt -> RETURN expr ; .)
    ATOI            reduce using rule 20 (stmt -> RETURN expr ; .)
    !               reduce using rule 20 (stmt -> RETURN expr ; .)
    -               reduce using rule 20 (stmt -> RETURN expr ; .)
    STRING          reduce using rule 20 (stmt -> RETURN expr ; .)
    NUM             reduce using rule 20 (stmt -> RETURN expr ; .)
    TRUE            reduce using rule 20 (stmt -> RETURN expr ; .)
    FALSE           reduce using rule 20 (stmt -> RETURN expr ; .)
    (               reduce using rule 20 (stmt -> RETURN expr ; .)
    $end            reduce using rule 20 (stmt -> RETURN expr ; .)
    DEF             reduce using rule 20 (stmt -> RETURN expr ; .)
    }               reduce using rule 20 (stmt -> RETURN expr ; .)
    ELSE            reduce using rule 20 (stmt -> RETURN expr ; .)


state 108

    (22) stmt -> PRINTI ( expr . ) ;
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    )               shift and go to state 127
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 109

    (24) stmt -> FREE ( expr . ) ;
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    )               shift and go to state 128
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 110

    (4) fun -> DEF fun_name ( idlist ) . block
    (64) block -> . { stmtlist }
    (65) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (18) stmt -> . ID = expr ;
    (19) stmt -> . expr [ expr ] = expr ;
    (20) stmt -> . RETURN expr ;
    (21) stmt -> . RETURN ;
    (22) stmt -> . PRINTI ( expr ) ;
    (23) stmt -> . expr ;
    (24) stmt -> . FREE ( expr ) ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    {               shift and go to state 113
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    IF              shift and go to state 34
    ID              shift and go to state 35
    RETURN          shift and go to state 36
    PRINTI          shift and go to state 37
    FREE            shift and go to state 38
    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    block                          shift and go to state 129
    stmt                           shift and go to state 114
    expr                           shift and go to state 31

state 111

    (60) idlist -> idlist , . ID

    ID              shift and go to state 130


state 112

    (5) fun -> DEF fun_name ( ) block .

    DEF             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINT           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINTLN         reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    WHILE           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    IF              reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    ID              reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    RETURN          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINTI          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    FREE            reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    ALLOC           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    INPUT           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    STR             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    ATOI            reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    !               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    -               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    STRING          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    NUM             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    TRUE            reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    FALSE           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    (               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    $end            reduce using rule 5 (fun -> DEF fun_name ( ) block .)


state 113

    (64) block -> { . stmtlist }
    (58) stmtlist -> . stmtlist stmt
    (59) stmtlist -> .

    }               reduce using rule 59 (stmtlist -> .)
    PRINT           reduce using rule 59 (stmtlist -> .)
    PRINTLN         reduce using rule 59 (stmtlist -> .)
    WHILE           reduce using rule 59 (stmtlist -> .)
    IF              reduce using rule 59 (stmtlist -> .)
    ID              reduce using rule 59 (stmtlist -> .)
    RETURN          reduce using rule 59 (stmtlist -> .)
    PRINTI          reduce using rule 59 (stmtlist -> .)
    FREE            reduce using rule 59 (stmtlist -> .)
    ALLOC           reduce using rule 59 (stmtlist -> .)
    INPUT           reduce using rule 59 (stmtlist -> .)
    STR             reduce using rule 59 (stmtlist -> .)
    ATOI            reduce using rule 59 (stmtlist -> .)
    !               reduce using rule 59 (stmtlist -> .)
    -               reduce using rule 59 (stmtlist -> .)
    STRING          reduce using rule 59 (stmtlist -> .)
    NUM             reduce using rule 59 (stmtlist -> .)
    TRUE            reduce using rule 59 (stmtlist -> .)
    FALSE           reduce using rule 59 (stmtlist -> .)
    (               reduce using rule 59 (stmtlist -> .)

    stmtlist                       shift and go to state 131

state 114

    (65) block -> stmt .

    DEF             reduce using rule 65 (block -> stmt .)
    PRINT           reduce using rule 65 (block -> stmt .)
    PRINTLN         reduce using rule 65 (block -> stmt .)
    WHILE           reduce using rule 65 (block -> stmt .)
    IF              reduce using rule 65 (block -> stmt .)
    ID              reduce using rule 65 (block -> stmt .)
    RETURN          reduce using rule 65 (block -> stmt .)
    PRINTI          reduce using rule 65 (block -> stmt .)
    FREE            reduce using rule 65 (block -> stmt .)
    ALLOC           reduce using rule 65 (block -> stmt .)
    INPUT           reduce using rule 65 (block -> stmt .)
    STR             reduce using rule 65 (block -> stmt .)
    ATOI            reduce using rule 65 (block -> stmt .)
    !               reduce using rule 65 (block -> stmt .)
    -               reduce using rule 65 (block -> stmt .)
    STRING          reduce using rule 65 (block -> stmt .)
    NUM             reduce using rule 65 (block -> stmt .)
    TRUE            reduce using rule 65 (block -> stmt .)
    FALSE           reduce using rule 65 (block -> stmt .)
    (               reduce using rule 65 (block -> stmt .)
    $end            reduce using rule 65 (block -> stmt .)
    ELSE            reduce using rule 65 (block -> stmt .)
    }               reduce using rule 65 (block -> stmt .)


state 115

    (51) expr -> ID ( exprlist ) .

    ;               reduce using rule 51 (expr -> ID ( exprlist ) .)
    +               reduce using rule 51 (expr -> ID ( exprlist ) .)
    -               reduce using rule 51 (expr -> ID ( exprlist ) .)
    *               reduce using rule 51 (expr -> ID ( exprlist ) .)
    /               reduce using rule 51 (expr -> ID ( exprlist ) .)
    %               reduce using rule 51 (expr -> ID ( exprlist ) .)
    OR              reduce using rule 51 (expr -> ID ( exprlist ) .)
    AND             reduce using rule 51 (expr -> ID ( exprlist ) .)
    >               reduce using rule 51 (expr -> ID ( exprlist ) .)
    <               reduce using rule 51 (expr -> ID ( exprlist ) .)
    GTE             reduce using rule 51 (expr -> ID ( exprlist ) .)
    LTE             reduce using rule 51 (expr -> ID ( exprlist ) .)
    EQ              reduce using rule 51 (expr -> ID ( exprlist ) .)
    NEQ             reduce using rule 51 (expr -> ID ( exprlist ) .)
    $               reduce using rule 51 (expr -> ID ( exprlist ) .)
    [               reduce using rule 51 (expr -> ID ( exprlist ) .)
    )               reduce using rule 51 (expr -> ID ( exprlist ) .)
    ,               reduce using rule 51 (expr -> ID ( exprlist ) .)
    ]               reduce using rule 51 (expr -> ID ( exprlist ) .)


state 116

    (62) exprlist -> exprlist , . expr
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 132

state 117

    (46) expr -> expr [ expr ] .

    ;               reduce using rule 46 (expr -> expr [ expr ] .)
    +               reduce using rule 46 (expr -> expr [ expr ] .)
    -               reduce using rule 46 (expr -> expr [ expr ] .)
    *               reduce using rule 46 (expr -> expr [ expr ] .)
    /               reduce using rule 46 (expr -> expr [ expr ] .)
    %               reduce using rule 46 (expr -> expr [ expr ] .)
    OR              reduce using rule 46 (expr -> expr [ expr ] .)
    AND             reduce using rule 46 (expr -> expr [ expr ] .)
    >               reduce using rule 46 (expr -> expr [ expr ] .)
    <               reduce using rule 46 (expr -> expr [ expr ] .)
    GTE             reduce using rule 46 (expr -> expr [ expr ] .)
    LTE             reduce using rule 46 (expr -> expr [ expr ] .)
    EQ              reduce using rule 46 (expr -> expr [ expr ] .)
    NEQ             reduce using rule 46 (expr -> expr [ expr ] .)
    $               reduce using rule 46 (expr -> expr [ expr ] .)
    [               reduce using rule 46 (expr -> expr [ expr ] .)
    )               reduce using rule 46 (expr -> expr [ expr ] .)
    ,               reduce using rule 46 (expr -> expr [ expr ] .)
    ]               reduce using rule 46 (expr -> expr [ expr ] .)


state 118

    (25) expr -> ALLOC ( NUM ) .

    ;               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    +               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    -               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    *               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    /               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    %               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    OR              reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    AND             reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    >               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    <               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    GTE             reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    LTE             reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    EQ              reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    NEQ             reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    $               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    [               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    )               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    ,               reduce using rule 25 (expr -> ALLOC ( NUM ) .)
    ]               reduce using rule 25 (expr -> ALLOC ( NUM ) .)


state 119

    (27) expr -> STR ( expr ) .

    ;               reduce using rule 27 (expr -> STR ( expr ) .)
    +               reduce using rule 27 (expr -> STR ( expr ) .)
    -               reduce using rule 27 (expr -> STR ( expr ) .)
    *               reduce using rule 27 (expr -> STR ( expr ) .)
    /               reduce using rule 27 (expr -> STR ( expr ) .)
    %               reduce using rule 27 (expr -> STR ( expr ) .)
    OR              reduce using rule 27 (expr -> STR ( expr ) .)
    AND             reduce using rule 27 (expr -> STR ( expr ) .)
    >               reduce using rule 27 (expr -> STR ( expr ) .)
    <               reduce using rule 27 (expr -> STR ( expr ) .)
    GTE             reduce using rule 27 (expr -> STR ( expr ) .)
    LTE             reduce using rule 27 (expr -> STR ( expr ) .)
    EQ              reduce using rule 27 (expr -> STR ( expr ) .)
    NEQ             reduce using rule 27 (expr -> STR ( expr ) .)
    $               reduce using rule 27 (expr -> STR ( expr ) .)
    [               reduce using rule 27 (expr -> STR ( expr ) .)
    )               reduce using rule 27 (expr -> STR ( expr ) .)
    ,               reduce using rule 27 (expr -> STR ( expr ) .)
    ]               reduce using rule 27 (expr -> STR ( expr ) .)


state 120

    (28) expr -> ATOI ( expr ) .

    ;               reduce using rule 28 (expr -> ATOI ( expr ) .)
    +               reduce using rule 28 (expr -> ATOI ( expr ) .)
    -               reduce using rule 28 (expr -> ATOI ( expr ) .)
    *               reduce using rule 28 (expr -> ATOI ( expr ) .)
    /               reduce using rule 28 (expr -> ATOI ( expr ) .)
    %               reduce using rule 28 (expr -> ATOI ( expr ) .)
    OR              reduce using rule 28 (expr -> ATOI ( expr ) .)
    AND             reduce using rule 28 (expr -> ATOI ( expr ) .)
    >               reduce using rule 28 (expr -> ATOI ( expr ) .)
    <               reduce using rule 28 (expr -> ATOI ( expr ) .)
    GTE             reduce using rule 28 (expr -> ATOI ( expr ) .)
    LTE             reduce using rule 28 (expr -> ATOI ( expr ) .)
    EQ              reduce using rule 28 (expr -> ATOI ( expr ) .)
    NEQ             reduce using rule 28 (expr -> ATOI ( expr ) .)
    $               reduce using rule 28 (expr -> ATOI ( expr ) .)
    [               reduce using rule 28 (expr -> ATOI ( expr ) .)
    )               reduce using rule 28 (expr -> ATOI ( expr ) .)
    ,               reduce using rule 28 (expr -> ATOI ( expr ) .)
    ]               reduce using rule 28 (expr -> ATOI ( expr ) .)


state 121

    (7) stmt -> PRINT ( expr ) . ;

    ;               shift and go to state 133


state 122

    (19) stmt -> expr [ expr ] . = expr ;
    (46) expr -> expr [ expr ] .

    =               shift and go to state 134
    [               reduce using rule 46 (expr -> expr [ expr ] .)
    ;               reduce using rule 46 (expr -> expr [ expr ] .)
    +               reduce using rule 46 (expr -> expr [ expr ] .)
    -               reduce using rule 46 (expr -> expr [ expr ] .)
    *               reduce using rule 46 (expr -> expr [ expr ] .)
    /               reduce using rule 46 (expr -> expr [ expr ] .)
    %               reduce using rule 46 (expr -> expr [ expr ] .)
    OR              reduce using rule 46 (expr -> expr [ expr ] .)
    AND             reduce using rule 46 (expr -> expr [ expr ] .)
    >               reduce using rule 46 (expr -> expr [ expr ] .)
    <               reduce using rule 46 (expr -> expr [ expr ] .)
    GTE             reduce using rule 46 (expr -> expr [ expr ] .)
    LTE             reduce using rule 46 (expr -> expr [ expr ] .)
    EQ              reduce using rule 46 (expr -> expr [ expr ] .)
    NEQ             reduce using rule 46 (expr -> expr [ expr ] .)
    $               reduce using rule 46 (expr -> expr [ expr ] .)


state 123

    (8) stmt -> PRINTLN ( ) ; .

    PRINT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    PRINTLN         reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    WHILE           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    IF              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ID              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    RETURN          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    PRINTI          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    FREE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ALLOC           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    INPUT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STR             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ATOI            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    !               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    -               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STRING          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    NUM             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    TRUE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    FALSE           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    (               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    $end            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    DEF             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    }               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ELSE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)


state 124

    (9) stmt -> WHILE new_label ( expr . ) jz block
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    )               shift and go to state 135
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 125

    (10) stmt -> IF ( expr ) . jz block
    (11) stmt -> IF ( expr ) . jz block ELSE jmp jz_label block
    (13) jz -> .

    {               reduce using rule 13 (jz -> .)
    PRINT           reduce using rule 13 (jz -> .)
    PRINTLN         reduce using rule 13 (jz -> .)
    WHILE           reduce using rule 13 (jz -> .)
    IF              reduce using rule 13 (jz -> .)
    ID              reduce using rule 13 (jz -> .)
    RETURN          reduce using rule 13 (jz -> .)
    PRINTI          reduce using rule 13 (jz -> .)
    FREE            reduce using rule 13 (jz -> .)
    ALLOC           reduce using rule 13 (jz -> .)
    INPUT           reduce using rule 13 (jz -> .)
    STR             reduce using rule 13 (jz -> .)
    ATOI            reduce using rule 13 (jz -> .)
    !               reduce using rule 13 (jz -> .)
    -               reduce using rule 13 (jz -> .)
    STRING          reduce using rule 13 (jz -> .)
    NUM             reduce using rule 13 (jz -> .)
    TRUE            reduce using rule 13 (jz -> .)
    FALSE           reduce using rule 13 (jz -> .)
    (               reduce using rule 13 (jz -> .)

    jz                             shift and go to state 136

state 126

    (18) stmt -> ID = expr ; .

    PRINT           reduce using rule 18 (stmt -> ID = expr ; .)
    PRINTLN         reduce using rule 18 (stmt -> ID = expr ; .)
    WHILE           reduce using rule 18 (stmt -> ID = expr ; .)
    IF              reduce using rule 18 (stmt -> ID = expr ; .)
    ID              reduce using rule 18 (stmt -> ID = expr ; .)
    RETURN          reduce using rule 18 (stmt -> ID = expr ; .)
    PRINTI          reduce using rule 18 (stmt -> ID = expr ; .)
    FREE            reduce using rule 18 (stmt -> ID = expr ; .)
    ALLOC           reduce using rule 18 (stmt -> ID = expr ; .)
    INPUT           reduce using rule 18 (stmt -> ID = expr ; .)
    STR             reduce using rule 18 (stmt -> ID = expr ; .)
    ATOI            reduce using rule 18 (stmt -> ID = expr ; .)
    !               reduce using rule 18 (stmt -> ID = expr ; .)
    -               reduce using rule 18 (stmt -> ID = expr ; .)
    STRING          reduce using rule 18 (stmt -> ID = expr ; .)
    NUM             reduce using rule 18 (stmt -> ID = expr ; .)
    TRUE            reduce using rule 18 (stmt -> ID = expr ; .)
    FALSE           reduce using rule 18 (stmt -> ID = expr ; .)
    (               reduce using rule 18 (stmt -> ID = expr ; .)
    $end            reduce using rule 18 (stmt -> ID = expr ; .)
    DEF             reduce using rule 18 (stmt -> ID = expr ; .)
    }               reduce using rule 18 (stmt -> ID = expr ; .)
    ELSE            reduce using rule 18 (stmt -> ID = expr ; .)


state 127

    (22) stmt -> PRINTI ( expr ) . ;

    ;               shift and go to state 137


state 128

    (24) stmt -> FREE ( expr ) . ;

    ;               shift and go to state 138


state 129

    (4) fun -> DEF fun_name ( idlist ) block .

    DEF             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINT           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINTLN         reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    WHILE           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    IF              reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    ID              reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    RETURN          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINTI          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    FREE            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    ALLOC           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    INPUT           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    STR             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    ATOI            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    !               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    -               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    STRING          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    NUM             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    TRUE            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    FALSE           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    (               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    $end            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)


state 130

    (60) idlist -> idlist , ID .

    )               reduce using rule 60 (idlist -> idlist , ID .)
    ,               reduce using rule 60 (idlist -> idlist , ID .)


state 131

    (64) block -> { stmtlist . }
    (58) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (18) stmt -> . ID = expr ;
    (19) stmt -> . expr [ expr ] = expr ;
    (20) stmt -> . RETURN expr ;
    (21) stmt -> . RETURN ;
    (22) stmt -> . PRINTI ( expr ) ;
    (23) stmt -> . expr ;
    (24) stmt -> . FREE ( expr ) ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    }               shift and go to state 139
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    IF              shift and go to state 34
    ID              shift and go to state 35
    RETURN          shift and go to state 36
    PRINTI          shift and go to state 37
    FREE            shift and go to state 38
    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    stmt                           shift and go to state 29
    expr                           shift and go to state 31

state 132

    (62) exprlist -> exprlist , expr .
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    )               reduce using rule 62 (exprlist -> exprlist , expr .)
    ,               reduce using rule 62 (exprlist -> exprlist , expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 133

    (7) stmt -> PRINT ( expr ) ; .

    PRINT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    PRINTLN         reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    WHILE           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    IF              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ID              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    RETURN          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    PRINTI          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    FREE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ALLOC           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    INPUT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STR             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ATOI            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    !               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    -               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STRING          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    NUM             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    TRUE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    FALSE           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    (               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    $end            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    DEF             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    }               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ELSE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)


state 134

    (19) stmt -> expr [ expr ] = . expr ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    ID              shift and go to state 16
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 140

state 135

    (9) stmt -> WHILE new_label ( expr ) . jz block
    (13) jz -> .

    {               reduce using rule 13 (jz -> .)
    PRINT           reduce using rule 13 (jz -> .)
    PRINTLN         reduce using rule 13 (jz -> .)
    WHILE           reduce using rule 13 (jz -> .)
    IF              reduce using rule 13 (jz -> .)
    ID              reduce using rule 13 (jz -> .)
    RETURN          reduce using rule 13 (jz -> .)
    PRINTI          reduce using rule 13 (jz -> .)
    FREE            reduce using rule 13 (jz -> .)
    ALLOC           reduce using rule 13 (jz -> .)
    INPUT           reduce using rule 13 (jz -> .)
    STR             reduce using rule 13 (jz -> .)
    ATOI            reduce using rule 13 (jz -> .)
    !               reduce using rule 13 (jz -> .)
    -               reduce using rule 13 (jz -> .)
    STRING          reduce using rule 13 (jz -> .)
    NUM             reduce using rule 13 (jz -> .)
    TRUE            reduce using rule 13 (jz -> .)
    FALSE           reduce using rule 13 (jz -> .)
    (               reduce using rule 13 (jz -> .)

    jz                             shift and go to state 141

state 136

    (10) stmt -> IF ( expr ) jz . block
    (11) stmt -> IF ( expr ) jz . block ELSE jmp jz_label block
    (64) block -> . { stmtlist }
    (65) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (18) stmt -> . ID = expr ;
    (19) stmt -> . expr [ expr ] = expr ;
    (20) stmt -> . RETURN expr ;
    (21) stmt -> . RETURN ;
    (22) stmt -> . PRINTI ( expr ) ;
    (23) stmt -> . expr ;
    (24) stmt -> . FREE ( expr ) ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    {               shift and go to state 113
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    IF              shift and go to state 34
    ID              shift and go to state 35
    RETURN          shift and go to state 36
    PRINTI          shift and go to state 37
    FREE            shift and go to state 38
    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 31
    block                          shift and go to state 142
    stmt                           shift and go to state 114

state 137

    (22) stmt -> PRINTI ( expr ) ; .

    PRINT           reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    PRINTLN         reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    WHILE           reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    IF              reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    ID              reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    RETURN          reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    PRINTI          reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    FREE            reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    ALLOC           reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    INPUT           reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    STR             reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    ATOI            reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    !               reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    -               reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    STRING          reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    NUM             reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    TRUE            reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    FALSE           reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    (               reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    $end            reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    DEF             reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    }               reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)
    ELSE            reduce using rule 22 (stmt -> PRINTI ( expr ) ; .)


state 138

    (24) stmt -> FREE ( expr ) ; .

    PRINT           reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    PRINTLN         reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    WHILE           reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    IF              reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    ID              reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    RETURN          reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    PRINTI          reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    FREE            reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    ALLOC           reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    INPUT           reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    STR             reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    ATOI            reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    !               reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    -               reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    STRING          reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    NUM             reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    TRUE            reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    FALSE           reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    (               reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    $end            reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    DEF             reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    }               reduce using rule 24 (stmt -> FREE ( expr ) ; .)
    ELSE            reduce using rule 24 (stmt -> FREE ( expr ) ; .)


state 139

    (64) block -> { stmtlist } .

    DEF             reduce using rule 64 (block -> { stmtlist } .)
    PRINT           reduce using rule 64 (block -> { stmtlist } .)
    PRINTLN         reduce using rule 64 (block -> { stmtlist } .)
    WHILE           reduce using rule 64 (block -> { stmtlist } .)
    IF              reduce using rule 64 (block -> { stmtlist } .)
    ID              reduce using rule 64 (block -> { stmtlist } .)
    RETURN          reduce using rule 64 (block -> { stmtlist } .)
    PRINTI          reduce using rule 64 (block -> { stmtlist } .)
    FREE            reduce using rule 64 (block -> { stmtlist } .)
    ALLOC           reduce using rule 64 (block -> { stmtlist } .)
    INPUT           reduce using rule 64 (block -> { stmtlist } .)
    STR             reduce using rule 64 (block -> { stmtlist } .)
    ATOI            reduce using rule 64 (block -> { stmtlist } .)
    !               reduce using rule 64 (block -> { stmtlist } .)
    -               reduce using rule 64 (block -> { stmtlist } .)
    STRING          reduce using rule 64 (block -> { stmtlist } .)
    NUM             reduce using rule 64 (block -> { stmtlist } .)
    TRUE            reduce using rule 64 (block -> { stmtlist } .)
    FALSE           reduce using rule 64 (block -> { stmtlist } .)
    (               reduce using rule 64 (block -> { stmtlist } .)
    $end            reduce using rule 64 (block -> { stmtlist } .)
    ELSE            reduce using rule 64 (block -> { stmtlist } .)
    }               reduce using rule 64 (block -> { stmtlist } .)


state 140

    (19) stmt -> expr [ expr ] = expr . ;
    (29) expr -> expr . + expr
    (30) expr -> expr . - expr
    (31) expr -> expr . * expr
    (32) expr -> expr . / expr
    (33) expr -> expr . % expr
    (34) expr -> expr . OR expr
    (35) expr -> expr . AND expr
    (36) expr -> expr . > expr
    (37) expr -> expr . < expr
    (38) expr -> expr . GTE expr
    (39) expr -> expr . LTE expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . $ expr
    (46) expr -> expr . [ expr ]

    ;               shift and go to state 143
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 141

    (9) stmt -> WHILE new_label ( expr ) jz . block
    (64) block -> . { stmtlist }
    (65) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (18) stmt -> . ID = expr ;
    (19) stmt -> . expr [ expr ] = expr ;
    (20) stmt -> . RETURN expr ;
    (21) stmt -> . RETURN ;
    (22) stmt -> . PRINTI ( expr ) ;
    (23) stmt -> . expr ;
    (24) stmt -> . FREE ( expr ) ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    {               shift and go to state 113
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    IF              shift and go to state 34
    ID              shift and go to state 35
    RETURN          shift and go to state 36
    PRINTI          shift and go to state 37
    FREE            shift and go to state 38
    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 31
    block                          shift and go to state 144
    stmt                           shift and go to state 114

state 142

    (10) stmt -> IF ( expr ) jz block .
    (11) stmt -> IF ( expr ) jz block . ELSE jmp jz_label block

  ! shift/reduce conflict for ELSE resolved as shift
    PRINT           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    PRINTLN         reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    WHILE           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    IF              reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ID              reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    RETURN          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    PRINTI          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    FREE            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ALLOC           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    INPUT           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    STR             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ATOI            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    !               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    -               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    STRING          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    NUM             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    TRUE            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    FALSE           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    (               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    $end            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    DEF             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    }               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ELSE            shift and go to state 145

  ! ELSE            [ reduce using rule 10 (stmt -> IF ( expr ) jz block .) ]


state 143

    (19) stmt -> expr [ expr ] = expr ; .

    PRINT           reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    PRINTLN         reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    WHILE           reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    IF              reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    ID              reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    RETURN          reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    PRINTI          reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    FREE            reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    ALLOC           reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    INPUT           reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    STR             reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    ATOI            reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    !               reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    -               reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    STRING          reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    NUM             reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    TRUE            reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    FALSE           reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    (               reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    $end            reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    DEF             reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    }               reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)
    ELSE            reduce using rule 19 (stmt -> expr [ expr ] = expr ; .)


state 144

    (9) stmt -> WHILE new_label ( expr ) jz block .

    PRINT           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    PRINTLN         reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    WHILE           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    IF              reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ID              reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    RETURN          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    PRINTI          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    FREE            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ALLOC           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    INPUT           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    STR             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ATOI            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    !               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    -               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    STRING          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    NUM             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    TRUE            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    FALSE           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    (               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    $end            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    DEF             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    }               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ELSE            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)


state 145

    (11) stmt -> IF ( expr ) jz block ELSE . jmp jz_label block
    (12) jmp -> .

    {               reduce using rule 12 (jmp -> .)
    PRINT           reduce using rule 12 (jmp -> .)
    PRINTLN         reduce using rule 12 (jmp -> .)
    WHILE           reduce using rule 12 (jmp -> .)
    IF              reduce using rule 12 (jmp -> .)
    ID              reduce using rule 12 (jmp -> .)
    RETURN          reduce using rule 12 (jmp -> .)
    PRINTI          reduce using rule 12 (jmp -> .)
    FREE            reduce using rule 12 (jmp -> .)
    ALLOC           reduce using rule 12 (jmp -> .)
    INPUT           reduce using rule 12 (jmp -> .)
    STR             reduce using rule 12 (jmp -> .)
    ATOI            reduce using rule 12 (jmp -> .)
    !               reduce using rule 12 (jmp -> .)
    -               reduce using rule 12 (jmp -> .)
    STRING          reduce using rule 12 (jmp -> .)
    NUM             reduce using rule 12 (jmp -> .)
    TRUE            reduce using rule 12 (jmp -> .)
    FALSE           reduce using rule 12 (jmp -> .)
    (               reduce using rule 12 (jmp -> .)

    jmp                            shift and go to state 146

state 146

    (11) stmt -> IF ( expr ) jz block ELSE jmp . jz_label block
    (14) jz_label -> .

    {               reduce using rule 14 (jz_label -> .)
    PRINT           reduce using rule 14 (jz_label -> .)
    PRINTLN         reduce using rule 14 (jz_label -> .)
    WHILE           reduce using rule 14 (jz_label -> .)
    IF              reduce using rule 14 (jz_label -> .)
    ID              reduce using rule 14 (jz_label -> .)
    RETURN          reduce using rule 14 (jz_label -> .)
    PRINTI          reduce using rule 14 (jz_label -> .)
    FREE            reduce using rule 14 (jz_label -> .)
    ALLOC           reduce using rule 14 (jz_label -> .)
    INPUT           reduce using rule 14 (jz_label -> .)
    STR             reduce using rule 14 (jz_label -> .)
    ATOI            reduce using rule 14 (jz_label -> .)
    !               reduce using rule 14 (jz_label -> .)
    -               reduce using rule 14 (jz_label -> .)
    STRING          reduce using rule 14 (jz_label -> .)
    NUM             reduce using rule 14 (jz_label -> .)
    TRUE            reduce using rule 14 (jz_label -> .)
    FALSE           reduce using rule 14 (jz_label -> .)
    (               reduce using rule 14 (jz_label -> .)

    jz_label                       shift and go to state 147

state 147

    (11) stmt -> IF ( expr ) jz block ELSE jmp jz_label . block
    (64) block -> . { stmtlist }
    (65) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (18) stmt -> . ID = expr ;
    (19) stmt -> . expr [ expr ] = expr ;
    (20) stmt -> . RETURN expr ;
    (21) stmt -> . RETURN ;
    (22) stmt -> . PRINTI ( expr ) ;
    (23) stmt -> . expr ;
    (24) stmt -> . FREE ( expr ) ;
    (25) expr -> . ALLOC ( NUM )
    (26) expr -> . INPUT ( )
    (27) expr -> . STR ( expr )
    (28) expr -> . ATOI ( expr )
    (29) expr -> . expr + expr
    (30) expr -> . expr - expr
    (31) expr -> . expr * expr
    (32) expr -> . expr / expr
    (33) expr -> . expr % expr
    (34) expr -> . expr OR expr
    (35) expr -> . expr AND expr
    (36) expr -> . expr > expr
    (37) expr -> . expr < expr
    (38) expr -> . expr GTE expr
    (39) expr -> . expr LTE expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr $ expr
    (43) expr -> . ! expr
    (44) expr -> . - expr
    (45) expr -> . ID
    (46) expr -> . expr [ expr ]
    (47) expr -> . STRING
    (48) expr -> . NUM
    (49) expr -> . TRUE
    (50) expr -> . FALSE
    (51) expr -> . ID ( exprlist )
    (52) expr -> . ID ( )
    (53) expr -> . ( expr )

    {               shift and go to state 113
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    IF              shift and go to state 34
    ID              shift and go to state 35
    RETURN          shift and go to state 36
    PRINTI          shift and go to state 37
    FREE            shift and go to state 38
    ALLOC           shift and go to state 18
    INPUT           shift and go to state 21
    STR             shift and go to state 22
    ATOI            shift and go to state 23
    !               shift and go to state 25
    -               shift and go to state 24
    STRING          shift and go to state 26
    NUM             shift and go to state 20
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 31
    block                          shift and go to state 148
    stmt                           shift and go to state 114

state 148

    (11) stmt -> IF ( expr ) jz block ELSE jmp jz_label block .

    PRINT           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    PRINTLN         reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    WHILE           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    IF              reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ID              reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    RETURN          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    PRINTI          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    FREE            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ALLOC           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    INPUT           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STR             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ATOI            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    !               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    -               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STRING          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    NUM             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    TRUE            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    FALSE           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    (               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    $end            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    DEF             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    }               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ELSE            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 142 resolved as shift
