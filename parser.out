Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declist start funlist entrypoint stmtlist
Rule 2     start -> <empty>
Rule 3     entrypoint -> <empty>
Rule 4     fun -> DEF fun_name ( idlist ) block
Rule 5     fun -> DEF fun_name ( ) block
Rule 6     fun_name -> ID
Rule 7     stmt -> PRINT ( expr ) ;
Rule 8     stmt -> PRINTLN ( ) ;
Rule 9     stmt -> WHILE new_label ( expr ) jz block
Rule 10    stmt -> BREAK ;
Rule 11    stmt -> CONTINUE ;
Rule 12    stmt -> IF ( expr ) jz block
Rule 13    stmt -> IF ( expr ) jz block ELSE jmp jz_label block
Rule 14    jmp -> <empty>
Rule 15    jz -> <empty>
Rule 16    jz_label -> <empty>
Rule 17    new_label -> <empty>
Rule 18    var_declare -> VAR ID = expr ;
Rule 19    var_declare -> VAR ID ;
Rule 20    stmt -> ID = expr ;
Rule 21    stmt -> arr_id [ expr ] = expr ;
Rule 22    arr_id -> ID
Rule 23    stmt -> RETURN expr ;
Rule 24    stmt -> RETURN ;
Rule 25    stmt -> PRINTI ( expr ) ;
Rule 26    stmt -> expr ;
Rule 27    expr -> INPUT ( )
Rule 28    expr -> STR ( expr )
Rule 29    expr -> ATOI ( expr )
Rule 30    expr -> ALLOC ( expr )
Rule 31    expr -> expr + expr
Rule 32    expr -> expr - expr
Rule 33    expr -> expr * expr
Rule 34    expr -> expr / expr
Rule 35    expr -> expr % expr
Rule 36    expr -> expr OR expr
Rule 37    expr -> expr AND expr
Rule 38    expr -> expr > expr
Rule 39    expr -> expr < expr
Rule 40    expr -> expr GTE expr
Rule 41    expr -> expr LTE expr
Rule 42    expr -> expr EQ expr
Rule 43    expr -> expr NEQ expr
Rule 44    expr -> expr $ expr
Rule 45    expr -> ! expr
Rule 46    expr -> - expr
Rule 47    expr -> ID
Rule 48    expr -> expr [ expr ]
Rule 49    expr -> STRING
Rule 50    expr -> NUM
Rule 51    expr -> TRUE
Rule 52    expr -> FALSE
Rule 53    expr -> ID ( exprlist )
Rule 54    expr -> ID ( )
Rule 55    expr -> ( expr )
Rule 56    declist -> declist var_declare
Rule 57    declist -> <empty>
Rule 58    funlist -> funlist fun
Rule 59    funlist -> <empty>
Rule 60    stmtlist -> stmtlist stmt
Rule 61    stmtlist -> <empty>
Rule 62    idlist -> idlist , ID
Rule 63    idlist -> ID
Rule 64    exprlist -> exprlist , expr
Rule 65    exprlist -> expr
Rule 66    block -> { stmtlist }
Rule 67    block -> stmt

Terminals, with rules where they appear

!                    : 45
$                    : 44
%                    : 35
(                    : 4 5 7 8 9 12 13 25 27 28 29 30 53 54 55
)                    : 4 5 7 8 9 12 13 25 27 28 29 30 53 54 55
*                    : 33
+                    : 31
,                    : 62 64
-                    : 32 46
/                    : 34
;                    : 7 8 10 11 18 19 20 21 23 24 25 26
<                    : 39
=                    : 18 20 21
>                    : 38
ALLOC                : 30
AND                  : 37
ATOI                 : 29
BREAK                : 10
CONTINUE             : 11
DEF                  : 4 5
ELSE                 : 13
EQ                   : 42
FALSE                : 52
GTE                  : 40
ID                   : 6 18 19 20 22 47 53 54 62 63
IF                   : 12 13
INPUT                : 27
LTE                  : 41
NEQ                  : 43
NUM                  : 50
OR                   : 36
PRINT                : 7
PRINTI               : 25
PRINTLN              : 8
RETURN               : 23 24
STR                  : 28
STRING               : 49
TRUE                 : 51
VAR                  : 18 19
WHILE                : 9
[                    : 21 48
]                    : 21 48
error                : 
{                    : 66
}                    : 66

Nonterminals, with rules where they appear

arr_id               : 21
block                : 4 5 9 12 13 13
declist              : 1 56
entrypoint           : 1
expr                 : 7 9 12 13 18 20 21 21 23 25 26 28 29 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 46 48 48 55 64 65
exprlist             : 53 64
fun                  : 58
fun_name             : 4 5
funlist              : 1 58
idlist               : 4 62
jmp                  : 13
jz                   : 9 12 13
jz_label             : 13
new_label            : 9
program              : 0
start                : 1
stmt                 : 60 67
stmtlist             : 1 60 66
var_declare          : 56

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declist start funlist entrypoint stmtlist
    (56) declist -> . declist var_declare
    (57) declist -> .

    VAR             reduce using rule 57 (declist -> .)
    DEF             reduce using rule 57 (declist -> .)
    PRINT           reduce using rule 57 (declist -> .)
    PRINTLN         reduce using rule 57 (declist -> .)
    WHILE           reduce using rule 57 (declist -> .)
    BREAK           reduce using rule 57 (declist -> .)
    CONTINUE        reduce using rule 57 (declist -> .)
    IF              reduce using rule 57 (declist -> .)
    ID              reduce using rule 57 (declist -> .)
    RETURN          reduce using rule 57 (declist -> .)
    PRINTI          reduce using rule 57 (declist -> .)
    INPUT           reduce using rule 57 (declist -> .)
    STR             reduce using rule 57 (declist -> .)
    ATOI            reduce using rule 57 (declist -> .)
    ALLOC           reduce using rule 57 (declist -> .)
    !               reduce using rule 57 (declist -> .)
    -               reduce using rule 57 (declist -> .)
    STRING          reduce using rule 57 (declist -> .)
    NUM             reduce using rule 57 (declist -> .)
    TRUE            reduce using rule 57 (declist -> .)
    FALSE           reduce using rule 57 (declist -> .)
    (               reduce using rule 57 (declist -> .)
    $end            reduce using rule 57 (declist -> .)

    program                        shift and go to state 1
    declist                        shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> declist . start funlist entrypoint stmtlist
    (56) declist -> declist . var_declare
    (2) start -> .
    (18) var_declare -> . VAR ID = expr ;
    (19) var_declare -> . VAR ID ;

    DEF             reduce using rule 2 (start -> .)
    PRINT           reduce using rule 2 (start -> .)
    PRINTLN         reduce using rule 2 (start -> .)
    WHILE           reduce using rule 2 (start -> .)
    BREAK           reduce using rule 2 (start -> .)
    CONTINUE        reduce using rule 2 (start -> .)
    IF              reduce using rule 2 (start -> .)
    ID              reduce using rule 2 (start -> .)
    RETURN          reduce using rule 2 (start -> .)
    PRINTI          reduce using rule 2 (start -> .)
    INPUT           reduce using rule 2 (start -> .)
    STR             reduce using rule 2 (start -> .)
    ATOI            reduce using rule 2 (start -> .)
    ALLOC           reduce using rule 2 (start -> .)
    !               reduce using rule 2 (start -> .)
    -               reduce using rule 2 (start -> .)
    STRING          reduce using rule 2 (start -> .)
    NUM             reduce using rule 2 (start -> .)
    TRUE            reduce using rule 2 (start -> .)
    FALSE           reduce using rule 2 (start -> .)
    (               reduce using rule 2 (start -> .)
    $end            reduce using rule 2 (start -> .)
    VAR             shift and go to state 5

    start                          shift and go to state 3
    var_declare                    shift and go to state 4

state 3

    (1) program -> declist start . funlist entrypoint stmtlist
    (58) funlist -> . funlist fun
    (59) funlist -> .

    DEF             reduce using rule 59 (funlist -> .)
    PRINT           reduce using rule 59 (funlist -> .)
    PRINTLN         reduce using rule 59 (funlist -> .)
    WHILE           reduce using rule 59 (funlist -> .)
    BREAK           reduce using rule 59 (funlist -> .)
    CONTINUE        reduce using rule 59 (funlist -> .)
    IF              reduce using rule 59 (funlist -> .)
    ID              reduce using rule 59 (funlist -> .)
    RETURN          reduce using rule 59 (funlist -> .)
    PRINTI          reduce using rule 59 (funlist -> .)
    INPUT           reduce using rule 59 (funlist -> .)
    STR             reduce using rule 59 (funlist -> .)
    ATOI            reduce using rule 59 (funlist -> .)
    ALLOC           reduce using rule 59 (funlist -> .)
    !               reduce using rule 59 (funlist -> .)
    -               reduce using rule 59 (funlist -> .)
    STRING          reduce using rule 59 (funlist -> .)
    NUM             reduce using rule 59 (funlist -> .)
    TRUE            reduce using rule 59 (funlist -> .)
    FALSE           reduce using rule 59 (funlist -> .)
    (               reduce using rule 59 (funlist -> .)
    $end            reduce using rule 59 (funlist -> .)

    funlist                        shift and go to state 6

state 4

    (56) declist -> declist var_declare .

    VAR             reduce using rule 56 (declist -> declist var_declare .)
    DEF             reduce using rule 56 (declist -> declist var_declare .)
    PRINT           reduce using rule 56 (declist -> declist var_declare .)
    PRINTLN         reduce using rule 56 (declist -> declist var_declare .)
    WHILE           reduce using rule 56 (declist -> declist var_declare .)
    BREAK           reduce using rule 56 (declist -> declist var_declare .)
    CONTINUE        reduce using rule 56 (declist -> declist var_declare .)
    IF              reduce using rule 56 (declist -> declist var_declare .)
    ID              reduce using rule 56 (declist -> declist var_declare .)
    RETURN          reduce using rule 56 (declist -> declist var_declare .)
    PRINTI          reduce using rule 56 (declist -> declist var_declare .)
    INPUT           reduce using rule 56 (declist -> declist var_declare .)
    STR             reduce using rule 56 (declist -> declist var_declare .)
    ATOI            reduce using rule 56 (declist -> declist var_declare .)
    ALLOC           reduce using rule 56 (declist -> declist var_declare .)
    !               reduce using rule 56 (declist -> declist var_declare .)
    -               reduce using rule 56 (declist -> declist var_declare .)
    STRING          reduce using rule 56 (declist -> declist var_declare .)
    NUM             reduce using rule 56 (declist -> declist var_declare .)
    TRUE            reduce using rule 56 (declist -> declist var_declare .)
    FALSE           reduce using rule 56 (declist -> declist var_declare .)
    (               reduce using rule 56 (declist -> declist var_declare .)
    $end            reduce using rule 56 (declist -> declist var_declare .)


state 5

    (18) var_declare -> VAR . ID = expr ;
    (19) var_declare -> VAR . ID ;

    ID              shift and go to state 7


state 6

    (1) program -> declist start funlist . entrypoint stmtlist
    (58) funlist -> funlist . fun
    (3) entrypoint -> .
    (4) fun -> . DEF fun_name ( idlist ) block
    (5) fun -> . DEF fun_name ( ) block

    PRINT           reduce using rule 3 (entrypoint -> .)
    PRINTLN         reduce using rule 3 (entrypoint -> .)
    WHILE           reduce using rule 3 (entrypoint -> .)
    BREAK           reduce using rule 3 (entrypoint -> .)
    CONTINUE        reduce using rule 3 (entrypoint -> .)
    IF              reduce using rule 3 (entrypoint -> .)
    ID              reduce using rule 3 (entrypoint -> .)
    RETURN          reduce using rule 3 (entrypoint -> .)
    PRINTI          reduce using rule 3 (entrypoint -> .)
    INPUT           reduce using rule 3 (entrypoint -> .)
    STR             reduce using rule 3 (entrypoint -> .)
    ATOI            reduce using rule 3 (entrypoint -> .)
    ALLOC           reduce using rule 3 (entrypoint -> .)
    !               reduce using rule 3 (entrypoint -> .)
    -               reduce using rule 3 (entrypoint -> .)
    STRING          reduce using rule 3 (entrypoint -> .)
    NUM             reduce using rule 3 (entrypoint -> .)
    TRUE            reduce using rule 3 (entrypoint -> .)
    FALSE           reduce using rule 3 (entrypoint -> .)
    (               reduce using rule 3 (entrypoint -> .)
    $end            reduce using rule 3 (entrypoint -> .)
    DEF             shift and go to state 10

    entrypoint                     shift and go to state 8
    fun                            shift and go to state 9

state 7

    (18) var_declare -> VAR ID . = expr ;
    (19) var_declare -> VAR ID . ;

    =               shift and go to state 11
    ;               shift and go to state 12


state 8

    (1) program -> declist start funlist entrypoint . stmtlist
    (60) stmtlist -> . stmtlist stmt
    (61) stmtlist -> .

    PRINT           reduce using rule 61 (stmtlist -> .)
    PRINTLN         reduce using rule 61 (stmtlist -> .)
    WHILE           reduce using rule 61 (stmtlist -> .)
    BREAK           reduce using rule 61 (stmtlist -> .)
    CONTINUE        reduce using rule 61 (stmtlist -> .)
    IF              reduce using rule 61 (stmtlist -> .)
    ID              reduce using rule 61 (stmtlist -> .)
    RETURN          reduce using rule 61 (stmtlist -> .)
    PRINTI          reduce using rule 61 (stmtlist -> .)
    INPUT           reduce using rule 61 (stmtlist -> .)
    STR             reduce using rule 61 (stmtlist -> .)
    ATOI            reduce using rule 61 (stmtlist -> .)
    ALLOC           reduce using rule 61 (stmtlist -> .)
    !               reduce using rule 61 (stmtlist -> .)
    -               reduce using rule 61 (stmtlist -> .)
    STRING          reduce using rule 61 (stmtlist -> .)
    NUM             reduce using rule 61 (stmtlist -> .)
    TRUE            reduce using rule 61 (stmtlist -> .)
    FALSE           reduce using rule 61 (stmtlist -> .)
    (               reduce using rule 61 (stmtlist -> .)
    $end            reduce using rule 61 (stmtlist -> .)

    stmtlist                       shift and go to state 13

state 9

    (58) funlist -> funlist fun .

    DEF             reduce using rule 58 (funlist -> funlist fun .)
    PRINT           reduce using rule 58 (funlist -> funlist fun .)
    PRINTLN         reduce using rule 58 (funlist -> funlist fun .)
    WHILE           reduce using rule 58 (funlist -> funlist fun .)
    BREAK           reduce using rule 58 (funlist -> funlist fun .)
    CONTINUE        reduce using rule 58 (funlist -> funlist fun .)
    IF              reduce using rule 58 (funlist -> funlist fun .)
    ID              reduce using rule 58 (funlist -> funlist fun .)
    RETURN          reduce using rule 58 (funlist -> funlist fun .)
    PRINTI          reduce using rule 58 (funlist -> funlist fun .)
    INPUT           reduce using rule 58 (funlist -> funlist fun .)
    STR             reduce using rule 58 (funlist -> funlist fun .)
    ATOI            reduce using rule 58 (funlist -> funlist fun .)
    ALLOC           reduce using rule 58 (funlist -> funlist fun .)
    !               reduce using rule 58 (funlist -> funlist fun .)
    -               reduce using rule 58 (funlist -> funlist fun .)
    STRING          reduce using rule 58 (funlist -> funlist fun .)
    NUM             reduce using rule 58 (funlist -> funlist fun .)
    TRUE            reduce using rule 58 (funlist -> funlist fun .)
    FALSE           reduce using rule 58 (funlist -> funlist fun .)
    (               reduce using rule 58 (funlist -> funlist fun .)
    $end            reduce using rule 58 (funlist -> funlist fun .)


state 10

    (4) fun -> DEF . fun_name ( idlist ) block
    (5) fun -> DEF . fun_name ( ) block
    (6) fun_name -> . ID

    ID              shift and go to state 15

    fun_name                       shift and go to state 14

state 11

    (18) var_declare -> VAR ID = . expr ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 17

state 12

    (19) var_declare -> VAR ID ; .

    VAR             reduce using rule 19 (var_declare -> VAR ID ; .)
    DEF             reduce using rule 19 (var_declare -> VAR ID ; .)
    PRINT           reduce using rule 19 (var_declare -> VAR ID ; .)
    PRINTLN         reduce using rule 19 (var_declare -> VAR ID ; .)
    WHILE           reduce using rule 19 (var_declare -> VAR ID ; .)
    BREAK           reduce using rule 19 (var_declare -> VAR ID ; .)
    CONTINUE        reduce using rule 19 (var_declare -> VAR ID ; .)
    IF              reduce using rule 19 (var_declare -> VAR ID ; .)
    ID              reduce using rule 19 (var_declare -> VAR ID ; .)
    RETURN          reduce using rule 19 (var_declare -> VAR ID ; .)
    PRINTI          reduce using rule 19 (var_declare -> VAR ID ; .)
    INPUT           reduce using rule 19 (var_declare -> VAR ID ; .)
    STR             reduce using rule 19 (var_declare -> VAR ID ; .)
    ATOI            reduce using rule 19 (var_declare -> VAR ID ; .)
    ALLOC           reduce using rule 19 (var_declare -> VAR ID ; .)
    !               reduce using rule 19 (var_declare -> VAR ID ; .)
    -               reduce using rule 19 (var_declare -> VAR ID ; .)
    STRING          reduce using rule 19 (var_declare -> VAR ID ; .)
    NUM             reduce using rule 19 (var_declare -> VAR ID ; .)
    TRUE            reduce using rule 19 (var_declare -> VAR ID ; .)
    FALSE           reduce using rule 19 (var_declare -> VAR ID ; .)
    (               reduce using rule 19 (var_declare -> VAR ID ; .)
    $end            reduce using rule 19 (var_declare -> VAR ID ; .)


state 13

    (1) program -> declist start funlist entrypoint stmtlist .
    (60) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . BREAK ;
    (11) stmt -> . CONTINUE ;
    (12) stmt -> . IF ( expr ) jz block
    (13) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . arr_id [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    $end            reduce using rule 1 (program -> declist start funlist entrypoint stmtlist .)
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    BREAK           shift and go to state 34
    CONTINUE        shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    stmt                           shift and go to state 29
    expr                           shift and go to state 31
    arr_id                         shift and go to state 38

state 14

    (4) fun -> DEF fun_name . ( idlist ) block
    (5) fun -> DEF fun_name . ( ) block

    (               shift and go to state 41


state 15

    (6) fun_name -> ID .

    (               reduce using rule 6 (fun_name -> ID .)


state 16

    (47) expr -> ID .
    (53) expr -> ID . ( exprlist )
    (54) expr -> ID . ( )

    ;               reduce using rule 47 (expr -> ID .)
    +               reduce using rule 47 (expr -> ID .)
    -               reduce using rule 47 (expr -> ID .)
    *               reduce using rule 47 (expr -> ID .)
    /               reduce using rule 47 (expr -> ID .)
    %               reduce using rule 47 (expr -> ID .)
    OR              reduce using rule 47 (expr -> ID .)
    AND             reduce using rule 47 (expr -> ID .)
    >               reduce using rule 47 (expr -> ID .)
    <               reduce using rule 47 (expr -> ID .)
    GTE             reduce using rule 47 (expr -> ID .)
    LTE             reduce using rule 47 (expr -> ID .)
    EQ              reduce using rule 47 (expr -> ID .)
    NEQ             reduce using rule 47 (expr -> ID .)
    $               reduce using rule 47 (expr -> ID .)
    [               reduce using rule 47 (expr -> ID .)
    )               reduce using rule 47 (expr -> ID .)
    ,               reduce using rule 47 (expr -> ID .)
    ]               reduce using rule 47 (expr -> ID .)
    (               shift and go to state 42


state 17

    (18) var_declare -> VAR ID = expr . ;
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               shift and go to state 43
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 18

    (27) expr -> INPUT . ( )

    (               shift and go to state 59


state 19

    (55) expr -> ( . expr )
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 60

state 20

    (28) expr -> STR . ( expr )

    (               shift and go to state 61


state 21

    (29) expr -> ATOI . ( expr )

    (               shift and go to state 62


state 22

    (30) expr -> ALLOC . ( expr )

    (               shift and go to state 63


state 23

    (46) expr -> - . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 64

state 24

    (45) expr -> ! . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 65

state 25

    (49) expr -> STRING .

    ;               reduce using rule 49 (expr -> STRING .)
    +               reduce using rule 49 (expr -> STRING .)
    -               reduce using rule 49 (expr -> STRING .)
    *               reduce using rule 49 (expr -> STRING .)
    /               reduce using rule 49 (expr -> STRING .)
    %               reduce using rule 49 (expr -> STRING .)
    OR              reduce using rule 49 (expr -> STRING .)
    AND             reduce using rule 49 (expr -> STRING .)
    >               reduce using rule 49 (expr -> STRING .)
    <               reduce using rule 49 (expr -> STRING .)
    GTE             reduce using rule 49 (expr -> STRING .)
    LTE             reduce using rule 49 (expr -> STRING .)
    EQ              reduce using rule 49 (expr -> STRING .)
    NEQ             reduce using rule 49 (expr -> STRING .)
    $               reduce using rule 49 (expr -> STRING .)
    [               reduce using rule 49 (expr -> STRING .)
    )               reduce using rule 49 (expr -> STRING .)
    ,               reduce using rule 49 (expr -> STRING .)
    ]               reduce using rule 49 (expr -> STRING .)


state 26

    (50) expr -> NUM .

    ;               reduce using rule 50 (expr -> NUM .)
    +               reduce using rule 50 (expr -> NUM .)
    -               reduce using rule 50 (expr -> NUM .)
    *               reduce using rule 50 (expr -> NUM .)
    /               reduce using rule 50 (expr -> NUM .)
    %               reduce using rule 50 (expr -> NUM .)
    OR              reduce using rule 50 (expr -> NUM .)
    AND             reduce using rule 50 (expr -> NUM .)
    >               reduce using rule 50 (expr -> NUM .)
    <               reduce using rule 50 (expr -> NUM .)
    GTE             reduce using rule 50 (expr -> NUM .)
    LTE             reduce using rule 50 (expr -> NUM .)
    EQ              reduce using rule 50 (expr -> NUM .)
    NEQ             reduce using rule 50 (expr -> NUM .)
    $               reduce using rule 50 (expr -> NUM .)
    [               reduce using rule 50 (expr -> NUM .)
    )               reduce using rule 50 (expr -> NUM .)
    ,               reduce using rule 50 (expr -> NUM .)
    ]               reduce using rule 50 (expr -> NUM .)


state 27

    (51) expr -> TRUE .

    ;               reduce using rule 51 (expr -> TRUE .)
    +               reduce using rule 51 (expr -> TRUE .)
    -               reduce using rule 51 (expr -> TRUE .)
    *               reduce using rule 51 (expr -> TRUE .)
    /               reduce using rule 51 (expr -> TRUE .)
    %               reduce using rule 51 (expr -> TRUE .)
    OR              reduce using rule 51 (expr -> TRUE .)
    AND             reduce using rule 51 (expr -> TRUE .)
    >               reduce using rule 51 (expr -> TRUE .)
    <               reduce using rule 51 (expr -> TRUE .)
    GTE             reduce using rule 51 (expr -> TRUE .)
    LTE             reduce using rule 51 (expr -> TRUE .)
    EQ              reduce using rule 51 (expr -> TRUE .)
    NEQ             reduce using rule 51 (expr -> TRUE .)
    $               reduce using rule 51 (expr -> TRUE .)
    [               reduce using rule 51 (expr -> TRUE .)
    )               reduce using rule 51 (expr -> TRUE .)
    ,               reduce using rule 51 (expr -> TRUE .)
    ]               reduce using rule 51 (expr -> TRUE .)


state 28

    (52) expr -> FALSE .

    ;               reduce using rule 52 (expr -> FALSE .)
    +               reduce using rule 52 (expr -> FALSE .)
    -               reduce using rule 52 (expr -> FALSE .)
    *               reduce using rule 52 (expr -> FALSE .)
    /               reduce using rule 52 (expr -> FALSE .)
    %               reduce using rule 52 (expr -> FALSE .)
    OR              reduce using rule 52 (expr -> FALSE .)
    AND             reduce using rule 52 (expr -> FALSE .)
    >               reduce using rule 52 (expr -> FALSE .)
    <               reduce using rule 52 (expr -> FALSE .)
    GTE             reduce using rule 52 (expr -> FALSE .)
    LTE             reduce using rule 52 (expr -> FALSE .)
    EQ              reduce using rule 52 (expr -> FALSE .)
    NEQ             reduce using rule 52 (expr -> FALSE .)
    $               reduce using rule 52 (expr -> FALSE .)
    [               reduce using rule 52 (expr -> FALSE .)
    )               reduce using rule 52 (expr -> FALSE .)
    ,               reduce using rule 52 (expr -> FALSE .)
    ]               reduce using rule 52 (expr -> FALSE .)


state 29

    (60) stmtlist -> stmtlist stmt .

    PRINT           reduce using rule 60 (stmtlist -> stmtlist stmt .)
    PRINTLN         reduce using rule 60 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 60 (stmtlist -> stmtlist stmt .)
    BREAK           reduce using rule 60 (stmtlist -> stmtlist stmt .)
    CONTINUE        reduce using rule 60 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 60 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 60 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 60 (stmtlist -> stmtlist stmt .)
    PRINTI          reduce using rule 60 (stmtlist -> stmtlist stmt .)
    INPUT           reduce using rule 60 (stmtlist -> stmtlist stmt .)
    STR             reduce using rule 60 (stmtlist -> stmtlist stmt .)
    ATOI            reduce using rule 60 (stmtlist -> stmtlist stmt .)
    ALLOC           reduce using rule 60 (stmtlist -> stmtlist stmt .)
    !               reduce using rule 60 (stmtlist -> stmtlist stmt .)
    -               reduce using rule 60 (stmtlist -> stmtlist stmt .)
    STRING          reduce using rule 60 (stmtlist -> stmtlist stmt .)
    NUM             reduce using rule 60 (stmtlist -> stmtlist stmt .)
    TRUE            reduce using rule 60 (stmtlist -> stmtlist stmt .)
    FALSE           reduce using rule 60 (stmtlist -> stmtlist stmt .)
    (               reduce using rule 60 (stmtlist -> stmtlist stmt .)
    $end            reduce using rule 60 (stmtlist -> stmtlist stmt .)
    }               reduce using rule 60 (stmtlist -> stmtlist stmt .)


state 30

    (7) stmt -> PRINT . ( expr ) ;

    (               shift and go to state 66


state 31

    (26) stmt -> expr . ;
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               shift and go to state 67
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 32

    (8) stmt -> PRINTLN . ( ) ;

    (               shift and go to state 68


state 33

    (9) stmt -> WHILE . new_label ( expr ) jz block
    (17) new_label -> .

    (               reduce using rule 17 (new_label -> .)

    new_label                      shift and go to state 69

state 34

    (10) stmt -> BREAK . ;

    ;               shift and go to state 70


state 35

    (11) stmt -> CONTINUE . ;

    ;               shift and go to state 71


state 36

    (12) stmt -> IF . ( expr ) jz block
    (13) stmt -> IF . ( expr ) jz block ELSE jmp jz_label block

    (               shift and go to state 72


state 37

    (20) stmt -> ID . = expr ;
    (22) arr_id -> ID .
    (47) expr -> ID .
    (53) expr -> ID . ( exprlist )
    (54) expr -> ID . ( )

  ! reduce/reduce conflict for [ resolved using rule 22 (arr_id -> ID .)
    =               shift and go to state 73
    [               reduce using rule 22 (arr_id -> ID .)
    ;               reduce using rule 47 (expr -> ID .)
    +               reduce using rule 47 (expr -> ID .)
    -               reduce using rule 47 (expr -> ID .)
    *               reduce using rule 47 (expr -> ID .)
    /               reduce using rule 47 (expr -> ID .)
    %               reduce using rule 47 (expr -> ID .)
    OR              reduce using rule 47 (expr -> ID .)
    AND             reduce using rule 47 (expr -> ID .)
    >               reduce using rule 47 (expr -> ID .)
    <               reduce using rule 47 (expr -> ID .)
    GTE             reduce using rule 47 (expr -> ID .)
    LTE             reduce using rule 47 (expr -> ID .)
    EQ              reduce using rule 47 (expr -> ID .)
    NEQ             reduce using rule 47 (expr -> ID .)
    $               reduce using rule 47 (expr -> ID .)
    (               shift and go to state 42

  ! [               [ reduce using rule 47 (expr -> ID .) ]


state 38

    (21) stmt -> arr_id . [ expr ] = expr ;

    [               shift and go to state 74


state 39

    (23) stmt -> RETURN . expr ;
    (24) stmt -> RETURN . ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    ;               shift and go to state 76
    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 75

state 40

    (25) stmt -> PRINTI . ( expr ) ;

    (               shift and go to state 77


state 41

    (4) fun -> DEF fun_name ( . idlist ) block
    (5) fun -> DEF fun_name ( . ) block
    (62) idlist -> . idlist , ID
    (63) idlist -> . ID

    )               shift and go to state 79
    ID              shift and go to state 80

    idlist                         shift and go to state 78

state 42

    (53) expr -> ID ( . exprlist )
    (54) expr -> ID ( . )
    (64) exprlist -> . exprlist , expr
    (65) exprlist -> . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    )               shift and go to state 82
    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    exprlist                       shift and go to state 81
    expr                           shift and go to state 83

state 43

    (18) var_declare -> VAR ID = expr ; .

    VAR             reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    DEF             reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    PRINT           reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    PRINTLN         reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    WHILE           reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    BREAK           reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    CONTINUE        reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    IF              reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    ID              reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    RETURN          reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    PRINTI          reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    INPUT           reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    STR             reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    ATOI            reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    ALLOC           reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    !               reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    -               reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    STRING          reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    NUM             reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    TRUE            reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    FALSE           reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    (               reduce using rule 18 (var_declare -> VAR ID = expr ; .)
    $end            reduce using rule 18 (var_declare -> VAR ID = expr ; .)


state 44

    (31) expr -> expr + . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 84

state 45

    (32) expr -> expr - . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 85

state 46

    (33) expr -> expr * . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 86

state 47

    (34) expr -> expr / . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 87

state 48

    (35) expr -> expr % . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 88

state 49

    (36) expr -> expr OR . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 89

state 50

    (37) expr -> expr AND . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 90

state 51

    (38) expr -> expr > . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 91

state 52

    (39) expr -> expr < . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 92

state 53

    (40) expr -> expr GTE . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 93

state 54

    (41) expr -> expr LTE . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 94

state 55

    (42) expr -> expr EQ . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 95

state 56

    (43) expr -> expr NEQ . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 96

state 57

    (44) expr -> expr $ . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 97

state 58

    (48) expr -> expr [ . expr ]
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 98

state 59

    (27) expr -> INPUT ( . )

    )               shift and go to state 99


state 60

    (55) expr -> ( expr . )
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    )               shift and go to state 100
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 61

    (28) expr -> STR ( . expr )
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 101

state 62

    (29) expr -> ATOI ( . expr )
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 102

state 63

    (30) expr -> ALLOC ( . expr )
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 103

state 64

    (46) expr -> - expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 46 (expr -> - expr .)
    +               reduce using rule 46 (expr -> - expr .)
    -               reduce using rule 46 (expr -> - expr .)
    *               reduce using rule 46 (expr -> - expr .)
    /               reduce using rule 46 (expr -> - expr .)
    %               reduce using rule 46 (expr -> - expr .)
    OR              reduce using rule 46 (expr -> - expr .)
    AND             reduce using rule 46 (expr -> - expr .)
    >               reduce using rule 46 (expr -> - expr .)
    <               reduce using rule 46 (expr -> - expr .)
    GTE             reduce using rule 46 (expr -> - expr .)
    LTE             reduce using rule 46 (expr -> - expr .)
    EQ              reduce using rule 46 (expr -> - expr .)
    NEQ             reduce using rule 46 (expr -> - expr .)
    $               reduce using rule 46 (expr -> - expr .)
    [               reduce using rule 46 (expr -> - expr .)
    )               reduce using rule 46 (expr -> - expr .)
    ,               reduce using rule 46 (expr -> - expr .)
    ]               reduce using rule 46 (expr -> - expr .)

  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! /               [ shift and go to state 47 ]
  ! %               [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]
  ! [               [ shift and go to state 58 ]


state 65

    (45) expr -> ! expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 45 (expr -> ! expr .)
    +               reduce using rule 45 (expr -> ! expr .)
    -               reduce using rule 45 (expr -> ! expr .)
    *               reduce using rule 45 (expr -> ! expr .)
    /               reduce using rule 45 (expr -> ! expr .)
    %               reduce using rule 45 (expr -> ! expr .)
    OR              reduce using rule 45 (expr -> ! expr .)
    AND             reduce using rule 45 (expr -> ! expr .)
    >               reduce using rule 45 (expr -> ! expr .)
    <               reduce using rule 45 (expr -> ! expr .)
    GTE             reduce using rule 45 (expr -> ! expr .)
    LTE             reduce using rule 45 (expr -> ! expr .)
    EQ              reduce using rule 45 (expr -> ! expr .)
    NEQ             reduce using rule 45 (expr -> ! expr .)
    $               reduce using rule 45 (expr -> ! expr .)
    [               reduce using rule 45 (expr -> ! expr .)
    )               reduce using rule 45 (expr -> ! expr .)
    ,               reduce using rule 45 (expr -> ! expr .)
    ]               reduce using rule 45 (expr -> ! expr .)

  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! /               [ shift and go to state 47 ]
  ! %               [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]
  ! [               [ shift and go to state 58 ]


state 66

    (7) stmt -> PRINT ( . expr ) ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 104

state 67

    (26) stmt -> expr ; .

    PRINT           reduce using rule 26 (stmt -> expr ; .)
    PRINTLN         reduce using rule 26 (stmt -> expr ; .)
    WHILE           reduce using rule 26 (stmt -> expr ; .)
    BREAK           reduce using rule 26 (stmt -> expr ; .)
    CONTINUE        reduce using rule 26 (stmt -> expr ; .)
    IF              reduce using rule 26 (stmt -> expr ; .)
    ID              reduce using rule 26 (stmt -> expr ; .)
    RETURN          reduce using rule 26 (stmt -> expr ; .)
    PRINTI          reduce using rule 26 (stmt -> expr ; .)
    INPUT           reduce using rule 26 (stmt -> expr ; .)
    STR             reduce using rule 26 (stmt -> expr ; .)
    ATOI            reduce using rule 26 (stmt -> expr ; .)
    ALLOC           reduce using rule 26 (stmt -> expr ; .)
    !               reduce using rule 26 (stmt -> expr ; .)
    -               reduce using rule 26 (stmt -> expr ; .)
    STRING          reduce using rule 26 (stmt -> expr ; .)
    NUM             reduce using rule 26 (stmt -> expr ; .)
    TRUE            reduce using rule 26 (stmt -> expr ; .)
    FALSE           reduce using rule 26 (stmt -> expr ; .)
    (               reduce using rule 26 (stmt -> expr ; .)
    $end            reduce using rule 26 (stmt -> expr ; .)
    DEF             reduce using rule 26 (stmt -> expr ; .)
    }               reduce using rule 26 (stmt -> expr ; .)
    ELSE            reduce using rule 26 (stmt -> expr ; .)


state 68

    (8) stmt -> PRINTLN ( . ) ;

    )               shift and go to state 105


state 69

    (9) stmt -> WHILE new_label . ( expr ) jz block

    (               shift and go to state 106


state 70

    (10) stmt -> BREAK ; .

    PRINT           reduce using rule 10 (stmt -> BREAK ; .)
    PRINTLN         reduce using rule 10 (stmt -> BREAK ; .)
    WHILE           reduce using rule 10 (stmt -> BREAK ; .)
    BREAK           reduce using rule 10 (stmt -> BREAK ; .)
    CONTINUE        reduce using rule 10 (stmt -> BREAK ; .)
    IF              reduce using rule 10 (stmt -> BREAK ; .)
    ID              reduce using rule 10 (stmt -> BREAK ; .)
    RETURN          reduce using rule 10 (stmt -> BREAK ; .)
    PRINTI          reduce using rule 10 (stmt -> BREAK ; .)
    INPUT           reduce using rule 10 (stmt -> BREAK ; .)
    STR             reduce using rule 10 (stmt -> BREAK ; .)
    ATOI            reduce using rule 10 (stmt -> BREAK ; .)
    ALLOC           reduce using rule 10 (stmt -> BREAK ; .)
    !               reduce using rule 10 (stmt -> BREAK ; .)
    -               reduce using rule 10 (stmt -> BREAK ; .)
    STRING          reduce using rule 10 (stmt -> BREAK ; .)
    NUM             reduce using rule 10 (stmt -> BREAK ; .)
    TRUE            reduce using rule 10 (stmt -> BREAK ; .)
    FALSE           reduce using rule 10 (stmt -> BREAK ; .)
    (               reduce using rule 10 (stmt -> BREAK ; .)
    $end            reduce using rule 10 (stmt -> BREAK ; .)
    DEF             reduce using rule 10 (stmt -> BREAK ; .)
    }               reduce using rule 10 (stmt -> BREAK ; .)
    ELSE            reduce using rule 10 (stmt -> BREAK ; .)


state 71

    (11) stmt -> CONTINUE ; .

    PRINT           reduce using rule 11 (stmt -> CONTINUE ; .)
    PRINTLN         reduce using rule 11 (stmt -> CONTINUE ; .)
    WHILE           reduce using rule 11 (stmt -> CONTINUE ; .)
    BREAK           reduce using rule 11 (stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 11 (stmt -> CONTINUE ; .)
    IF              reduce using rule 11 (stmt -> CONTINUE ; .)
    ID              reduce using rule 11 (stmt -> CONTINUE ; .)
    RETURN          reduce using rule 11 (stmt -> CONTINUE ; .)
    PRINTI          reduce using rule 11 (stmt -> CONTINUE ; .)
    INPUT           reduce using rule 11 (stmt -> CONTINUE ; .)
    STR             reduce using rule 11 (stmt -> CONTINUE ; .)
    ATOI            reduce using rule 11 (stmt -> CONTINUE ; .)
    ALLOC           reduce using rule 11 (stmt -> CONTINUE ; .)
    !               reduce using rule 11 (stmt -> CONTINUE ; .)
    -               reduce using rule 11 (stmt -> CONTINUE ; .)
    STRING          reduce using rule 11 (stmt -> CONTINUE ; .)
    NUM             reduce using rule 11 (stmt -> CONTINUE ; .)
    TRUE            reduce using rule 11 (stmt -> CONTINUE ; .)
    FALSE           reduce using rule 11 (stmt -> CONTINUE ; .)
    (               reduce using rule 11 (stmt -> CONTINUE ; .)
    $end            reduce using rule 11 (stmt -> CONTINUE ; .)
    DEF             reduce using rule 11 (stmt -> CONTINUE ; .)
    }               reduce using rule 11 (stmt -> CONTINUE ; .)
    ELSE            reduce using rule 11 (stmt -> CONTINUE ; .)


state 72

    (12) stmt -> IF ( . expr ) jz block
    (13) stmt -> IF ( . expr ) jz block ELSE jmp jz_label block
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 107

state 73

    (20) stmt -> ID = . expr ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 108

state 74

    (21) stmt -> arr_id [ . expr ] = expr ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 109

state 75

    (23) stmt -> RETURN expr . ;
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               shift and go to state 110
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 76

    (24) stmt -> RETURN ; .

    PRINT           reduce using rule 24 (stmt -> RETURN ; .)
    PRINTLN         reduce using rule 24 (stmt -> RETURN ; .)
    WHILE           reduce using rule 24 (stmt -> RETURN ; .)
    BREAK           reduce using rule 24 (stmt -> RETURN ; .)
    CONTINUE        reduce using rule 24 (stmt -> RETURN ; .)
    IF              reduce using rule 24 (stmt -> RETURN ; .)
    ID              reduce using rule 24 (stmt -> RETURN ; .)
    RETURN          reduce using rule 24 (stmt -> RETURN ; .)
    PRINTI          reduce using rule 24 (stmt -> RETURN ; .)
    INPUT           reduce using rule 24 (stmt -> RETURN ; .)
    STR             reduce using rule 24 (stmt -> RETURN ; .)
    ATOI            reduce using rule 24 (stmt -> RETURN ; .)
    ALLOC           reduce using rule 24 (stmt -> RETURN ; .)
    !               reduce using rule 24 (stmt -> RETURN ; .)
    -               reduce using rule 24 (stmt -> RETURN ; .)
    STRING          reduce using rule 24 (stmt -> RETURN ; .)
    NUM             reduce using rule 24 (stmt -> RETURN ; .)
    TRUE            reduce using rule 24 (stmt -> RETURN ; .)
    FALSE           reduce using rule 24 (stmt -> RETURN ; .)
    (               reduce using rule 24 (stmt -> RETURN ; .)
    $end            reduce using rule 24 (stmt -> RETURN ; .)
    DEF             reduce using rule 24 (stmt -> RETURN ; .)
    }               reduce using rule 24 (stmt -> RETURN ; .)
    ELSE            reduce using rule 24 (stmt -> RETURN ; .)


state 77

    (25) stmt -> PRINTI ( . expr ) ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 111

state 78

    (4) fun -> DEF fun_name ( idlist . ) block
    (62) idlist -> idlist . , ID

    )               shift and go to state 112
    ,               shift and go to state 113


state 79

    (5) fun -> DEF fun_name ( ) . block
    (66) block -> . { stmtlist }
    (67) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . BREAK ;
    (11) stmt -> . CONTINUE ;
    (12) stmt -> . IF ( expr ) jz block
    (13) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . arr_id [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    {               shift and go to state 115
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    BREAK           shift and go to state 34
    CONTINUE        shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    block                          shift and go to state 114
    stmt                           shift and go to state 116
    expr                           shift and go to state 31
    arr_id                         shift and go to state 38

state 80

    (63) idlist -> ID .

    )               reduce using rule 63 (idlist -> ID .)
    ,               reduce using rule 63 (idlist -> ID .)


state 81

    (53) expr -> ID ( exprlist . )
    (64) exprlist -> exprlist . , expr

    )               shift and go to state 117
    ,               shift and go to state 118


state 82

    (54) expr -> ID ( ) .

    ;               reduce using rule 54 (expr -> ID ( ) .)
    +               reduce using rule 54 (expr -> ID ( ) .)
    -               reduce using rule 54 (expr -> ID ( ) .)
    *               reduce using rule 54 (expr -> ID ( ) .)
    /               reduce using rule 54 (expr -> ID ( ) .)
    %               reduce using rule 54 (expr -> ID ( ) .)
    OR              reduce using rule 54 (expr -> ID ( ) .)
    AND             reduce using rule 54 (expr -> ID ( ) .)
    >               reduce using rule 54 (expr -> ID ( ) .)
    <               reduce using rule 54 (expr -> ID ( ) .)
    GTE             reduce using rule 54 (expr -> ID ( ) .)
    LTE             reduce using rule 54 (expr -> ID ( ) .)
    EQ              reduce using rule 54 (expr -> ID ( ) .)
    NEQ             reduce using rule 54 (expr -> ID ( ) .)
    $               reduce using rule 54 (expr -> ID ( ) .)
    [               reduce using rule 54 (expr -> ID ( ) .)
    )               reduce using rule 54 (expr -> ID ( ) .)
    ,               reduce using rule 54 (expr -> ID ( ) .)
    ]               reduce using rule 54 (expr -> ID ( ) .)


state 83

    (65) exprlist -> expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    )               reduce using rule 65 (exprlist -> expr .)
    ,               reduce using rule 65 (exprlist -> expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 84

    (31) expr -> expr + expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 31 (expr -> expr + expr .)
    +               reduce using rule 31 (expr -> expr + expr .)
    -               reduce using rule 31 (expr -> expr + expr .)
    OR              reduce using rule 31 (expr -> expr + expr .)
    AND             reduce using rule 31 (expr -> expr + expr .)
    >               reduce using rule 31 (expr -> expr + expr .)
    <               reduce using rule 31 (expr -> expr + expr .)
    GTE             reduce using rule 31 (expr -> expr + expr .)
    LTE             reduce using rule 31 (expr -> expr + expr .)
    EQ              reduce using rule 31 (expr -> expr + expr .)
    NEQ             reduce using rule 31 (expr -> expr + expr .)
    $               reduce using rule 31 (expr -> expr + expr .)
    [               reduce using rule 31 (expr -> expr + expr .)
    )               reduce using rule 31 (expr -> expr + expr .)
    ,               reduce using rule 31 (expr -> expr + expr .)
    ]               reduce using rule 31 (expr -> expr + expr .)
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48

  ! *               [ reduce using rule 31 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 31 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 31 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]
  ! [               [ shift and go to state 58 ]


state 85

    (32) expr -> expr - expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 32 (expr -> expr - expr .)
    +               reduce using rule 32 (expr -> expr - expr .)
    -               reduce using rule 32 (expr -> expr - expr .)
    OR              reduce using rule 32 (expr -> expr - expr .)
    AND             reduce using rule 32 (expr -> expr - expr .)
    >               reduce using rule 32 (expr -> expr - expr .)
    <               reduce using rule 32 (expr -> expr - expr .)
    GTE             reduce using rule 32 (expr -> expr - expr .)
    LTE             reduce using rule 32 (expr -> expr - expr .)
    EQ              reduce using rule 32 (expr -> expr - expr .)
    NEQ             reduce using rule 32 (expr -> expr - expr .)
    $               reduce using rule 32 (expr -> expr - expr .)
    [               reduce using rule 32 (expr -> expr - expr .)
    )               reduce using rule 32 (expr -> expr - expr .)
    ,               reduce using rule 32 (expr -> expr - expr .)
    ]               reduce using rule 32 (expr -> expr - expr .)
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48

  ! *               [ reduce using rule 32 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 32 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 32 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]
  ! [               [ shift and go to state 58 ]


state 86

    (33) expr -> expr * expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 33 (expr -> expr * expr .)
    +               reduce using rule 33 (expr -> expr * expr .)
    -               reduce using rule 33 (expr -> expr * expr .)
    *               reduce using rule 33 (expr -> expr * expr .)
    /               reduce using rule 33 (expr -> expr * expr .)
    %               reduce using rule 33 (expr -> expr * expr .)
    OR              reduce using rule 33 (expr -> expr * expr .)
    AND             reduce using rule 33 (expr -> expr * expr .)
    >               reduce using rule 33 (expr -> expr * expr .)
    <               reduce using rule 33 (expr -> expr * expr .)
    GTE             reduce using rule 33 (expr -> expr * expr .)
    LTE             reduce using rule 33 (expr -> expr * expr .)
    EQ              reduce using rule 33 (expr -> expr * expr .)
    NEQ             reduce using rule 33 (expr -> expr * expr .)
    $               reduce using rule 33 (expr -> expr * expr .)
    [               reduce using rule 33 (expr -> expr * expr .)
    )               reduce using rule 33 (expr -> expr * expr .)
    ,               reduce using rule 33 (expr -> expr * expr .)
    ]               reduce using rule 33 (expr -> expr * expr .)

  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! /               [ shift and go to state 47 ]
  ! %               [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]
  ! [               [ shift and go to state 58 ]


state 87

    (34) expr -> expr / expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 34 (expr -> expr / expr .)
    +               reduce using rule 34 (expr -> expr / expr .)
    -               reduce using rule 34 (expr -> expr / expr .)
    *               reduce using rule 34 (expr -> expr / expr .)
    /               reduce using rule 34 (expr -> expr / expr .)
    %               reduce using rule 34 (expr -> expr / expr .)
    OR              reduce using rule 34 (expr -> expr / expr .)
    AND             reduce using rule 34 (expr -> expr / expr .)
    >               reduce using rule 34 (expr -> expr / expr .)
    <               reduce using rule 34 (expr -> expr / expr .)
    GTE             reduce using rule 34 (expr -> expr / expr .)
    LTE             reduce using rule 34 (expr -> expr / expr .)
    EQ              reduce using rule 34 (expr -> expr / expr .)
    NEQ             reduce using rule 34 (expr -> expr / expr .)
    $               reduce using rule 34 (expr -> expr / expr .)
    [               reduce using rule 34 (expr -> expr / expr .)
    )               reduce using rule 34 (expr -> expr / expr .)
    ,               reduce using rule 34 (expr -> expr / expr .)
    ]               reduce using rule 34 (expr -> expr / expr .)

  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! /               [ shift and go to state 47 ]
  ! %               [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]
  ! [               [ shift and go to state 58 ]


state 88

    (35) expr -> expr % expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 35 (expr -> expr % expr .)
    +               reduce using rule 35 (expr -> expr % expr .)
    -               reduce using rule 35 (expr -> expr % expr .)
    *               reduce using rule 35 (expr -> expr % expr .)
    /               reduce using rule 35 (expr -> expr % expr .)
    %               reduce using rule 35 (expr -> expr % expr .)
    OR              reduce using rule 35 (expr -> expr % expr .)
    AND             reduce using rule 35 (expr -> expr % expr .)
    >               reduce using rule 35 (expr -> expr % expr .)
    <               reduce using rule 35 (expr -> expr % expr .)
    GTE             reduce using rule 35 (expr -> expr % expr .)
    LTE             reduce using rule 35 (expr -> expr % expr .)
    EQ              reduce using rule 35 (expr -> expr % expr .)
    NEQ             reduce using rule 35 (expr -> expr % expr .)
    $               reduce using rule 35 (expr -> expr % expr .)
    [               reduce using rule 35 (expr -> expr % expr .)
    )               reduce using rule 35 (expr -> expr % expr .)
    ,               reduce using rule 35 (expr -> expr % expr .)
    ]               reduce using rule 35 (expr -> expr % expr .)

  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! /               [ shift and go to state 47 ]
  ! %               [ shift and go to state 48 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]
  ! [               [ shift and go to state 58 ]


state 89

    (36) expr -> expr OR expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 36 (expr -> expr OR expr .)
    OR              reduce using rule 36 (expr -> expr OR expr .)
    AND             reduce using rule 36 (expr -> expr OR expr .)
    EQ              reduce using rule 36 (expr -> expr OR expr .)
    NEQ             reduce using rule 36 (expr -> expr OR expr .)
    [               reduce using rule 36 (expr -> expr OR expr .)
    )               reduce using rule 36 (expr -> expr OR expr .)
    ,               reduce using rule 36 (expr -> expr OR expr .)
    ]               reduce using rule 36 (expr -> expr OR expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    $               shift and go to state 57

  ! +               [ reduce using rule 36 (expr -> expr OR expr .) ]
  ! -               [ reduce using rule 36 (expr -> expr OR expr .) ]
  ! *               [ reduce using rule 36 (expr -> expr OR expr .) ]
  ! /               [ reduce using rule 36 (expr -> expr OR expr .) ]
  ! %               [ reduce using rule 36 (expr -> expr OR expr .) ]
  ! >               [ reduce using rule 36 (expr -> expr OR expr .) ]
  ! <               [ reduce using rule 36 (expr -> expr OR expr .) ]
  ! GTE             [ reduce using rule 36 (expr -> expr OR expr .) ]
  ! LTE             [ reduce using rule 36 (expr -> expr OR expr .) ]
  ! $               [ reduce using rule 36 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! [               [ shift and go to state 58 ]


state 90

    (37) expr -> expr AND expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 37 (expr -> expr AND expr .)
    OR              reduce using rule 37 (expr -> expr AND expr .)
    AND             reduce using rule 37 (expr -> expr AND expr .)
    EQ              reduce using rule 37 (expr -> expr AND expr .)
    NEQ             reduce using rule 37 (expr -> expr AND expr .)
    [               reduce using rule 37 (expr -> expr AND expr .)
    )               reduce using rule 37 (expr -> expr AND expr .)
    ,               reduce using rule 37 (expr -> expr AND expr .)
    ]               reduce using rule 37 (expr -> expr AND expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    $               shift and go to state 57

  ! +               [ reduce using rule 37 (expr -> expr AND expr .) ]
  ! -               [ reduce using rule 37 (expr -> expr AND expr .) ]
  ! *               [ reduce using rule 37 (expr -> expr AND expr .) ]
  ! /               [ reduce using rule 37 (expr -> expr AND expr .) ]
  ! %               [ reduce using rule 37 (expr -> expr AND expr .) ]
  ! >               [ reduce using rule 37 (expr -> expr AND expr .) ]
  ! <               [ reduce using rule 37 (expr -> expr AND expr .) ]
  ! GTE             [ reduce using rule 37 (expr -> expr AND expr .) ]
  ! LTE             [ reduce using rule 37 (expr -> expr AND expr .) ]
  ! $               [ reduce using rule 37 (expr -> expr AND expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! [               [ shift and go to state 58 ]


state 91

    (38) expr -> expr > expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 38 (expr -> expr > expr .)
    OR              reduce using rule 38 (expr -> expr > expr .)
    AND             reduce using rule 38 (expr -> expr > expr .)
    >               reduce using rule 38 (expr -> expr > expr .)
    <               reduce using rule 38 (expr -> expr > expr .)
    GTE             reduce using rule 38 (expr -> expr > expr .)
    LTE             reduce using rule 38 (expr -> expr > expr .)
    EQ              reduce using rule 38 (expr -> expr > expr .)
    NEQ             reduce using rule 38 (expr -> expr > expr .)
    [               reduce using rule 38 (expr -> expr > expr .)
    )               reduce using rule 38 (expr -> expr > expr .)
    ,               reduce using rule 38 (expr -> expr > expr .)
    ]               reduce using rule 38 (expr -> expr > expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    $               shift and go to state 57

  ! +               [ reduce using rule 38 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr > expr .) ]
  ! %               [ reduce using rule 38 (expr -> expr > expr .) ]
  ! $               [ reduce using rule 38 (expr -> expr > expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! [               [ shift and go to state 58 ]


state 92

    (39) expr -> expr < expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 39 (expr -> expr < expr .)
    OR              reduce using rule 39 (expr -> expr < expr .)
    AND             reduce using rule 39 (expr -> expr < expr .)
    >               reduce using rule 39 (expr -> expr < expr .)
    <               reduce using rule 39 (expr -> expr < expr .)
    GTE             reduce using rule 39 (expr -> expr < expr .)
    LTE             reduce using rule 39 (expr -> expr < expr .)
    EQ              reduce using rule 39 (expr -> expr < expr .)
    NEQ             reduce using rule 39 (expr -> expr < expr .)
    [               reduce using rule 39 (expr -> expr < expr .)
    )               reduce using rule 39 (expr -> expr < expr .)
    ,               reduce using rule 39 (expr -> expr < expr .)
    ]               reduce using rule 39 (expr -> expr < expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    $               shift and go to state 57

  ! +               [ reduce using rule 39 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr < expr .) ]
  ! %               [ reduce using rule 39 (expr -> expr < expr .) ]
  ! $               [ reduce using rule 39 (expr -> expr < expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! [               [ shift and go to state 58 ]


state 93

    (40) expr -> expr GTE expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 40 (expr -> expr GTE expr .)
    OR              reduce using rule 40 (expr -> expr GTE expr .)
    AND             reduce using rule 40 (expr -> expr GTE expr .)
    >               reduce using rule 40 (expr -> expr GTE expr .)
    <               reduce using rule 40 (expr -> expr GTE expr .)
    GTE             reduce using rule 40 (expr -> expr GTE expr .)
    LTE             reduce using rule 40 (expr -> expr GTE expr .)
    EQ              reduce using rule 40 (expr -> expr GTE expr .)
    NEQ             reduce using rule 40 (expr -> expr GTE expr .)
    [               reduce using rule 40 (expr -> expr GTE expr .)
    )               reduce using rule 40 (expr -> expr GTE expr .)
    ,               reduce using rule 40 (expr -> expr GTE expr .)
    ]               reduce using rule 40 (expr -> expr GTE expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    $               shift and go to state 57

  ! +               [ reduce using rule 40 (expr -> expr GTE expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr GTE expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr GTE expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr GTE expr .) ]
  ! %               [ reduce using rule 40 (expr -> expr GTE expr .) ]
  ! $               [ reduce using rule 40 (expr -> expr GTE expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! [               [ shift and go to state 58 ]


state 94

    (41) expr -> expr LTE expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 41 (expr -> expr LTE expr .)
    OR              reduce using rule 41 (expr -> expr LTE expr .)
    AND             reduce using rule 41 (expr -> expr LTE expr .)
    >               reduce using rule 41 (expr -> expr LTE expr .)
    <               reduce using rule 41 (expr -> expr LTE expr .)
    GTE             reduce using rule 41 (expr -> expr LTE expr .)
    LTE             reduce using rule 41 (expr -> expr LTE expr .)
    EQ              reduce using rule 41 (expr -> expr LTE expr .)
    NEQ             reduce using rule 41 (expr -> expr LTE expr .)
    [               reduce using rule 41 (expr -> expr LTE expr .)
    )               reduce using rule 41 (expr -> expr LTE expr .)
    ,               reduce using rule 41 (expr -> expr LTE expr .)
    ]               reduce using rule 41 (expr -> expr LTE expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    $               shift and go to state 57

  ! +               [ reduce using rule 41 (expr -> expr LTE expr .) ]
  ! -               [ reduce using rule 41 (expr -> expr LTE expr .) ]
  ! *               [ reduce using rule 41 (expr -> expr LTE expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr LTE expr .) ]
  ! %               [ reduce using rule 41 (expr -> expr LTE expr .) ]
  ! $               [ reduce using rule 41 (expr -> expr LTE expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! [               [ shift and go to state 58 ]


state 95

    (42) expr -> expr EQ expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 42 (expr -> expr EQ expr .)
    OR              reduce using rule 42 (expr -> expr EQ expr .)
    AND             reduce using rule 42 (expr -> expr EQ expr .)
    EQ              reduce using rule 42 (expr -> expr EQ expr .)
    NEQ             reduce using rule 42 (expr -> expr EQ expr .)
    [               reduce using rule 42 (expr -> expr EQ expr .)
    )               reduce using rule 42 (expr -> expr EQ expr .)
    ,               reduce using rule 42 (expr -> expr EQ expr .)
    ]               reduce using rule 42 (expr -> expr EQ expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    $               shift and go to state 57

  ! +               [ reduce using rule 42 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 42 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 42 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 42 (expr -> expr EQ expr .) ]
  ! %               [ reduce using rule 42 (expr -> expr EQ expr .) ]
  ! >               [ reduce using rule 42 (expr -> expr EQ expr .) ]
  ! <               [ reduce using rule 42 (expr -> expr EQ expr .) ]
  ! GTE             [ reduce using rule 42 (expr -> expr EQ expr .) ]
  ! LTE             [ reduce using rule 42 (expr -> expr EQ expr .) ]
  ! $               [ reduce using rule 42 (expr -> expr EQ expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! [               [ shift and go to state 58 ]


state 96

    (43) expr -> expr NEQ expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 43 (expr -> expr NEQ expr .)
    OR              reduce using rule 43 (expr -> expr NEQ expr .)
    AND             reduce using rule 43 (expr -> expr NEQ expr .)
    EQ              reduce using rule 43 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 43 (expr -> expr NEQ expr .)
    [               reduce using rule 43 (expr -> expr NEQ expr .)
    )               reduce using rule 43 (expr -> expr NEQ expr .)
    ,               reduce using rule 43 (expr -> expr NEQ expr .)
    ]               reduce using rule 43 (expr -> expr NEQ expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    $               shift and go to state 57

  ! +               [ reduce using rule 43 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 43 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 43 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 43 (expr -> expr NEQ expr .) ]
  ! %               [ reduce using rule 43 (expr -> expr NEQ expr .) ]
  ! >               [ reduce using rule 43 (expr -> expr NEQ expr .) ]
  ! <               [ reduce using rule 43 (expr -> expr NEQ expr .) ]
  ! GTE             [ reduce using rule 43 (expr -> expr NEQ expr .) ]
  ! LTE             [ reduce using rule 43 (expr -> expr NEQ expr .) ]
  ! $               [ reduce using rule 43 (expr -> expr NEQ expr .) ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! [               [ shift and go to state 58 ]


state 97

    (44) expr -> expr $ expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               reduce using rule 44 (expr -> expr $ expr .)
    +               reduce using rule 44 (expr -> expr $ expr .)
    -               reduce using rule 44 (expr -> expr $ expr .)
    OR              reduce using rule 44 (expr -> expr $ expr .)
    AND             reduce using rule 44 (expr -> expr $ expr .)
    >               reduce using rule 44 (expr -> expr $ expr .)
    <               reduce using rule 44 (expr -> expr $ expr .)
    GTE             reduce using rule 44 (expr -> expr $ expr .)
    LTE             reduce using rule 44 (expr -> expr $ expr .)
    EQ              reduce using rule 44 (expr -> expr $ expr .)
    NEQ             reduce using rule 44 (expr -> expr $ expr .)
    $               reduce using rule 44 (expr -> expr $ expr .)
    [               reduce using rule 44 (expr -> expr $ expr .)
    )               reduce using rule 44 (expr -> expr $ expr .)
    ,               reduce using rule 44 (expr -> expr $ expr .)
    ]               reduce using rule 44 (expr -> expr $ expr .)
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48

  ! *               [ reduce using rule 44 (expr -> expr $ expr .) ]
  ! /               [ reduce using rule 44 (expr -> expr $ expr .) ]
  ! %               [ reduce using rule 44 (expr -> expr $ expr .) ]
  ! +               [ shift and go to state 44 ]
  ! -               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 50 ]
  ! >               [ shift and go to state 51 ]
  ! <               [ shift and go to state 52 ]
  ! GTE             [ shift and go to state 53 ]
  ! LTE             [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! $               [ shift and go to state 57 ]
  ! [               [ shift and go to state 58 ]


state 98

    (48) expr -> expr [ expr . ]
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ]               shift and go to state 119
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 99

    (27) expr -> INPUT ( ) .

    ;               reduce using rule 27 (expr -> INPUT ( ) .)
    +               reduce using rule 27 (expr -> INPUT ( ) .)
    -               reduce using rule 27 (expr -> INPUT ( ) .)
    *               reduce using rule 27 (expr -> INPUT ( ) .)
    /               reduce using rule 27 (expr -> INPUT ( ) .)
    %               reduce using rule 27 (expr -> INPUT ( ) .)
    OR              reduce using rule 27 (expr -> INPUT ( ) .)
    AND             reduce using rule 27 (expr -> INPUT ( ) .)
    >               reduce using rule 27 (expr -> INPUT ( ) .)
    <               reduce using rule 27 (expr -> INPUT ( ) .)
    GTE             reduce using rule 27 (expr -> INPUT ( ) .)
    LTE             reduce using rule 27 (expr -> INPUT ( ) .)
    EQ              reduce using rule 27 (expr -> INPUT ( ) .)
    NEQ             reduce using rule 27 (expr -> INPUT ( ) .)
    $               reduce using rule 27 (expr -> INPUT ( ) .)
    [               reduce using rule 27 (expr -> INPUT ( ) .)
    )               reduce using rule 27 (expr -> INPUT ( ) .)
    ,               reduce using rule 27 (expr -> INPUT ( ) .)
    ]               reduce using rule 27 (expr -> INPUT ( ) .)


state 100

    (55) expr -> ( expr ) .

    ;               reduce using rule 55 (expr -> ( expr ) .)
    +               reduce using rule 55 (expr -> ( expr ) .)
    -               reduce using rule 55 (expr -> ( expr ) .)
    *               reduce using rule 55 (expr -> ( expr ) .)
    /               reduce using rule 55 (expr -> ( expr ) .)
    %               reduce using rule 55 (expr -> ( expr ) .)
    OR              reduce using rule 55 (expr -> ( expr ) .)
    AND             reduce using rule 55 (expr -> ( expr ) .)
    >               reduce using rule 55 (expr -> ( expr ) .)
    <               reduce using rule 55 (expr -> ( expr ) .)
    GTE             reduce using rule 55 (expr -> ( expr ) .)
    LTE             reduce using rule 55 (expr -> ( expr ) .)
    EQ              reduce using rule 55 (expr -> ( expr ) .)
    NEQ             reduce using rule 55 (expr -> ( expr ) .)
    $               reduce using rule 55 (expr -> ( expr ) .)
    [               reduce using rule 55 (expr -> ( expr ) .)
    )               reduce using rule 55 (expr -> ( expr ) .)
    ,               reduce using rule 55 (expr -> ( expr ) .)
    ]               reduce using rule 55 (expr -> ( expr ) .)


state 101

    (28) expr -> STR ( expr . )
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    )               shift and go to state 120
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 102

    (29) expr -> ATOI ( expr . )
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    )               shift and go to state 121
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 103

    (30) expr -> ALLOC ( expr . )
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    )               shift and go to state 122
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 104

    (7) stmt -> PRINT ( expr . ) ;
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    )               shift and go to state 123
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 105

    (8) stmt -> PRINTLN ( ) . ;

    ;               shift and go to state 124


state 106

    (9) stmt -> WHILE new_label ( . expr ) jz block
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 125

state 107

    (12) stmt -> IF ( expr . ) jz block
    (13) stmt -> IF ( expr . ) jz block ELSE jmp jz_label block
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    )               shift and go to state 126
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 108

    (20) stmt -> ID = expr . ;
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               shift and go to state 127
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 109

    (21) stmt -> arr_id [ expr . ] = expr ;
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ]               shift and go to state 128
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 110

    (23) stmt -> RETURN expr ; .

    PRINT           reduce using rule 23 (stmt -> RETURN expr ; .)
    PRINTLN         reduce using rule 23 (stmt -> RETURN expr ; .)
    WHILE           reduce using rule 23 (stmt -> RETURN expr ; .)
    BREAK           reduce using rule 23 (stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 23 (stmt -> RETURN expr ; .)
    IF              reduce using rule 23 (stmt -> RETURN expr ; .)
    ID              reduce using rule 23 (stmt -> RETURN expr ; .)
    RETURN          reduce using rule 23 (stmt -> RETURN expr ; .)
    PRINTI          reduce using rule 23 (stmt -> RETURN expr ; .)
    INPUT           reduce using rule 23 (stmt -> RETURN expr ; .)
    STR             reduce using rule 23 (stmt -> RETURN expr ; .)
    ATOI            reduce using rule 23 (stmt -> RETURN expr ; .)
    ALLOC           reduce using rule 23 (stmt -> RETURN expr ; .)
    !               reduce using rule 23 (stmt -> RETURN expr ; .)
    -               reduce using rule 23 (stmt -> RETURN expr ; .)
    STRING          reduce using rule 23 (stmt -> RETURN expr ; .)
    NUM             reduce using rule 23 (stmt -> RETURN expr ; .)
    TRUE            reduce using rule 23 (stmt -> RETURN expr ; .)
    FALSE           reduce using rule 23 (stmt -> RETURN expr ; .)
    (               reduce using rule 23 (stmt -> RETURN expr ; .)
    $end            reduce using rule 23 (stmt -> RETURN expr ; .)
    DEF             reduce using rule 23 (stmt -> RETURN expr ; .)
    }               reduce using rule 23 (stmt -> RETURN expr ; .)
    ELSE            reduce using rule 23 (stmt -> RETURN expr ; .)


state 111

    (25) stmt -> PRINTI ( expr . ) ;
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    )               shift and go to state 129
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 112

    (4) fun -> DEF fun_name ( idlist ) . block
    (66) block -> . { stmtlist }
    (67) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . BREAK ;
    (11) stmt -> . CONTINUE ;
    (12) stmt -> . IF ( expr ) jz block
    (13) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . arr_id [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    {               shift and go to state 115
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    BREAK           shift and go to state 34
    CONTINUE        shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    block                          shift and go to state 130
    stmt                           shift and go to state 116
    expr                           shift and go to state 31
    arr_id                         shift and go to state 38

state 113

    (62) idlist -> idlist , . ID

    ID              shift and go to state 131


state 114

    (5) fun -> DEF fun_name ( ) block .

    DEF             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINT           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINTLN         reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    WHILE           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    BREAK           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    CONTINUE        reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    IF              reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    ID              reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    RETURN          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINTI          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    INPUT           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    STR             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    ATOI            reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    ALLOC           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    !               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    -               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    STRING          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    NUM             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    TRUE            reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    FALSE           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    (               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    $end            reduce using rule 5 (fun -> DEF fun_name ( ) block .)


state 115

    (66) block -> { . stmtlist }
    (60) stmtlist -> . stmtlist stmt
    (61) stmtlist -> .

    }               reduce using rule 61 (stmtlist -> .)
    PRINT           reduce using rule 61 (stmtlist -> .)
    PRINTLN         reduce using rule 61 (stmtlist -> .)
    WHILE           reduce using rule 61 (stmtlist -> .)
    BREAK           reduce using rule 61 (stmtlist -> .)
    CONTINUE        reduce using rule 61 (stmtlist -> .)
    IF              reduce using rule 61 (stmtlist -> .)
    ID              reduce using rule 61 (stmtlist -> .)
    RETURN          reduce using rule 61 (stmtlist -> .)
    PRINTI          reduce using rule 61 (stmtlist -> .)
    INPUT           reduce using rule 61 (stmtlist -> .)
    STR             reduce using rule 61 (stmtlist -> .)
    ATOI            reduce using rule 61 (stmtlist -> .)
    ALLOC           reduce using rule 61 (stmtlist -> .)
    !               reduce using rule 61 (stmtlist -> .)
    -               reduce using rule 61 (stmtlist -> .)
    STRING          reduce using rule 61 (stmtlist -> .)
    NUM             reduce using rule 61 (stmtlist -> .)
    TRUE            reduce using rule 61 (stmtlist -> .)
    FALSE           reduce using rule 61 (stmtlist -> .)
    (               reduce using rule 61 (stmtlist -> .)

    stmtlist                       shift and go to state 132

state 116

    (67) block -> stmt .

    DEF             reduce using rule 67 (block -> stmt .)
    PRINT           reduce using rule 67 (block -> stmt .)
    PRINTLN         reduce using rule 67 (block -> stmt .)
    WHILE           reduce using rule 67 (block -> stmt .)
    BREAK           reduce using rule 67 (block -> stmt .)
    CONTINUE        reduce using rule 67 (block -> stmt .)
    IF              reduce using rule 67 (block -> stmt .)
    ID              reduce using rule 67 (block -> stmt .)
    RETURN          reduce using rule 67 (block -> stmt .)
    PRINTI          reduce using rule 67 (block -> stmt .)
    INPUT           reduce using rule 67 (block -> stmt .)
    STR             reduce using rule 67 (block -> stmt .)
    ATOI            reduce using rule 67 (block -> stmt .)
    ALLOC           reduce using rule 67 (block -> stmt .)
    !               reduce using rule 67 (block -> stmt .)
    -               reduce using rule 67 (block -> stmt .)
    STRING          reduce using rule 67 (block -> stmt .)
    NUM             reduce using rule 67 (block -> stmt .)
    TRUE            reduce using rule 67 (block -> stmt .)
    FALSE           reduce using rule 67 (block -> stmt .)
    (               reduce using rule 67 (block -> stmt .)
    $end            reduce using rule 67 (block -> stmt .)
    ELSE            reduce using rule 67 (block -> stmt .)
    }               reduce using rule 67 (block -> stmt .)


state 117

    (53) expr -> ID ( exprlist ) .

    ;               reduce using rule 53 (expr -> ID ( exprlist ) .)
    +               reduce using rule 53 (expr -> ID ( exprlist ) .)
    -               reduce using rule 53 (expr -> ID ( exprlist ) .)
    *               reduce using rule 53 (expr -> ID ( exprlist ) .)
    /               reduce using rule 53 (expr -> ID ( exprlist ) .)
    %               reduce using rule 53 (expr -> ID ( exprlist ) .)
    OR              reduce using rule 53 (expr -> ID ( exprlist ) .)
    AND             reduce using rule 53 (expr -> ID ( exprlist ) .)
    >               reduce using rule 53 (expr -> ID ( exprlist ) .)
    <               reduce using rule 53 (expr -> ID ( exprlist ) .)
    GTE             reduce using rule 53 (expr -> ID ( exprlist ) .)
    LTE             reduce using rule 53 (expr -> ID ( exprlist ) .)
    EQ              reduce using rule 53 (expr -> ID ( exprlist ) .)
    NEQ             reduce using rule 53 (expr -> ID ( exprlist ) .)
    $               reduce using rule 53 (expr -> ID ( exprlist ) .)
    [               reduce using rule 53 (expr -> ID ( exprlist ) .)
    )               reduce using rule 53 (expr -> ID ( exprlist ) .)
    ,               reduce using rule 53 (expr -> ID ( exprlist ) .)
    ]               reduce using rule 53 (expr -> ID ( exprlist ) .)


state 118

    (64) exprlist -> exprlist , . expr
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 133

state 119

    (48) expr -> expr [ expr ] .

    ;               reduce using rule 48 (expr -> expr [ expr ] .)
    +               reduce using rule 48 (expr -> expr [ expr ] .)
    -               reduce using rule 48 (expr -> expr [ expr ] .)
    *               reduce using rule 48 (expr -> expr [ expr ] .)
    /               reduce using rule 48 (expr -> expr [ expr ] .)
    %               reduce using rule 48 (expr -> expr [ expr ] .)
    OR              reduce using rule 48 (expr -> expr [ expr ] .)
    AND             reduce using rule 48 (expr -> expr [ expr ] .)
    >               reduce using rule 48 (expr -> expr [ expr ] .)
    <               reduce using rule 48 (expr -> expr [ expr ] .)
    GTE             reduce using rule 48 (expr -> expr [ expr ] .)
    LTE             reduce using rule 48 (expr -> expr [ expr ] .)
    EQ              reduce using rule 48 (expr -> expr [ expr ] .)
    NEQ             reduce using rule 48 (expr -> expr [ expr ] .)
    $               reduce using rule 48 (expr -> expr [ expr ] .)
    [               reduce using rule 48 (expr -> expr [ expr ] .)
    )               reduce using rule 48 (expr -> expr [ expr ] .)
    ,               reduce using rule 48 (expr -> expr [ expr ] .)
    ]               reduce using rule 48 (expr -> expr [ expr ] .)


state 120

    (28) expr -> STR ( expr ) .

    ;               reduce using rule 28 (expr -> STR ( expr ) .)
    +               reduce using rule 28 (expr -> STR ( expr ) .)
    -               reduce using rule 28 (expr -> STR ( expr ) .)
    *               reduce using rule 28 (expr -> STR ( expr ) .)
    /               reduce using rule 28 (expr -> STR ( expr ) .)
    %               reduce using rule 28 (expr -> STR ( expr ) .)
    OR              reduce using rule 28 (expr -> STR ( expr ) .)
    AND             reduce using rule 28 (expr -> STR ( expr ) .)
    >               reduce using rule 28 (expr -> STR ( expr ) .)
    <               reduce using rule 28 (expr -> STR ( expr ) .)
    GTE             reduce using rule 28 (expr -> STR ( expr ) .)
    LTE             reduce using rule 28 (expr -> STR ( expr ) .)
    EQ              reduce using rule 28 (expr -> STR ( expr ) .)
    NEQ             reduce using rule 28 (expr -> STR ( expr ) .)
    $               reduce using rule 28 (expr -> STR ( expr ) .)
    [               reduce using rule 28 (expr -> STR ( expr ) .)
    )               reduce using rule 28 (expr -> STR ( expr ) .)
    ,               reduce using rule 28 (expr -> STR ( expr ) .)
    ]               reduce using rule 28 (expr -> STR ( expr ) .)


state 121

    (29) expr -> ATOI ( expr ) .

    ;               reduce using rule 29 (expr -> ATOI ( expr ) .)
    +               reduce using rule 29 (expr -> ATOI ( expr ) .)
    -               reduce using rule 29 (expr -> ATOI ( expr ) .)
    *               reduce using rule 29 (expr -> ATOI ( expr ) .)
    /               reduce using rule 29 (expr -> ATOI ( expr ) .)
    %               reduce using rule 29 (expr -> ATOI ( expr ) .)
    OR              reduce using rule 29 (expr -> ATOI ( expr ) .)
    AND             reduce using rule 29 (expr -> ATOI ( expr ) .)
    >               reduce using rule 29 (expr -> ATOI ( expr ) .)
    <               reduce using rule 29 (expr -> ATOI ( expr ) .)
    GTE             reduce using rule 29 (expr -> ATOI ( expr ) .)
    LTE             reduce using rule 29 (expr -> ATOI ( expr ) .)
    EQ              reduce using rule 29 (expr -> ATOI ( expr ) .)
    NEQ             reduce using rule 29 (expr -> ATOI ( expr ) .)
    $               reduce using rule 29 (expr -> ATOI ( expr ) .)
    [               reduce using rule 29 (expr -> ATOI ( expr ) .)
    )               reduce using rule 29 (expr -> ATOI ( expr ) .)
    ,               reduce using rule 29 (expr -> ATOI ( expr ) .)
    ]               reduce using rule 29 (expr -> ATOI ( expr ) .)


state 122

    (30) expr -> ALLOC ( expr ) .

    ;               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    +               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    -               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    *               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    /               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    %               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    OR              reduce using rule 30 (expr -> ALLOC ( expr ) .)
    AND             reduce using rule 30 (expr -> ALLOC ( expr ) .)
    >               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    <               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    GTE             reduce using rule 30 (expr -> ALLOC ( expr ) .)
    LTE             reduce using rule 30 (expr -> ALLOC ( expr ) .)
    EQ              reduce using rule 30 (expr -> ALLOC ( expr ) .)
    NEQ             reduce using rule 30 (expr -> ALLOC ( expr ) .)
    $               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    [               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    )               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    ,               reduce using rule 30 (expr -> ALLOC ( expr ) .)
    ]               reduce using rule 30 (expr -> ALLOC ( expr ) .)


state 123

    (7) stmt -> PRINT ( expr ) . ;

    ;               shift and go to state 134


state 124

    (8) stmt -> PRINTLN ( ) ; .

    PRINT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    PRINTLN         reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    WHILE           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    BREAK           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    CONTINUE        reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    IF              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ID              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    RETURN          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    PRINTI          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    INPUT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STR             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ATOI            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ALLOC           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    !               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    -               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STRING          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    NUM             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    TRUE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    FALSE           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    (               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    $end            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    DEF             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    }               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ELSE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)


state 125

    (9) stmt -> WHILE new_label ( expr . ) jz block
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    )               shift and go to state 135
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 126

    (12) stmt -> IF ( expr ) . jz block
    (13) stmt -> IF ( expr ) . jz block ELSE jmp jz_label block
    (15) jz -> .

    {               reduce using rule 15 (jz -> .)
    PRINT           reduce using rule 15 (jz -> .)
    PRINTLN         reduce using rule 15 (jz -> .)
    WHILE           reduce using rule 15 (jz -> .)
    BREAK           reduce using rule 15 (jz -> .)
    CONTINUE        reduce using rule 15 (jz -> .)
    IF              reduce using rule 15 (jz -> .)
    ID              reduce using rule 15 (jz -> .)
    RETURN          reduce using rule 15 (jz -> .)
    PRINTI          reduce using rule 15 (jz -> .)
    INPUT           reduce using rule 15 (jz -> .)
    STR             reduce using rule 15 (jz -> .)
    ATOI            reduce using rule 15 (jz -> .)
    ALLOC           reduce using rule 15 (jz -> .)
    !               reduce using rule 15 (jz -> .)
    -               reduce using rule 15 (jz -> .)
    STRING          reduce using rule 15 (jz -> .)
    NUM             reduce using rule 15 (jz -> .)
    TRUE            reduce using rule 15 (jz -> .)
    FALSE           reduce using rule 15 (jz -> .)
    (               reduce using rule 15 (jz -> .)

    jz                             shift and go to state 136

state 127

    (20) stmt -> ID = expr ; .

    PRINT           reduce using rule 20 (stmt -> ID = expr ; .)
    PRINTLN         reduce using rule 20 (stmt -> ID = expr ; .)
    WHILE           reduce using rule 20 (stmt -> ID = expr ; .)
    BREAK           reduce using rule 20 (stmt -> ID = expr ; .)
    CONTINUE        reduce using rule 20 (stmt -> ID = expr ; .)
    IF              reduce using rule 20 (stmt -> ID = expr ; .)
    ID              reduce using rule 20 (stmt -> ID = expr ; .)
    RETURN          reduce using rule 20 (stmt -> ID = expr ; .)
    PRINTI          reduce using rule 20 (stmt -> ID = expr ; .)
    INPUT           reduce using rule 20 (stmt -> ID = expr ; .)
    STR             reduce using rule 20 (stmt -> ID = expr ; .)
    ATOI            reduce using rule 20 (stmt -> ID = expr ; .)
    ALLOC           reduce using rule 20 (stmt -> ID = expr ; .)
    !               reduce using rule 20 (stmt -> ID = expr ; .)
    -               reduce using rule 20 (stmt -> ID = expr ; .)
    STRING          reduce using rule 20 (stmt -> ID = expr ; .)
    NUM             reduce using rule 20 (stmt -> ID = expr ; .)
    TRUE            reduce using rule 20 (stmt -> ID = expr ; .)
    FALSE           reduce using rule 20 (stmt -> ID = expr ; .)
    (               reduce using rule 20 (stmt -> ID = expr ; .)
    $end            reduce using rule 20 (stmt -> ID = expr ; .)
    DEF             reduce using rule 20 (stmt -> ID = expr ; .)
    }               reduce using rule 20 (stmt -> ID = expr ; .)
    ELSE            reduce using rule 20 (stmt -> ID = expr ; .)


state 128

    (21) stmt -> arr_id [ expr ] . = expr ;

    =               shift and go to state 137


state 129

    (25) stmt -> PRINTI ( expr ) . ;

    ;               shift and go to state 138


state 130

    (4) fun -> DEF fun_name ( idlist ) block .

    DEF             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINT           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINTLN         reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    WHILE           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    BREAK           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    CONTINUE        reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    IF              reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    ID              reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    RETURN          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINTI          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    INPUT           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    STR             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    ATOI            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    ALLOC           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    !               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    -               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    STRING          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    NUM             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    TRUE            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    FALSE           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    (               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    $end            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)


state 131

    (62) idlist -> idlist , ID .

    )               reduce using rule 62 (idlist -> idlist , ID .)
    ,               reduce using rule 62 (idlist -> idlist , ID .)


state 132

    (66) block -> { stmtlist . }
    (60) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . BREAK ;
    (11) stmt -> . CONTINUE ;
    (12) stmt -> . IF ( expr ) jz block
    (13) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . arr_id [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    }               shift and go to state 139
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    BREAK           shift and go to state 34
    CONTINUE        shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    stmt                           shift and go to state 29
    expr                           shift and go to state 31
    arr_id                         shift and go to state 38

state 133

    (64) exprlist -> exprlist , expr .
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    )               reduce using rule 64 (exprlist -> exprlist , expr .)
    ,               reduce using rule 64 (exprlist -> exprlist , expr .)
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 134

    (7) stmt -> PRINT ( expr ) ; .

    PRINT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    PRINTLN         reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    WHILE           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    BREAK           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    CONTINUE        reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    IF              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ID              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    RETURN          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    PRINTI          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    INPUT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STR             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ATOI            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ALLOC           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    !               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    -               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STRING          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    NUM             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    TRUE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    FALSE           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    (               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    $end            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    DEF             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    }               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ELSE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)


state 135

    (9) stmt -> WHILE new_label ( expr ) . jz block
    (15) jz -> .

    {               reduce using rule 15 (jz -> .)
    PRINT           reduce using rule 15 (jz -> .)
    PRINTLN         reduce using rule 15 (jz -> .)
    WHILE           reduce using rule 15 (jz -> .)
    BREAK           reduce using rule 15 (jz -> .)
    CONTINUE        reduce using rule 15 (jz -> .)
    IF              reduce using rule 15 (jz -> .)
    ID              reduce using rule 15 (jz -> .)
    RETURN          reduce using rule 15 (jz -> .)
    PRINTI          reduce using rule 15 (jz -> .)
    INPUT           reduce using rule 15 (jz -> .)
    STR             reduce using rule 15 (jz -> .)
    ATOI            reduce using rule 15 (jz -> .)
    ALLOC           reduce using rule 15 (jz -> .)
    !               reduce using rule 15 (jz -> .)
    -               reduce using rule 15 (jz -> .)
    STRING          reduce using rule 15 (jz -> .)
    NUM             reduce using rule 15 (jz -> .)
    TRUE            reduce using rule 15 (jz -> .)
    FALSE           reduce using rule 15 (jz -> .)
    (               reduce using rule 15 (jz -> .)

    jz                             shift and go to state 140

state 136

    (12) stmt -> IF ( expr ) jz . block
    (13) stmt -> IF ( expr ) jz . block ELSE jmp jz_label block
    (66) block -> . { stmtlist }
    (67) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . BREAK ;
    (11) stmt -> . CONTINUE ;
    (12) stmt -> . IF ( expr ) jz block
    (13) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . arr_id [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    {               shift and go to state 115
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    BREAK           shift and go to state 34
    CONTINUE        shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 31
    block                          shift and go to state 141
    stmt                           shift and go to state 116
    arr_id                         shift and go to state 38

state 137

    (21) stmt -> arr_id [ expr ] = . expr ;
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 16
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 142

state 138

    (25) stmt -> PRINTI ( expr ) ; .

    PRINT           reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    PRINTLN         reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    WHILE           reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    BREAK           reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    CONTINUE        reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    IF              reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    ID              reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    RETURN          reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    PRINTI          reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    INPUT           reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    STR             reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    ATOI            reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    ALLOC           reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    !               reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    -               reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    STRING          reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    NUM             reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    TRUE            reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    FALSE           reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    (               reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    $end            reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    DEF             reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    }               reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)
    ELSE            reduce using rule 25 (stmt -> PRINTI ( expr ) ; .)


state 139

    (66) block -> { stmtlist } .

    DEF             reduce using rule 66 (block -> { stmtlist } .)
    PRINT           reduce using rule 66 (block -> { stmtlist } .)
    PRINTLN         reduce using rule 66 (block -> { stmtlist } .)
    WHILE           reduce using rule 66 (block -> { stmtlist } .)
    BREAK           reduce using rule 66 (block -> { stmtlist } .)
    CONTINUE        reduce using rule 66 (block -> { stmtlist } .)
    IF              reduce using rule 66 (block -> { stmtlist } .)
    ID              reduce using rule 66 (block -> { stmtlist } .)
    RETURN          reduce using rule 66 (block -> { stmtlist } .)
    PRINTI          reduce using rule 66 (block -> { stmtlist } .)
    INPUT           reduce using rule 66 (block -> { stmtlist } .)
    STR             reduce using rule 66 (block -> { stmtlist } .)
    ATOI            reduce using rule 66 (block -> { stmtlist } .)
    ALLOC           reduce using rule 66 (block -> { stmtlist } .)
    !               reduce using rule 66 (block -> { stmtlist } .)
    -               reduce using rule 66 (block -> { stmtlist } .)
    STRING          reduce using rule 66 (block -> { stmtlist } .)
    NUM             reduce using rule 66 (block -> { stmtlist } .)
    TRUE            reduce using rule 66 (block -> { stmtlist } .)
    FALSE           reduce using rule 66 (block -> { stmtlist } .)
    (               reduce using rule 66 (block -> { stmtlist } .)
    $end            reduce using rule 66 (block -> { stmtlist } .)
    ELSE            reduce using rule 66 (block -> { stmtlist } .)
    }               reduce using rule 66 (block -> { stmtlist } .)


state 140

    (9) stmt -> WHILE new_label ( expr ) jz . block
    (66) block -> . { stmtlist }
    (67) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . BREAK ;
    (11) stmt -> . CONTINUE ;
    (12) stmt -> . IF ( expr ) jz block
    (13) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . arr_id [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    {               shift and go to state 115
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    BREAK           shift and go to state 34
    CONTINUE        shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 31
    block                          shift and go to state 143
    stmt                           shift and go to state 116
    arr_id                         shift and go to state 38

state 141

    (12) stmt -> IF ( expr ) jz block .
    (13) stmt -> IF ( expr ) jz block . ELSE jmp jz_label block

  ! shift/reduce conflict for ELSE resolved as shift
    PRINT           reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    PRINTLN         reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    WHILE           reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    BREAK           reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    CONTINUE        reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    IF              reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    ID              reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    RETURN          reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    PRINTI          reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    INPUT           reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    STR             reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    ATOI            reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    ALLOC           reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    !               reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    -               reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    STRING          reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    NUM             reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    TRUE            reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    FALSE           reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    (               reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    $end            reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    DEF             reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    }               reduce using rule 12 (stmt -> IF ( expr ) jz block .)
    ELSE            shift and go to state 144

  ! ELSE            [ reduce using rule 12 (stmt -> IF ( expr ) jz block .) ]


state 142

    (21) stmt -> arr_id [ expr ] = expr . ;
    (31) expr -> expr . + expr
    (32) expr -> expr . - expr
    (33) expr -> expr . * expr
    (34) expr -> expr . / expr
    (35) expr -> expr . % expr
    (36) expr -> expr . OR expr
    (37) expr -> expr . AND expr
    (38) expr -> expr . > expr
    (39) expr -> expr . < expr
    (40) expr -> expr . GTE expr
    (41) expr -> expr . LTE expr
    (42) expr -> expr . EQ expr
    (43) expr -> expr . NEQ expr
    (44) expr -> expr . $ expr
    (48) expr -> expr . [ expr ]

    ;               shift and go to state 145
    +               shift and go to state 44
    -               shift and go to state 45
    *               shift and go to state 46
    /               shift and go to state 47
    %               shift and go to state 48
    OR              shift and go to state 49
    AND             shift and go to state 50
    >               shift and go to state 51
    <               shift and go to state 52
    GTE             shift and go to state 53
    LTE             shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    $               shift and go to state 57
    [               shift and go to state 58


state 143

    (9) stmt -> WHILE new_label ( expr ) jz block .

    PRINT           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    PRINTLN         reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    WHILE           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    BREAK           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    CONTINUE        reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    IF              reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ID              reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    RETURN          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    PRINTI          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    INPUT           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    STR             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ATOI            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ALLOC           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    !               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    -               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    STRING          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    NUM             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    TRUE            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    FALSE           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    (               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    $end            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    DEF             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    }               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ELSE            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)


state 144

    (13) stmt -> IF ( expr ) jz block ELSE . jmp jz_label block
    (14) jmp -> .

    {               reduce using rule 14 (jmp -> .)
    PRINT           reduce using rule 14 (jmp -> .)
    PRINTLN         reduce using rule 14 (jmp -> .)
    WHILE           reduce using rule 14 (jmp -> .)
    BREAK           reduce using rule 14 (jmp -> .)
    CONTINUE        reduce using rule 14 (jmp -> .)
    IF              reduce using rule 14 (jmp -> .)
    ID              reduce using rule 14 (jmp -> .)
    RETURN          reduce using rule 14 (jmp -> .)
    PRINTI          reduce using rule 14 (jmp -> .)
    INPUT           reduce using rule 14 (jmp -> .)
    STR             reduce using rule 14 (jmp -> .)
    ATOI            reduce using rule 14 (jmp -> .)
    ALLOC           reduce using rule 14 (jmp -> .)
    !               reduce using rule 14 (jmp -> .)
    -               reduce using rule 14 (jmp -> .)
    STRING          reduce using rule 14 (jmp -> .)
    NUM             reduce using rule 14 (jmp -> .)
    TRUE            reduce using rule 14 (jmp -> .)
    FALSE           reduce using rule 14 (jmp -> .)
    (               reduce using rule 14 (jmp -> .)

    jmp                            shift and go to state 146

state 145

    (21) stmt -> arr_id [ expr ] = expr ; .

    PRINT           reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    PRINTLN         reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    WHILE           reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    BREAK           reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    CONTINUE        reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    IF              reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    ID              reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    RETURN          reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    PRINTI          reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    INPUT           reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    STR             reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    ATOI            reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    ALLOC           reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    !               reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    -               reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    STRING          reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    NUM             reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    TRUE            reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    FALSE           reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    (               reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    $end            reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    DEF             reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    }               reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)
    ELSE            reduce using rule 21 (stmt -> arr_id [ expr ] = expr ; .)


state 146

    (13) stmt -> IF ( expr ) jz block ELSE jmp . jz_label block
    (16) jz_label -> .

    {               reduce using rule 16 (jz_label -> .)
    PRINT           reduce using rule 16 (jz_label -> .)
    PRINTLN         reduce using rule 16 (jz_label -> .)
    WHILE           reduce using rule 16 (jz_label -> .)
    BREAK           reduce using rule 16 (jz_label -> .)
    CONTINUE        reduce using rule 16 (jz_label -> .)
    IF              reduce using rule 16 (jz_label -> .)
    ID              reduce using rule 16 (jz_label -> .)
    RETURN          reduce using rule 16 (jz_label -> .)
    PRINTI          reduce using rule 16 (jz_label -> .)
    INPUT           reduce using rule 16 (jz_label -> .)
    STR             reduce using rule 16 (jz_label -> .)
    ATOI            reduce using rule 16 (jz_label -> .)
    ALLOC           reduce using rule 16 (jz_label -> .)
    !               reduce using rule 16 (jz_label -> .)
    -               reduce using rule 16 (jz_label -> .)
    STRING          reduce using rule 16 (jz_label -> .)
    NUM             reduce using rule 16 (jz_label -> .)
    TRUE            reduce using rule 16 (jz_label -> .)
    FALSE           reduce using rule 16 (jz_label -> .)
    (               reduce using rule 16 (jz_label -> .)

    jz_label                       shift and go to state 147

state 147

    (13) stmt -> IF ( expr ) jz block ELSE jmp jz_label . block
    (66) block -> . { stmtlist }
    (67) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . BREAK ;
    (11) stmt -> . CONTINUE ;
    (12) stmt -> . IF ( expr ) jz block
    (13) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . arr_id [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . PRINTI ( expr ) ;
    (26) stmt -> . expr ;
    (22) arr_id -> . ID
    (27) expr -> . INPUT ( )
    (28) expr -> . STR ( expr )
    (29) expr -> . ATOI ( expr )
    (30) expr -> . ALLOC ( expr )
    (31) expr -> . expr + expr
    (32) expr -> . expr - expr
    (33) expr -> . expr * expr
    (34) expr -> . expr / expr
    (35) expr -> . expr % expr
    (36) expr -> . expr OR expr
    (37) expr -> . expr AND expr
    (38) expr -> . expr > expr
    (39) expr -> . expr < expr
    (40) expr -> . expr GTE expr
    (41) expr -> . expr LTE expr
    (42) expr -> . expr EQ expr
    (43) expr -> . expr NEQ expr
    (44) expr -> . expr $ expr
    (45) expr -> . ! expr
    (46) expr -> . - expr
    (47) expr -> . ID
    (48) expr -> . expr [ expr ]
    (49) expr -> . STRING
    (50) expr -> . NUM
    (51) expr -> . TRUE
    (52) expr -> . FALSE
    (53) expr -> . ID ( exprlist )
    (54) expr -> . ID ( )
    (55) expr -> . ( expr )

    {               shift and go to state 115
    PRINT           shift and go to state 30
    PRINTLN         shift and go to state 32
    WHILE           shift and go to state 33
    BREAK           shift and go to state 34
    CONTINUE        shift and go to state 35
    IF              shift and go to state 36
    ID              shift and go to state 37
    RETURN          shift and go to state 39
    PRINTI          shift and go to state 40
    INPUT           shift and go to state 18
    STR             shift and go to state 20
    ATOI            shift and go to state 21
    ALLOC           shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 19

    expr                           shift and go to state 31
    block                          shift and go to state 148
    stmt                           shift and go to state 116
    arr_id                         shift and go to state 38

state 148

    (13) stmt -> IF ( expr ) jz block ELSE jmp jz_label block .

    PRINT           reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    PRINTLN         reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    WHILE           reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    BREAK           reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    CONTINUE        reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    IF              reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ID              reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    RETURN          reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    PRINTI          reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    INPUT           reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STR             reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ATOI            reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ALLOC           reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    !               reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    -               reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STRING          reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    NUM             reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    TRUE            reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    FALSE           reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    (               reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    $end            reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    DEF             reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    }               reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ELSE            reduce using rule 13 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 141 resolved as shift
WARNING: reduce/reduce conflict in state 37 resolved using rule (arr_id -> ID)
WARNING: rejected rule (expr -> ID) in state 37
