Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declist start funlist entrypoint stmtlist
Rule 2     start -> <empty>
Rule 3     entrypoint -> <empty>
Rule 4     fun -> DEF fun_name ( idlist ) block
Rule 5     fun -> DEF fun_name ( ) block
Rule 6     fun_name -> ID
Rule 7     stmt -> PRINT ( expr ) ;
Rule 8     stmt -> PRINTLN ( ) ;
Rule 9     stmt -> WHILE new_label ( expr ) jz block
Rule 10    stmt -> IF ( expr ) jz block
Rule 11    stmt -> IF ( expr ) jz block ELSE jmp jz_label block
Rule 12    jmp -> <empty>
Rule 13    jz -> <empty>
Rule 14    jz_label -> <empty>
Rule 15    new_label -> <empty>
Rule 16    var_declare -> VAR ID = expr ;
Rule 17    var_declare -> VAR ID ;
Rule 18    var_declare -> VAR ID [ NUM ] ;
Rule 19    stmt -> ID = expr ;
Rule 20    stmt -> expr [ expr ] = expr ;
Rule 21    stmt -> RETURN expr ;
Rule 22    stmt -> RETURN ;
Rule 23    stmt -> PRINTI ( expr ) ;
Rule 24    stmt -> expr ;
Rule 25    expr -> INPUT ( )
Rule 26    expr -> STR ( expr )
Rule 27    expr -> ATOI ( expr )
Rule 28    expr -> expr + expr
Rule 29    expr -> expr - expr
Rule 30    expr -> expr * expr
Rule 31    expr -> expr / expr
Rule 32    expr -> expr % expr
Rule 33    expr -> expr OR expr
Rule 34    expr -> expr AND expr
Rule 35    expr -> expr > expr
Rule 36    expr -> expr < expr
Rule 37    expr -> expr GTE expr
Rule 38    expr -> expr LTE expr
Rule 39    expr -> expr EQ expr
Rule 40    expr -> expr NEQ expr
Rule 41    expr -> expr $ expr
Rule 42    expr -> ! expr
Rule 43    expr -> - expr
Rule 44    expr -> ID
Rule 45    expr -> expr [ expr ]
Rule 46    expr -> STRING
Rule 47    expr -> NUM
Rule 48    expr -> TRUE
Rule 49    expr -> FALSE
Rule 50    expr -> ID ( exprlist )
Rule 51    expr -> ID ( )
Rule 52    expr -> ( expr )
Rule 53    declist -> declist var_declare
Rule 54    declist -> <empty>
Rule 55    funlist -> funlist fun
Rule 56    funlist -> <empty>
Rule 57    stmtlist -> stmtlist stmt
Rule 58    stmtlist -> <empty>
Rule 59    idlist -> idlist , ID
Rule 60    idlist -> ID
Rule 61    exprlist -> exprlist , expr
Rule 62    exprlist -> expr
Rule 63    block -> { stmtlist }
Rule 64    block -> stmt

Terminals, with rules where they appear

!                    : 42
$                    : 41
%                    : 32
(                    : 4 5 7 8 9 10 11 23 25 26 27 50 51 52
)                    : 4 5 7 8 9 10 11 23 25 26 27 50 51 52
*                    : 30
+                    : 28
,                    : 59 61
-                    : 29 43
/                    : 31
;                    : 7 8 16 17 18 19 20 21 22 23 24
<                    : 36
=                    : 16 19 20
>                    : 35
AND                  : 34
ATOI                 : 27
DEF                  : 4 5
ELSE                 : 11
EQ                   : 39
FALSE                : 49
GTE                  : 37
ID                   : 6 16 17 18 19 44 50 51 59 60
IF                   : 10 11
INPUT                : 25
LTE                  : 38
NEQ                  : 40
NUM                  : 18 47
OR                   : 33
PRINT                : 7
PRINTI               : 23
PRINTLN              : 8
RETURN               : 21 22
STR                  : 26
STRING               : 46
TRUE                 : 48
VAR                  : 16 17 18
WHILE                : 9
[                    : 18 20 45
]                    : 18 20 45
error                : 
{                    : 63
}                    : 63

Nonterminals, with rules where they appear

block                : 4 5 9 10 11 11
declist              : 1 53
entrypoint           : 1
expr                 : 7 9 10 11 16 19 20 20 20 21 23 24 26 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 43 45 45 52 61 62
exprlist             : 50 61
fun                  : 55
fun_name             : 4 5
funlist              : 1 55
idlist               : 4 59
jmp                  : 11
jz                   : 9 10 11
jz_label             : 11
new_label            : 9
program              : 0
start                : 1
stmt                 : 57 64
stmtlist             : 1 57 63
var_declare          : 53

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declist start funlist entrypoint stmtlist
    (53) declist -> . declist var_declare
    (54) declist -> .

    VAR             reduce using rule 54 (declist -> .)
    DEF             reduce using rule 54 (declist -> .)
    PRINT           reduce using rule 54 (declist -> .)
    PRINTLN         reduce using rule 54 (declist -> .)
    WHILE           reduce using rule 54 (declist -> .)
    IF              reduce using rule 54 (declist -> .)
    ID              reduce using rule 54 (declist -> .)
    RETURN          reduce using rule 54 (declist -> .)
    PRINTI          reduce using rule 54 (declist -> .)
    INPUT           reduce using rule 54 (declist -> .)
    STR             reduce using rule 54 (declist -> .)
    ATOI            reduce using rule 54 (declist -> .)
    !               reduce using rule 54 (declist -> .)
    -               reduce using rule 54 (declist -> .)
    STRING          reduce using rule 54 (declist -> .)
    NUM             reduce using rule 54 (declist -> .)
    TRUE            reduce using rule 54 (declist -> .)
    FALSE           reduce using rule 54 (declist -> .)
    (               reduce using rule 54 (declist -> .)
    $end            reduce using rule 54 (declist -> .)

    program                        shift and go to state 1
    declist                        shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> declist . start funlist entrypoint stmtlist
    (53) declist -> declist . var_declare
    (2) start -> .
    (16) var_declare -> . VAR ID = expr ;
    (17) var_declare -> . VAR ID ;
    (18) var_declare -> . VAR ID [ NUM ] ;

    DEF             reduce using rule 2 (start -> .)
    PRINT           reduce using rule 2 (start -> .)
    PRINTLN         reduce using rule 2 (start -> .)
    WHILE           reduce using rule 2 (start -> .)
    IF              reduce using rule 2 (start -> .)
    ID              reduce using rule 2 (start -> .)
    RETURN          reduce using rule 2 (start -> .)
    PRINTI          reduce using rule 2 (start -> .)
    INPUT           reduce using rule 2 (start -> .)
    STR             reduce using rule 2 (start -> .)
    ATOI            reduce using rule 2 (start -> .)
    !               reduce using rule 2 (start -> .)
    -               reduce using rule 2 (start -> .)
    STRING          reduce using rule 2 (start -> .)
    NUM             reduce using rule 2 (start -> .)
    TRUE            reduce using rule 2 (start -> .)
    FALSE           reduce using rule 2 (start -> .)
    (               reduce using rule 2 (start -> .)
    $end            reduce using rule 2 (start -> .)
    VAR             shift and go to state 5

    start                          shift and go to state 3
    var_declare                    shift and go to state 4

state 3

    (1) program -> declist start . funlist entrypoint stmtlist
    (55) funlist -> . funlist fun
    (56) funlist -> .

    DEF             reduce using rule 56 (funlist -> .)
    PRINT           reduce using rule 56 (funlist -> .)
    PRINTLN         reduce using rule 56 (funlist -> .)
    WHILE           reduce using rule 56 (funlist -> .)
    IF              reduce using rule 56 (funlist -> .)
    ID              reduce using rule 56 (funlist -> .)
    RETURN          reduce using rule 56 (funlist -> .)
    PRINTI          reduce using rule 56 (funlist -> .)
    INPUT           reduce using rule 56 (funlist -> .)
    STR             reduce using rule 56 (funlist -> .)
    ATOI            reduce using rule 56 (funlist -> .)
    !               reduce using rule 56 (funlist -> .)
    -               reduce using rule 56 (funlist -> .)
    STRING          reduce using rule 56 (funlist -> .)
    NUM             reduce using rule 56 (funlist -> .)
    TRUE            reduce using rule 56 (funlist -> .)
    FALSE           reduce using rule 56 (funlist -> .)
    (               reduce using rule 56 (funlist -> .)
    $end            reduce using rule 56 (funlist -> .)

    funlist                        shift and go to state 6

state 4

    (53) declist -> declist var_declare .

    VAR             reduce using rule 53 (declist -> declist var_declare .)
    DEF             reduce using rule 53 (declist -> declist var_declare .)
    PRINT           reduce using rule 53 (declist -> declist var_declare .)
    PRINTLN         reduce using rule 53 (declist -> declist var_declare .)
    WHILE           reduce using rule 53 (declist -> declist var_declare .)
    IF              reduce using rule 53 (declist -> declist var_declare .)
    ID              reduce using rule 53 (declist -> declist var_declare .)
    RETURN          reduce using rule 53 (declist -> declist var_declare .)
    PRINTI          reduce using rule 53 (declist -> declist var_declare .)
    INPUT           reduce using rule 53 (declist -> declist var_declare .)
    STR             reduce using rule 53 (declist -> declist var_declare .)
    ATOI            reduce using rule 53 (declist -> declist var_declare .)
    !               reduce using rule 53 (declist -> declist var_declare .)
    -               reduce using rule 53 (declist -> declist var_declare .)
    STRING          reduce using rule 53 (declist -> declist var_declare .)
    NUM             reduce using rule 53 (declist -> declist var_declare .)
    TRUE            reduce using rule 53 (declist -> declist var_declare .)
    FALSE           reduce using rule 53 (declist -> declist var_declare .)
    (               reduce using rule 53 (declist -> declist var_declare .)
    $end            reduce using rule 53 (declist -> declist var_declare .)


state 5

    (16) var_declare -> VAR . ID = expr ;
    (17) var_declare -> VAR . ID ;
    (18) var_declare -> VAR . ID [ NUM ] ;

    ID              shift and go to state 7


state 6

    (1) program -> declist start funlist . entrypoint stmtlist
    (55) funlist -> funlist . fun
    (3) entrypoint -> .
    (4) fun -> . DEF fun_name ( idlist ) block
    (5) fun -> . DEF fun_name ( ) block

    PRINT           reduce using rule 3 (entrypoint -> .)
    PRINTLN         reduce using rule 3 (entrypoint -> .)
    WHILE           reduce using rule 3 (entrypoint -> .)
    IF              reduce using rule 3 (entrypoint -> .)
    ID              reduce using rule 3 (entrypoint -> .)
    RETURN          reduce using rule 3 (entrypoint -> .)
    PRINTI          reduce using rule 3 (entrypoint -> .)
    INPUT           reduce using rule 3 (entrypoint -> .)
    STR             reduce using rule 3 (entrypoint -> .)
    ATOI            reduce using rule 3 (entrypoint -> .)
    !               reduce using rule 3 (entrypoint -> .)
    -               reduce using rule 3 (entrypoint -> .)
    STRING          reduce using rule 3 (entrypoint -> .)
    NUM             reduce using rule 3 (entrypoint -> .)
    TRUE            reduce using rule 3 (entrypoint -> .)
    FALSE           reduce using rule 3 (entrypoint -> .)
    (               reduce using rule 3 (entrypoint -> .)
    $end            reduce using rule 3 (entrypoint -> .)
    DEF             shift and go to state 10

    entrypoint                     shift and go to state 8
    fun                            shift and go to state 9

state 7

    (16) var_declare -> VAR ID . = expr ;
    (17) var_declare -> VAR ID . ;
    (18) var_declare -> VAR ID . [ NUM ] ;

    =               shift and go to state 11
    ;               shift and go to state 12
    [               shift and go to state 13


state 8

    (1) program -> declist start funlist entrypoint . stmtlist
    (57) stmtlist -> . stmtlist stmt
    (58) stmtlist -> .

    PRINT           reduce using rule 58 (stmtlist -> .)
    PRINTLN         reduce using rule 58 (stmtlist -> .)
    WHILE           reduce using rule 58 (stmtlist -> .)
    IF              reduce using rule 58 (stmtlist -> .)
    ID              reduce using rule 58 (stmtlist -> .)
    RETURN          reduce using rule 58 (stmtlist -> .)
    PRINTI          reduce using rule 58 (stmtlist -> .)
    INPUT           reduce using rule 58 (stmtlist -> .)
    STR             reduce using rule 58 (stmtlist -> .)
    ATOI            reduce using rule 58 (stmtlist -> .)
    !               reduce using rule 58 (stmtlist -> .)
    -               reduce using rule 58 (stmtlist -> .)
    STRING          reduce using rule 58 (stmtlist -> .)
    NUM             reduce using rule 58 (stmtlist -> .)
    TRUE            reduce using rule 58 (stmtlist -> .)
    FALSE           reduce using rule 58 (stmtlist -> .)
    (               reduce using rule 58 (stmtlist -> .)
    $end            reduce using rule 58 (stmtlist -> .)

    stmtlist                       shift and go to state 14

state 9

    (55) funlist -> funlist fun .

    DEF             reduce using rule 55 (funlist -> funlist fun .)
    PRINT           reduce using rule 55 (funlist -> funlist fun .)
    PRINTLN         reduce using rule 55 (funlist -> funlist fun .)
    WHILE           reduce using rule 55 (funlist -> funlist fun .)
    IF              reduce using rule 55 (funlist -> funlist fun .)
    ID              reduce using rule 55 (funlist -> funlist fun .)
    RETURN          reduce using rule 55 (funlist -> funlist fun .)
    PRINTI          reduce using rule 55 (funlist -> funlist fun .)
    INPUT           reduce using rule 55 (funlist -> funlist fun .)
    STR             reduce using rule 55 (funlist -> funlist fun .)
    ATOI            reduce using rule 55 (funlist -> funlist fun .)
    !               reduce using rule 55 (funlist -> funlist fun .)
    -               reduce using rule 55 (funlist -> funlist fun .)
    STRING          reduce using rule 55 (funlist -> funlist fun .)
    NUM             reduce using rule 55 (funlist -> funlist fun .)
    TRUE            reduce using rule 55 (funlist -> funlist fun .)
    FALSE           reduce using rule 55 (funlist -> funlist fun .)
    (               reduce using rule 55 (funlist -> funlist fun .)
    $end            reduce using rule 55 (funlist -> funlist fun .)


state 10

    (4) fun -> DEF . fun_name ( idlist ) block
    (5) fun -> DEF . fun_name ( ) block
    (6) fun_name -> . ID

    ID              shift and go to state 16

    fun_name                       shift and go to state 15

state 11

    (16) var_declare -> VAR ID = . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 18

state 12

    (17) var_declare -> VAR ID ; .

    VAR             reduce using rule 17 (var_declare -> VAR ID ; .)
    DEF             reduce using rule 17 (var_declare -> VAR ID ; .)
    PRINT           reduce using rule 17 (var_declare -> VAR ID ; .)
    PRINTLN         reduce using rule 17 (var_declare -> VAR ID ; .)
    WHILE           reduce using rule 17 (var_declare -> VAR ID ; .)
    IF              reduce using rule 17 (var_declare -> VAR ID ; .)
    ID              reduce using rule 17 (var_declare -> VAR ID ; .)
    RETURN          reduce using rule 17 (var_declare -> VAR ID ; .)
    PRINTI          reduce using rule 17 (var_declare -> VAR ID ; .)
    INPUT           reduce using rule 17 (var_declare -> VAR ID ; .)
    STR             reduce using rule 17 (var_declare -> VAR ID ; .)
    ATOI            reduce using rule 17 (var_declare -> VAR ID ; .)
    !               reduce using rule 17 (var_declare -> VAR ID ; .)
    -               reduce using rule 17 (var_declare -> VAR ID ; .)
    STRING          reduce using rule 17 (var_declare -> VAR ID ; .)
    NUM             reduce using rule 17 (var_declare -> VAR ID ; .)
    TRUE            reduce using rule 17 (var_declare -> VAR ID ; .)
    FALSE           reduce using rule 17 (var_declare -> VAR ID ; .)
    (               reduce using rule 17 (var_declare -> VAR ID ; .)
    $end            reduce using rule 17 (var_declare -> VAR ID ; .)


state 13

    (18) var_declare -> VAR ID [ . NUM ] ;

    NUM             shift and go to state 29


state 14

    (1) program -> declist start funlist entrypoint stmtlist .
    (57) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . expr [ expr ] = expr ;
    (21) stmt -> . RETURN expr ;
    (22) stmt -> . RETURN ;
    (23) stmt -> . PRINTI ( expr ) ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    $end            reduce using rule 1 (program -> declist start funlist entrypoint stmtlist .)
    PRINT           shift and go to state 31
    PRINTLN         shift and go to state 33
    WHILE           shift and go to state 34
    IF              shift and go to state 35
    ID              shift and go to state 36
    RETURN          shift and go to state 37
    PRINTI          shift and go to state 38
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    stmt                           shift and go to state 30
    expr                           shift and go to state 32

state 15

    (4) fun -> DEF fun_name . ( idlist ) block
    (5) fun -> DEF fun_name . ( ) block

    (               shift and go to state 39


state 16

    (6) fun_name -> ID .

    (               reduce using rule 6 (fun_name -> ID .)


state 17

    (44) expr -> ID .
    (50) expr -> ID . ( exprlist )
    (51) expr -> ID . ( )

    ;               reduce using rule 44 (expr -> ID .)
    +               reduce using rule 44 (expr -> ID .)
    -               reduce using rule 44 (expr -> ID .)
    *               reduce using rule 44 (expr -> ID .)
    /               reduce using rule 44 (expr -> ID .)
    %               reduce using rule 44 (expr -> ID .)
    OR              reduce using rule 44 (expr -> ID .)
    AND             reduce using rule 44 (expr -> ID .)
    >               reduce using rule 44 (expr -> ID .)
    <               reduce using rule 44 (expr -> ID .)
    GTE             reduce using rule 44 (expr -> ID .)
    LTE             reduce using rule 44 (expr -> ID .)
    EQ              reduce using rule 44 (expr -> ID .)
    NEQ             reduce using rule 44 (expr -> ID .)
    $               reduce using rule 44 (expr -> ID .)
    [               reduce using rule 44 (expr -> ID .)
    )               reduce using rule 44 (expr -> ID .)
    ,               reduce using rule 44 (expr -> ID .)
    ]               reduce using rule 44 (expr -> ID .)
    (               shift and go to state 40


state 18

    (16) var_declare -> VAR ID = expr . ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               shift and go to state 41
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 19

    (25) expr -> INPUT . ( )

    (               shift and go to state 57


state 20

    (52) expr -> ( . expr )
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 58

state 21

    (26) expr -> STR . ( expr )

    (               shift and go to state 59


state 22

    (27) expr -> ATOI . ( expr )

    (               shift and go to state 60


state 23

    (43) expr -> - . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 61

state 24

    (42) expr -> ! . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 62

state 25

    (46) expr -> STRING .

    ;               reduce using rule 46 (expr -> STRING .)
    +               reduce using rule 46 (expr -> STRING .)
    -               reduce using rule 46 (expr -> STRING .)
    *               reduce using rule 46 (expr -> STRING .)
    /               reduce using rule 46 (expr -> STRING .)
    %               reduce using rule 46 (expr -> STRING .)
    OR              reduce using rule 46 (expr -> STRING .)
    AND             reduce using rule 46 (expr -> STRING .)
    >               reduce using rule 46 (expr -> STRING .)
    <               reduce using rule 46 (expr -> STRING .)
    GTE             reduce using rule 46 (expr -> STRING .)
    LTE             reduce using rule 46 (expr -> STRING .)
    EQ              reduce using rule 46 (expr -> STRING .)
    NEQ             reduce using rule 46 (expr -> STRING .)
    $               reduce using rule 46 (expr -> STRING .)
    [               reduce using rule 46 (expr -> STRING .)
    )               reduce using rule 46 (expr -> STRING .)
    ,               reduce using rule 46 (expr -> STRING .)
    ]               reduce using rule 46 (expr -> STRING .)


state 26

    (47) expr -> NUM .

    ;               reduce using rule 47 (expr -> NUM .)
    +               reduce using rule 47 (expr -> NUM .)
    -               reduce using rule 47 (expr -> NUM .)
    *               reduce using rule 47 (expr -> NUM .)
    /               reduce using rule 47 (expr -> NUM .)
    %               reduce using rule 47 (expr -> NUM .)
    OR              reduce using rule 47 (expr -> NUM .)
    AND             reduce using rule 47 (expr -> NUM .)
    >               reduce using rule 47 (expr -> NUM .)
    <               reduce using rule 47 (expr -> NUM .)
    GTE             reduce using rule 47 (expr -> NUM .)
    LTE             reduce using rule 47 (expr -> NUM .)
    EQ              reduce using rule 47 (expr -> NUM .)
    NEQ             reduce using rule 47 (expr -> NUM .)
    $               reduce using rule 47 (expr -> NUM .)
    [               reduce using rule 47 (expr -> NUM .)
    )               reduce using rule 47 (expr -> NUM .)
    ,               reduce using rule 47 (expr -> NUM .)
    ]               reduce using rule 47 (expr -> NUM .)


state 27

    (48) expr -> TRUE .

    ;               reduce using rule 48 (expr -> TRUE .)
    +               reduce using rule 48 (expr -> TRUE .)
    -               reduce using rule 48 (expr -> TRUE .)
    *               reduce using rule 48 (expr -> TRUE .)
    /               reduce using rule 48 (expr -> TRUE .)
    %               reduce using rule 48 (expr -> TRUE .)
    OR              reduce using rule 48 (expr -> TRUE .)
    AND             reduce using rule 48 (expr -> TRUE .)
    >               reduce using rule 48 (expr -> TRUE .)
    <               reduce using rule 48 (expr -> TRUE .)
    GTE             reduce using rule 48 (expr -> TRUE .)
    LTE             reduce using rule 48 (expr -> TRUE .)
    EQ              reduce using rule 48 (expr -> TRUE .)
    NEQ             reduce using rule 48 (expr -> TRUE .)
    $               reduce using rule 48 (expr -> TRUE .)
    [               reduce using rule 48 (expr -> TRUE .)
    )               reduce using rule 48 (expr -> TRUE .)
    ,               reduce using rule 48 (expr -> TRUE .)
    ]               reduce using rule 48 (expr -> TRUE .)


state 28

    (49) expr -> FALSE .

    ;               reduce using rule 49 (expr -> FALSE .)
    +               reduce using rule 49 (expr -> FALSE .)
    -               reduce using rule 49 (expr -> FALSE .)
    *               reduce using rule 49 (expr -> FALSE .)
    /               reduce using rule 49 (expr -> FALSE .)
    %               reduce using rule 49 (expr -> FALSE .)
    OR              reduce using rule 49 (expr -> FALSE .)
    AND             reduce using rule 49 (expr -> FALSE .)
    >               reduce using rule 49 (expr -> FALSE .)
    <               reduce using rule 49 (expr -> FALSE .)
    GTE             reduce using rule 49 (expr -> FALSE .)
    LTE             reduce using rule 49 (expr -> FALSE .)
    EQ              reduce using rule 49 (expr -> FALSE .)
    NEQ             reduce using rule 49 (expr -> FALSE .)
    $               reduce using rule 49 (expr -> FALSE .)
    [               reduce using rule 49 (expr -> FALSE .)
    )               reduce using rule 49 (expr -> FALSE .)
    ,               reduce using rule 49 (expr -> FALSE .)
    ]               reduce using rule 49 (expr -> FALSE .)


state 29

    (18) var_declare -> VAR ID [ NUM . ] ;

    ]               shift and go to state 63


state 30

    (57) stmtlist -> stmtlist stmt .

    PRINT           reduce using rule 57 (stmtlist -> stmtlist stmt .)
    PRINTLN         reduce using rule 57 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 57 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 57 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 57 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 57 (stmtlist -> stmtlist stmt .)
    PRINTI          reduce using rule 57 (stmtlist -> stmtlist stmt .)
    INPUT           reduce using rule 57 (stmtlist -> stmtlist stmt .)
    STR             reduce using rule 57 (stmtlist -> stmtlist stmt .)
    ATOI            reduce using rule 57 (stmtlist -> stmtlist stmt .)
    !               reduce using rule 57 (stmtlist -> stmtlist stmt .)
    -               reduce using rule 57 (stmtlist -> stmtlist stmt .)
    STRING          reduce using rule 57 (stmtlist -> stmtlist stmt .)
    NUM             reduce using rule 57 (stmtlist -> stmtlist stmt .)
    TRUE            reduce using rule 57 (stmtlist -> stmtlist stmt .)
    FALSE           reduce using rule 57 (stmtlist -> stmtlist stmt .)
    (               reduce using rule 57 (stmtlist -> stmtlist stmt .)
    $end            reduce using rule 57 (stmtlist -> stmtlist stmt .)
    }               reduce using rule 57 (stmtlist -> stmtlist stmt .)


state 31

    (7) stmt -> PRINT . ( expr ) ;

    (               shift and go to state 64


state 32

    (20) stmt -> expr . [ expr ] = expr ;
    (24) stmt -> expr . ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               shift and go to state 65
    ;               shift and go to state 66
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55


state 33

    (8) stmt -> PRINTLN . ( ) ;

    (               shift and go to state 67


state 34

    (9) stmt -> WHILE . new_label ( expr ) jz block
    (15) new_label -> .

    (               reduce using rule 15 (new_label -> .)

    new_label                      shift and go to state 68

state 35

    (10) stmt -> IF . ( expr ) jz block
    (11) stmt -> IF . ( expr ) jz block ELSE jmp jz_label block

    (               shift and go to state 69


state 36

    (19) stmt -> ID . = expr ;
    (44) expr -> ID .
    (50) expr -> ID . ( exprlist )
    (51) expr -> ID . ( )

    =               shift and go to state 70
    [               reduce using rule 44 (expr -> ID .)
    ;               reduce using rule 44 (expr -> ID .)
    +               reduce using rule 44 (expr -> ID .)
    -               reduce using rule 44 (expr -> ID .)
    *               reduce using rule 44 (expr -> ID .)
    /               reduce using rule 44 (expr -> ID .)
    %               reduce using rule 44 (expr -> ID .)
    OR              reduce using rule 44 (expr -> ID .)
    AND             reduce using rule 44 (expr -> ID .)
    >               reduce using rule 44 (expr -> ID .)
    <               reduce using rule 44 (expr -> ID .)
    GTE             reduce using rule 44 (expr -> ID .)
    LTE             reduce using rule 44 (expr -> ID .)
    EQ              reduce using rule 44 (expr -> ID .)
    NEQ             reduce using rule 44 (expr -> ID .)
    $               reduce using rule 44 (expr -> ID .)
    (               shift and go to state 40


state 37

    (21) stmt -> RETURN . expr ;
    (22) stmt -> RETURN . ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    ;               shift and go to state 72
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 71

state 38

    (23) stmt -> PRINTI . ( expr ) ;

    (               shift and go to state 73


state 39

    (4) fun -> DEF fun_name ( . idlist ) block
    (5) fun -> DEF fun_name ( . ) block
    (59) idlist -> . idlist , ID
    (60) idlist -> . ID

    )               shift and go to state 75
    ID              shift and go to state 76

    idlist                         shift and go to state 74

state 40

    (50) expr -> ID ( . exprlist )
    (51) expr -> ID ( . )
    (61) exprlist -> . exprlist , expr
    (62) exprlist -> . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    )               shift and go to state 78
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    exprlist                       shift and go to state 77
    expr                           shift and go to state 79

state 41

    (16) var_declare -> VAR ID = expr ; .

    VAR             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    DEF             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    PRINT           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    PRINTLN         reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    WHILE           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    IF              reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    ID              reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    RETURN          reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    PRINTI          reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    INPUT           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    STR             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    ATOI            reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    !               reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    -               reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    STRING          reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    NUM             reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    TRUE            reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    FALSE           reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    (               reduce using rule 16 (var_declare -> VAR ID = expr ; .)
    $end            reduce using rule 16 (var_declare -> VAR ID = expr ; .)


state 42

    (28) expr -> expr + . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 80

state 43

    (29) expr -> expr - . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 81

state 44

    (30) expr -> expr * . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 82

state 45

    (31) expr -> expr / . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 83

state 46

    (32) expr -> expr % . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 84

state 47

    (33) expr -> expr OR . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 85

state 48

    (34) expr -> expr AND . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 86

state 49

    (35) expr -> expr > . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 87

state 50

    (36) expr -> expr < . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 88

state 51

    (37) expr -> expr GTE . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 89

state 52

    (38) expr -> expr LTE . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 90

state 53

    (39) expr -> expr EQ . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 91

state 54

    (40) expr -> expr NEQ . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 92

state 55

    (41) expr -> expr $ . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 93

state 56

    (45) expr -> expr [ . expr ]
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 94

state 57

    (25) expr -> INPUT ( . )

    )               shift and go to state 95


state 58

    (52) expr -> ( expr . )
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 96
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 59

    (26) expr -> STR ( . expr )
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 97

state 60

    (27) expr -> ATOI ( . expr )
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 98

state 61

    (43) expr -> - expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 43 (expr -> - expr .)
    +               reduce using rule 43 (expr -> - expr .)
    -               reduce using rule 43 (expr -> - expr .)
    *               reduce using rule 43 (expr -> - expr .)
    /               reduce using rule 43 (expr -> - expr .)
    %               reduce using rule 43 (expr -> - expr .)
    OR              reduce using rule 43 (expr -> - expr .)
    AND             reduce using rule 43 (expr -> - expr .)
    >               reduce using rule 43 (expr -> - expr .)
    <               reduce using rule 43 (expr -> - expr .)
    GTE             reduce using rule 43 (expr -> - expr .)
    LTE             reduce using rule 43 (expr -> - expr .)
    EQ              reduce using rule 43 (expr -> - expr .)
    NEQ             reduce using rule 43 (expr -> - expr .)
    $               reduce using rule 43 (expr -> - expr .)
    [               reduce using rule 43 (expr -> - expr .)
    )               reduce using rule 43 (expr -> - expr .)
    ,               reduce using rule 43 (expr -> - expr .)
    ]               reduce using rule 43 (expr -> - expr .)

  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! %               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 62

    (42) expr -> ! expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 42 (expr -> ! expr .)
    +               reduce using rule 42 (expr -> ! expr .)
    -               reduce using rule 42 (expr -> ! expr .)
    *               reduce using rule 42 (expr -> ! expr .)
    /               reduce using rule 42 (expr -> ! expr .)
    %               reduce using rule 42 (expr -> ! expr .)
    OR              reduce using rule 42 (expr -> ! expr .)
    AND             reduce using rule 42 (expr -> ! expr .)
    >               reduce using rule 42 (expr -> ! expr .)
    <               reduce using rule 42 (expr -> ! expr .)
    GTE             reduce using rule 42 (expr -> ! expr .)
    LTE             reduce using rule 42 (expr -> ! expr .)
    EQ              reduce using rule 42 (expr -> ! expr .)
    NEQ             reduce using rule 42 (expr -> ! expr .)
    $               reduce using rule 42 (expr -> ! expr .)
    [               reduce using rule 42 (expr -> ! expr .)
    )               reduce using rule 42 (expr -> ! expr .)
    ,               reduce using rule 42 (expr -> ! expr .)
    ]               reduce using rule 42 (expr -> ! expr .)

  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! %               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 63

    (18) var_declare -> VAR ID [ NUM ] . ;

    ;               shift and go to state 99


state 64

    (7) stmt -> PRINT ( . expr ) ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 100

state 65

    (20) stmt -> expr [ . expr ] = expr ;
    (45) expr -> expr [ . expr ]
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 101

state 66

    (24) stmt -> expr ; .

    PRINT           reduce using rule 24 (stmt -> expr ; .)
    PRINTLN         reduce using rule 24 (stmt -> expr ; .)
    WHILE           reduce using rule 24 (stmt -> expr ; .)
    IF              reduce using rule 24 (stmt -> expr ; .)
    ID              reduce using rule 24 (stmt -> expr ; .)
    RETURN          reduce using rule 24 (stmt -> expr ; .)
    PRINTI          reduce using rule 24 (stmt -> expr ; .)
    INPUT           reduce using rule 24 (stmt -> expr ; .)
    STR             reduce using rule 24 (stmt -> expr ; .)
    ATOI            reduce using rule 24 (stmt -> expr ; .)
    !               reduce using rule 24 (stmt -> expr ; .)
    -               reduce using rule 24 (stmt -> expr ; .)
    STRING          reduce using rule 24 (stmt -> expr ; .)
    NUM             reduce using rule 24 (stmt -> expr ; .)
    TRUE            reduce using rule 24 (stmt -> expr ; .)
    FALSE           reduce using rule 24 (stmt -> expr ; .)
    (               reduce using rule 24 (stmt -> expr ; .)
    $end            reduce using rule 24 (stmt -> expr ; .)
    DEF             reduce using rule 24 (stmt -> expr ; .)
    }               reduce using rule 24 (stmt -> expr ; .)
    ELSE            reduce using rule 24 (stmt -> expr ; .)


state 67

    (8) stmt -> PRINTLN ( . ) ;

    )               shift and go to state 102


state 68

    (9) stmt -> WHILE new_label . ( expr ) jz block

    (               shift and go to state 103


state 69

    (10) stmt -> IF ( . expr ) jz block
    (11) stmt -> IF ( . expr ) jz block ELSE jmp jz_label block
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 104

state 70

    (19) stmt -> ID = . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 105

state 71

    (21) stmt -> RETURN expr . ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               shift and go to state 106
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 72

    (22) stmt -> RETURN ; .

    PRINT           reduce using rule 22 (stmt -> RETURN ; .)
    PRINTLN         reduce using rule 22 (stmt -> RETURN ; .)
    WHILE           reduce using rule 22 (stmt -> RETURN ; .)
    IF              reduce using rule 22 (stmt -> RETURN ; .)
    ID              reduce using rule 22 (stmt -> RETURN ; .)
    RETURN          reduce using rule 22 (stmt -> RETURN ; .)
    PRINTI          reduce using rule 22 (stmt -> RETURN ; .)
    INPUT           reduce using rule 22 (stmt -> RETURN ; .)
    STR             reduce using rule 22 (stmt -> RETURN ; .)
    ATOI            reduce using rule 22 (stmt -> RETURN ; .)
    !               reduce using rule 22 (stmt -> RETURN ; .)
    -               reduce using rule 22 (stmt -> RETURN ; .)
    STRING          reduce using rule 22 (stmt -> RETURN ; .)
    NUM             reduce using rule 22 (stmt -> RETURN ; .)
    TRUE            reduce using rule 22 (stmt -> RETURN ; .)
    FALSE           reduce using rule 22 (stmt -> RETURN ; .)
    (               reduce using rule 22 (stmt -> RETURN ; .)
    $end            reduce using rule 22 (stmt -> RETURN ; .)
    DEF             reduce using rule 22 (stmt -> RETURN ; .)
    }               reduce using rule 22 (stmt -> RETURN ; .)
    ELSE            reduce using rule 22 (stmt -> RETURN ; .)


state 73

    (23) stmt -> PRINTI ( . expr ) ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 107

state 74

    (4) fun -> DEF fun_name ( idlist . ) block
    (59) idlist -> idlist . , ID

    )               shift and go to state 108
    ,               shift and go to state 109


state 75

    (5) fun -> DEF fun_name ( ) . block
    (63) block -> . { stmtlist }
    (64) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . expr [ expr ] = expr ;
    (21) stmt -> . RETURN expr ;
    (22) stmt -> . RETURN ;
    (23) stmt -> . PRINTI ( expr ) ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    {               shift and go to state 111
    PRINT           shift and go to state 31
    PRINTLN         shift and go to state 33
    WHILE           shift and go to state 34
    IF              shift and go to state 35
    ID              shift and go to state 36
    RETURN          shift and go to state 37
    PRINTI          shift and go to state 38
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    block                          shift and go to state 110
    stmt                           shift and go to state 112
    expr                           shift and go to state 32

state 76

    (60) idlist -> ID .

    )               reduce using rule 60 (idlist -> ID .)
    ,               reduce using rule 60 (idlist -> ID .)


state 77

    (50) expr -> ID ( exprlist . )
    (61) exprlist -> exprlist . , expr

    )               shift and go to state 113
    ,               shift and go to state 114


state 78

    (51) expr -> ID ( ) .

    ;               reduce using rule 51 (expr -> ID ( ) .)
    +               reduce using rule 51 (expr -> ID ( ) .)
    -               reduce using rule 51 (expr -> ID ( ) .)
    *               reduce using rule 51 (expr -> ID ( ) .)
    /               reduce using rule 51 (expr -> ID ( ) .)
    %               reduce using rule 51 (expr -> ID ( ) .)
    OR              reduce using rule 51 (expr -> ID ( ) .)
    AND             reduce using rule 51 (expr -> ID ( ) .)
    >               reduce using rule 51 (expr -> ID ( ) .)
    <               reduce using rule 51 (expr -> ID ( ) .)
    GTE             reduce using rule 51 (expr -> ID ( ) .)
    LTE             reduce using rule 51 (expr -> ID ( ) .)
    EQ              reduce using rule 51 (expr -> ID ( ) .)
    NEQ             reduce using rule 51 (expr -> ID ( ) .)
    $               reduce using rule 51 (expr -> ID ( ) .)
    [               reduce using rule 51 (expr -> ID ( ) .)
    )               reduce using rule 51 (expr -> ID ( ) .)
    ,               reduce using rule 51 (expr -> ID ( ) .)
    ]               reduce using rule 51 (expr -> ID ( ) .)


state 79

    (62) exprlist -> expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               reduce using rule 62 (exprlist -> expr .)
    ,               reduce using rule 62 (exprlist -> expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 80

    (28) expr -> expr + expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 28 (expr -> expr + expr .)
    +               reduce using rule 28 (expr -> expr + expr .)
    -               reduce using rule 28 (expr -> expr + expr .)
    OR              reduce using rule 28 (expr -> expr + expr .)
    AND             reduce using rule 28 (expr -> expr + expr .)
    >               reduce using rule 28 (expr -> expr + expr .)
    <               reduce using rule 28 (expr -> expr + expr .)
    GTE             reduce using rule 28 (expr -> expr + expr .)
    LTE             reduce using rule 28 (expr -> expr + expr .)
    EQ              reduce using rule 28 (expr -> expr + expr .)
    NEQ             reduce using rule 28 (expr -> expr + expr .)
    $               reduce using rule 28 (expr -> expr + expr .)
    [               reduce using rule 28 (expr -> expr + expr .)
    )               reduce using rule 28 (expr -> expr + expr .)
    ,               reduce using rule 28 (expr -> expr + expr .)
    ]               reduce using rule 28 (expr -> expr + expr .)
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46

  ! *               [ reduce using rule 28 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 28 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 28 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 81

    (29) expr -> expr - expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 29 (expr -> expr - expr .)
    +               reduce using rule 29 (expr -> expr - expr .)
    -               reduce using rule 29 (expr -> expr - expr .)
    OR              reduce using rule 29 (expr -> expr - expr .)
    AND             reduce using rule 29 (expr -> expr - expr .)
    >               reduce using rule 29 (expr -> expr - expr .)
    <               reduce using rule 29 (expr -> expr - expr .)
    GTE             reduce using rule 29 (expr -> expr - expr .)
    LTE             reduce using rule 29 (expr -> expr - expr .)
    EQ              reduce using rule 29 (expr -> expr - expr .)
    NEQ             reduce using rule 29 (expr -> expr - expr .)
    $               reduce using rule 29 (expr -> expr - expr .)
    [               reduce using rule 29 (expr -> expr - expr .)
    )               reduce using rule 29 (expr -> expr - expr .)
    ,               reduce using rule 29 (expr -> expr - expr .)
    ]               reduce using rule 29 (expr -> expr - expr .)
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46

  ! *               [ reduce using rule 29 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 29 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 29 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 82

    (30) expr -> expr * expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 30 (expr -> expr * expr .)
    +               reduce using rule 30 (expr -> expr * expr .)
    -               reduce using rule 30 (expr -> expr * expr .)
    *               reduce using rule 30 (expr -> expr * expr .)
    /               reduce using rule 30 (expr -> expr * expr .)
    %               reduce using rule 30 (expr -> expr * expr .)
    OR              reduce using rule 30 (expr -> expr * expr .)
    AND             reduce using rule 30 (expr -> expr * expr .)
    >               reduce using rule 30 (expr -> expr * expr .)
    <               reduce using rule 30 (expr -> expr * expr .)
    GTE             reduce using rule 30 (expr -> expr * expr .)
    LTE             reduce using rule 30 (expr -> expr * expr .)
    EQ              reduce using rule 30 (expr -> expr * expr .)
    NEQ             reduce using rule 30 (expr -> expr * expr .)
    $               reduce using rule 30 (expr -> expr * expr .)
    [               reduce using rule 30 (expr -> expr * expr .)
    )               reduce using rule 30 (expr -> expr * expr .)
    ,               reduce using rule 30 (expr -> expr * expr .)
    ]               reduce using rule 30 (expr -> expr * expr .)

  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! %               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 83

    (31) expr -> expr / expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 31 (expr -> expr / expr .)
    +               reduce using rule 31 (expr -> expr / expr .)
    -               reduce using rule 31 (expr -> expr / expr .)
    *               reduce using rule 31 (expr -> expr / expr .)
    /               reduce using rule 31 (expr -> expr / expr .)
    %               reduce using rule 31 (expr -> expr / expr .)
    OR              reduce using rule 31 (expr -> expr / expr .)
    AND             reduce using rule 31 (expr -> expr / expr .)
    >               reduce using rule 31 (expr -> expr / expr .)
    <               reduce using rule 31 (expr -> expr / expr .)
    GTE             reduce using rule 31 (expr -> expr / expr .)
    LTE             reduce using rule 31 (expr -> expr / expr .)
    EQ              reduce using rule 31 (expr -> expr / expr .)
    NEQ             reduce using rule 31 (expr -> expr / expr .)
    $               reduce using rule 31 (expr -> expr / expr .)
    [               reduce using rule 31 (expr -> expr / expr .)
    )               reduce using rule 31 (expr -> expr / expr .)
    ,               reduce using rule 31 (expr -> expr / expr .)
    ]               reduce using rule 31 (expr -> expr / expr .)

  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! %               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 84

    (32) expr -> expr % expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 32 (expr -> expr % expr .)
    +               reduce using rule 32 (expr -> expr % expr .)
    -               reduce using rule 32 (expr -> expr % expr .)
    *               reduce using rule 32 (expr -> expr % expr .)
    /               reduce using rule 32 (expr -> expr % expr .)
    %               reduce using rule 32 (expr -> expr % expr .)
    OR              reduce using rule 32 (expr -> expr % expr .)
    AND             reduce using rule 32 (expr -> expr % expr .)
    >               reduce using rule 32 (expr -> expr % expr .)
    <               reduce using rule 32 (expr -> expr % expr .)
    GTE             reduce using rule 32 (expr -> expr % expr .)
    LTE             reduce using rule 32 (expr -> expr % expr .)
    EQ              reduce using rule 32 (expr -> expr % expr .)
    NEQ             reduce using rule 32 (expr -> expr % expr .)
    $               reduce using rule 32 (expr -> expr % expr .)
    [               reduce using rule 32 (expr -> expr % expr .)
    )               reduce using rule 32 (expr -> expr % expr .)
    ,               reduce using rule 32 (expr -> expr % expr .)
    ]               reduce using rule 32 (expr -> expr % expr .)

  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! *               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! %               [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 85

    (33) expr -> expr OR expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 33 (expr -> expr OR expr .)
    OR              reduce using rule 33 (expr -> expr OR expr .)
    AND             reduce using rule 33 (expr -> expr OR expr .)
    EQ              reduce using rule 33 (expr -> expr OR expr .)
    NEQ             reduce using rule 33 (expr -> expr OR expr .)
    [               reduce using rule 33 (expr -> expr OR expr .)
    )               reduce using rule 33 (expr -> expr OR expr .)
    ,               reduce using rule 33 (expr -> expr OR expr .)
    ]               reduce using rule 33 (expr -> expr OR expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    $               shift and go to state 55

  ! +               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! -               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! *               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! /               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! %               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! >               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! <               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! GTE             [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! LTE             [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! $               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 86

    (34) expr -> expr AND expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 34 (expr -> expr AND expr .)
    OR              reduce using rule 34 (expr -> expr AND expr .)
    AND             reduce using rule 34 (expr -> expr AND expr .)
    EQ              reduce using rule 34 (expr -> expr AND expr .)
    NEQ             reduce using rule 34 (expr -> expr AND expr .)
    [               reduce using rule 34 (expr -> expr AND expr .)
    )               reduce using rule 34 (expr -> expr AND expr .)
    ,               reduce using rule 34 (expr -> expr AND expr .)
    ]               reduce using rule 34 (expr -> expr AND expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    $               shift and go to state 55

  ! +               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! -               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! *               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! /               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! %               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! >               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! <               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! GTE             [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! LTE             [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! $               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 87

    (35) expr -> expr > expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 35 (expr -> expr > expr .)
    OR              reduce using rule 35 (expr -> expr > expr .)
    AND             reduce using rule 35 (expr -> expr > expr .)
    >               reduce using rule 35 (expr -> expr > expr .)
    <               reduce using rule 35 (expr -> expr > expr .)
    GTE             reduce using rule 35 (expr -> expr > expr .)
    LTE             reduce using rule 35 (expr -> expr > expr .)
    EQ              reduce using rule 35 (expr -> expr > expr .)
    NEQ             reduce using rule 35 (expr -> expr > expr .)
    [               reduce using rule 35 (expr -> expr > expr .)
    )               reduce using rule 35 (expr -> expr > expr .)
    ,               reduce using rule 35 (expr -> expr > expr .)
    ]               reduce using rule 35 (expr -> expr > expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    $               shift and go to state 55

  ! +               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! %               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! $               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 88

    (36) expr -> expr < expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 36 (expr -> expr < expr .)
    OR              reduce using rule 36 (expr -> expr < expr .)
    AND             reduce using rule 36 (expr -> expr < expr .)
    >               reduce using rule 36 (expr -> expr < expr .)
    <               reduce using rule 36 (expr -> expr < expr .)
    GTE             reduce using rule 36 (expr -> expr < expr .)
    LTE             reduce using rule 36 (expr -> expr < expr .)
    EQ              reduce using rule 36 (expr -> expr < expr .)
    NEQ             reduce using rule 36 (expr -> expr < expr .)
    [               reduce using rule 36 (expr -> expr < expr .)
    )               reduce using rule 36 (expr -> expr < expr .)
    ,               reduce using rule 36 (expr -> expr < expr .)
    ]               reduce using rule 36 (expr -> expr < expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    $               shift and go to state 55

  ! +               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! %               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! $               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 89

    (37) expr -> expr GTE expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 37 (expr -> expr GTE expr .)
    OR              reduce using rule 37 (expr -> expr GTE expr .)
    AND             reduce using rule 37 (expr -> expr GTE expr .)
    >               reduce using rule 37 (expr -> expr GTE expr .)
    <               reduce using rule 37 (expr -> expr GTE expr .)
    GTE             reduce using rule 37 (expr -> expr GTE expr .)
    LTE             reduce using rule 37 (expr -> expr GTE expr .)
    EQ              reduce using rule 37 (expr -> expr GTE expr .)
    NEQ             reduce using rule 37 (expr -> expr GTE expr .)
    [               reduce using rule 37 (expr -> expr GTE expr .)
    )               reduce using rule 37 (expr -> expr GTE expr .)
    ,               reduce using rule 37 (expr -> expr GTE expr .)
    ]               reduce using rule 37 (expr -> expr GTE expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    $               shift and go to state 55

  ! +               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! -               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! *               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! /               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! %               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! $               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 90

    (38) expr -> expr LTE expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 38 (expr -> expr LTE expr .)
    OR              reduce using rule 38 (expr -> expr LTE expr .)
    AND             reduce using rule 38 (expr -> expr LTE expr .)
    >               reduce using rule 38 (expr -> expr LTE expr .)
    <               reduce using rule 38 (expr -> expr LTE expr .)
    GTE             reduce using rule 38 (expr -> expr LTE expr .)
    LTE             reduce using rule 38 (expr -> expr LTE expr .)
    EQ              reduce using rule 38 (expr -> expr LTE expr .)
    NEQ             reduce using rule 38 (expr -> expr LTE expr .)
    [               reduce using rule 38 (expr -> expr LTE expr .)
    )               reduce using rule 38 (expr -> expr LTE expr .)
    ,               reduce using rule 38 (expr -> expr LTE expr .)
    ]               reduce using rule 38 (expr -> expr LTE expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    $               shift and go to state 55

  ! +               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! %               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! $               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 91

    (39) expr -> expr EQ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 39 (expr -> expr EQ expr .)
    OR              reduce using rule 39 (expr -> expr EQ expr .)
    AND             reduce using rule 39 (expr -> expr EQ expr .)
    EQ              reduce using rule 39 (expr -> expr EQ expr .)
    NEQ             reduce using rule 39 (expr -> expr EQ expr .)
    [               reduce using rule 39 (expr -> expr EQ expr .)
    )               reduce using rule 39 (expr -> expr EQ expr .)
    ,               reduce using rule 39 (expr -> expr EQ expr .)
    ]               reduce using rule 39 (expr -> expr EQ expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    $               shift and go to state 55

  ! +               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! %               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! >               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! <               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! GTE             [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! LTE             [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! $               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 92

    (40) expr -> expr NEQ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 40 (expr -> expr NEQ expr .)
    OR              reduce using rule 40 (expr -> expr NEQ expr .)
    AND             reduce using rule 40 (expr -> expr NEQ expr .)
    EQ              reduce using rule 40 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 40 (expr -> expr NEQ expr .)
    [               reduce using rule 40 (expr -> expr NEQ expr .)
    )               reduce using rule 40 (expr -> expr NEQ expr .)
    ,               reduce using rule 40 (expr -> expr NEQ expr .)
    ]               reduce using rule 40 (expr -> expr NEQ expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    $               shift and go to state 55

  ! +               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! %               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! >               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! <               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! GTE             [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! LTE             [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! $               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! [               [ shift and go to state 56 ]


state 93

    (41) expr -> expr $ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               reduce using rule 41 (expr -> expr $ expr .)
    +               reduce using rule 41 (expr -> expr $ expr .)
    -               reduce using rule 41 (expr -> expr $ expr .)
    OR              reduce using rule 41 (expr -> expr $ expr .)
    AND             reduce using rule 41 (expr -> expr $ expr .)
    >               reduce using rule 41 (expr -> expr $ expr .)
    <               reduce using rule 41 (expr -> expr $ expr .)
    GTE             reduce using rule 41 (expr -> expr $ expr .)
    LTE             reduce using rule 41 (expr -> expr $ expr .)
    EQ              reduce using rule 41 (expr -> expr $ expr .)
    NEQ             reduce using rule 41 (expr -> expr $ expr .)
    $               reduce using rule 41 (expr -> expr $ expr .)
    [               reduce using rule 41 (expr -> expr $ expr .)
    )               reduce using rule 41 (expr -> expr $ expr .)
    ,               reduce using rule 41 (expr -> expr $ expr .)
    ]               reduce using rule 41 (expr -> expr $ expr .)
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46

  ! *               [ reduce using rule 41 (expr -> expr $ expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr $ expr .) ]
  ! %               [ reduce using rule 41 (expr -> expr $ expr .) ]
  ! +               [ shift and go to state 42 ]
  ! -               [ shift and go to state 43 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 48 ]
  ! >               [ shift and go to state 49 ]
  ! <               [ shift and go to state 50 ]
  ! GTE             [ shift and go to state 51 ]
  ! LTE             [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 53 ]
  ! NEQ             [ shift and go to state 54 ]
  ! $               [ shift and go to state 55 ]
  ! [               [ shift and go to state 56 ]


state 94

    (45) expr -> expr [ expr . ]
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ]               shift and go to state 115
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 95

    (25) expr -> INPUT ( ) .

    ;               reduce using rule 25 (expr -> INPUT ( ) .)
    +               reduce using rule 25 (expr -> INPUT ( ) .)
    -               reduce using rule 25 (expr -> INPUT ( ) .)
    *               reduce using rule 25 (expr -> INPUT ( ) .)
    /               reduce using rule 25 (expr -> INPUT ( ) .)
    %               reduce using rule 25 (expr -> INPUT ( ) .)
    OR              reduce using rule 25 (expr -> INPUT ( ) .)
    AND             reduce using rule 25 (expr -> INPUT ( ) .)
    >               reduce using rule 25 (expr -> INPUT ( ) .)
    <               reduce using rule 25 (expr -> INPUT ( ) .)
    GTE             reduce using rule 25 (expr -> INPUT ( ) .)
    LTE             reduce using rule 25 (expr -> INPUT ( ) .)
    EQ              reduce using rule 25 (expr -> INPUT ( ) .)
    NEQ             reduce using rule 25 (expr -> INPUT ( ) .)
    $               reduce using rule 25 (expr -> INPUT ( ) .)
    [               reduce using rule 25 (expr -> INPUT ( ) .)
    )               reduce using rule 25 (expr -> INPUT ( ) .)
    ,               reduce using rule 25 (expr -> INPUT ( ) .)
    ]               reduce using rule 25 (expr -> INPUT ( ) .)


state 96

    (52) expr -> ( expr ) .

    ;               reduce using rule 52 (expr -> ( expr ) .)
    +               reduce using rule 52 (expr -> ( expr ) .)
    -               reduce using rule 52 (expr -> ( expr ) .)
    *               reduce using rule 52 (expr -> ( expr ) .)
    /               reduce using rule 52 (expr -> ( expr ) .)
    %               reduce using rule 52 (expr -> ( expr ) .)
    OR              reduce using rule 52 (expr -> ( expr ) .)
    AND             reduce using rule 52 (expr -> ( expr ) .)
    >               reduce using rule 52 (expr -> ( expr ) .)
    <               reduce using rule 52 (expr -> ( expr ) .)
    GTE             reduce using rule 52 (expr -> ( expr ) .)
    LTE             reduce using rule 52 (expr -> ( expr ) .)
    EQ              reduce using rule 52 (expr -> ( expr ) .)
    NEQ             reduce using rule 52 (expr -> ( expr ) .)
    $               reduce using rule 52 (expr -> ( expr ) .)
    [               reduce using rule 52 (expr -> ( expr ) .)
    )               reduce using rule 52 (expr -> ( expr ) .)
    ,               reduce using rule 52 (expr -> ( expr ) .)
    ]               reduce using rule 52 (expr -> ( expr ) .)


state 97

    (26) expr -> STR ( expr . )
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 116
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 98

    (27) expr -> ATOI ( expr . )
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 117
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 99

    (18) var_declare -> VAR ID [ NUM ] ; .

    VAR             reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    DEF             reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    PRINT           reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    PRINTLN         reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    WHILE           reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    IF              reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    ID              reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    RETURN          reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    PRINTI          reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    INPUT           reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    STR             reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    ATOI            reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    !               reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    -               reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    STRING          reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    NUM             reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    TRUE            reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    FALSE           reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    (               reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)
    $end            reduce using rule 18 (var_declare -> VAR ID [ NUM ] ; .)


state 100

    (7) stmt -> PRINT ( expr . ) ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 118
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 101

    (20) stmt -> expr [ expr . ] = expr ;
    (45) expr -> expr [ expr . ]
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ]               shift and go to state 119
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 102

    (8) stmt -> PRINTLN ( ) . ;

    ;               shift and go to state 120


state 103

    (9) stmt -> WHILE new_label ( . expr ) jz block
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 121

state 104

    (10) stmt -> IF ( expr . ) jz block
    (11) stmt -> IF ( expr . ) jz block ELSE jmp jz_label block
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 122
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 105

    (19) stmt -> ID = expr . ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               shift and go to state 123
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 106

    (21) stmt -> RETURN expr ; .

    PRINT           reduce using rule 21 (stmt -> RETURN expr ; .)
    PRINTLN         reduce using rule 21 (stmt -> RETURN expr ; .)
    WHILE           reduce using rule 21 (stmt -> RETURN expr ; .)
    IF              reduce using rule 21 (stmt -> RETURN expr ; .)
    ID              reduce using rule 21 (stmt -> RETURN expr ; .)
    RETURN          reduce using rule 21 (stmt -> RETURN expr ; .)
    PRINTI          reduce using rule 21 (stmt -> RETURN expr ; .)
    INPUT           reduce using rule 21 (stmt -> RETURN expr ; .)
    STR             reduce using rule 21 (stmt -> RETURN expr ; .)
    ATOI            reduce using rule 21 (stmt -> RETURN expr ; .)
    !               reduce using rule 21 (stmt -> RETURN expr ; .)
    -               reduce using rule 21 (stmt -> RETURN expr ; .)
    STRING          reduce using rule 21 (stmt -> RETURN expr ; .)
    NUM             reduce using rule 21 (stmt -> RETURN expr ; .)
    TRUE            reduce using rule 21 (stmt -> RETURN expr ; .)
    FALSE           reduce using rule 21 (stmt -> RETURN expr ; .)
    (               reduce using rule 21 (stmt -> RETURN expr ; .)
    $end            reduce using rule 21 (stmt -> RETURN expr ; .)
    DEF             reduce using rule 21 (stmt -> RETURN expr ; .)
    }               reduce using rule 21 (stmt -> RETURN expr ; .)
    ELSE            reduce using rule 21 (stmt -> RETURN expr ; .)


state 107

    (23) stmt -> PRINTI ( expr . ) ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 124
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 108

    (4) fun -> DEF fun_name ( idlist ) . block
    (63) block -> . { stmtlist }
    (64) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . expr [ expr ] = expr ;
    (21) stmt -> . RETURN expr ;
    (22) stmt -> . RETURN ;
    (23) stmt -> . PRINTI ( expr ) ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    {               shift and go to state 111
    PRINT           shift and go to state 31
    PRINTLN         shift and go to state 33
    WHILE           shift and go to state 34
    IF              shift and go to state 35
    ID              shift and go to state 36
    RETURN          shift and go to state 37
    PRINTI          shift and go to state 38
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    block                          shift and go to state 125
    stmt                           shift and go to state 112
    expr                           shift and go to state 32

state 109

    (59) idlist -> idlist , . ID

    ID              shift and go to state 126


state 110

    (5) fun -> DEF fun_name ( ) block .

    DEF             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINT           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINTLN         reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    WHILE           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    IF              reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    ID              reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    RETURN          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    PRINTI          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    INPUT           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    STR             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    ATOI            reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    !               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    -               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    STRING          reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    NUM             reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    TRUE            reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    FALSE           reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    (               reduce using rule 5 (fun -> DEF fun_name ( ) block .)
    $end            reduce using rule 5 (fun -> DEF fun_name ( ) block .)


state 111

    (63) block -> { . stmtlist }
    (57) stmtlist -> . stmtlist stmt
    (58) stmtlist -> .

    }               reduce using rule 58 (stmtlist -> .)
    PRINT           reduce using rule 58 (stmtlist -> .)
    PRINTLN         reduce using rule 58 (stmtlist -> .)
    WHILE           reduce using rule 58 (stmtlist -> .)
    IF              reduce using rule 58 (stmtlist -> .)
    ID              reduce using rule 58 (stmtlist -> .)
    RETURN          reduce using rule 58 (stmtlist -> .)
    PRINTI          reduce using rule 58 (stmtlist -> .)
    INPUT           reduce using rule 58 (stmtlist -> .)
    STR             reduce using rule 58 (stmtlist -> .)
    ATOI            reduce using rule 58 (stmtlist -> .)
    !               reduce using rule 58 (stmtlist -> .)
    -               reduce using rule 58 (stmtlist -> .)
    STRING          reduce using rule 58 (stmtlist -> .)
    NUM             reduce using rule 58 (stmtlist -> .)
    TRUE            reduce using rule 58 (stmtlist -> .)
    FALSE           reduce using rule 58 (stmtlist -> .)
    (               reduce using rule 58 (stmtlist -> .)

    stmtlist                       shift and go to state 127

state 112

    (64) block -> stmt .

    DEF             reduce using rule 64 (block -> stmt .)
    PRINT           reduce using rule 64 (block -> stmt .)
    PRINTLN         reduce using rule 64 (block -> stmt .)
    WHILE           reduce using rule 64 (block -> stmt .)
    IF              reduce using rule 64 (block -> stmt .)
    ID              reduce using rule 64 (block -> stmt .)
    RETURN          reduce using rule 64 (block -> stmt .)
    PRINTI          reduce using rule 64 (block -> stmt .)
    INPUT           reduce using rule 64 (block -> stmt .)
    STR             reduce using rule 64 (block -> stmt .)
    ATOI            reduce using rule 64 (block -> stmt .)
    !               reduce using rule 64 (block -> stmt .)
    -               reduce using rule 64 (block -> stmt .)
    STRING          reduce using rule 64 (block -> stmt .)
    NUM             reduce using rule 64 (block -> stmt .)
    TRUE            reduce using rule 64 (block -> stmt .)
    FALSE           reduce using rule 64 (block -> stmt .)
    (               reduce using rule 64 (block -> stmt .)
    $end            reduce using rule 64 (block -> stmt .)
    ELSE            reduce using rule 64 (block -> stmt .)
    }               reduce using rule 64 (block -> stmt .)


state 113

    (50) expr -> ID ( exprlist ) .

    ;               reduce using rule 50 (expr -> ID ( exprlist ) .)
    +               reduce using rule 50 (expr -> ID ( exprlist ) .)
    -               reduce using rule 50 (expr -> ID ( exprlist ) .)
    *               reduce using rule 50 (expr -> ID ( exprlist ) .)
    /               reduce using rule 50 (expr -> ID ( exprlist ) .)
    %               reduce using rule 50 (expr -> ID ( exprlist ) .)
    OR              reduce using rule 50 (expr -> ID ( exprlist ) .)
    AND             reduce using rule 50 (expr -> ID ( exprlist ) .)
    >               reduce using rule 50 (expr -> ID ( exprlist ) .)
    <               reduce using rule 50 (expr -> ID ( exprlist ) .)
    GTE             reduce using rule 50 (expr -> ID ( exprlist ) .)
    LTE             reduce using rule 50 (expr -> ID ( exprlist ) .)
    EQ              reduce using rule 50 (expr -> ID ( exprlist ) .)
    NEQ             reduce using rule 50 (expr -> ID ( exprlist ) .)
    $               reduce using rule 50 (expr -> ID ( exprlist ) .)
    [               reduce using rule 50 (expr -> ID ( exprlist ) .)
    )               reduce using rule 50 (expr -> ID ( exprlist ) .)
    ,               reduce using rule 50 (expr -> ID ( exprlist ) .)
    ]               reduce using rule 50 (expr -> ID ( exprlist ) .)


state 114

    (61) exprlist -> exprlist , . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 128

state 115

    (45) expr -> expr [ expr ] .

    ;               reduce using rule 45 (expr -> expr [ expr ] .)
    +               reduce using rule 45 (expr -> expr [ expr ] .)
    -               reduce using rule 45 (expr -> expr [ expr ] .)
    *               reduce using rule 45 (expr -> expr [ expr ] .)
    /               reduce using rule 45 (expr -> expr [ expr ] .)
    %               reduce using rule 45 (expr -> expr [ expr ] .)
    OR              reduce using rule 45 (expr -> expr [ expr ] .)
    AND             reduce using rule 45 (expr -> expr [ expr ] .)
    >               reduce using rule 45 (expr -> expr [ expr ] .)
    <               reduce using rule 45 (expr -> expr [ expr ] .)
    GTE             reduce using rule 45 (expr -> expr [ expr ] .)
    LTE             reduce using rule 45 (expr -> expr [ expr ] .)
    EQ              reduce using rule 45 (expr -> expr [ expr ] .)
    NEQ             reduce using rule 45 (expr -> expr [ expr ] .)
    $               reduce using rule 45 (expr -> expr [ expr ] .)
    [               reduce using rule 45 (expr -> expr [ expr ] .)
    )               reduce using rule 45 (expr -> expr [ expr ] .)
    ,               reduce using rule 45 (expr -> expr [ expr ] .)
    ]               reduce using rule 45 (expr -> expr [ expr ] .)


state 116

    (26) expr -> STR ( expr ) .

    ;               reduce using rule 26 (expr -> STR ( expr ) .)
    +               reduce using rule 26 (expr -> STR ( expr ) .)
    -               reduce using rule 26 (expr -> STR ( expr ) .)
    *               reduce using rule 26 (expr -> STR ( expr ) .)
    /               reduce using rule 26 (expr -> STR ( expr ) .)
    %               reduce using rule 26 (expr -> STR ( expr ) .)
    OR              reduce using rule 26 (expr -> STR ( expr ) .)
    AND             reduce using rule 26 (expr -> STR ( expr ) .)
    >               reduce using rule 26 (expr -> STR ( expr ) .)
    <               reduce using rule 26 (expr -> STR ( expr ) .)
    GTE             reduce using rule 26 (expr -> STR ( expr ) .)
    LTE             reduce using rule 26 (expr -> STR ( expr ) .)
    EQ              reduce using rule 26 (expr -> STR ( expr ) .)
    NEQ             reduce using rule 26 (expr -> STR ( expr ) .)
    $               reduce using rule 26 (expr -> STR ( expr ) .)
    [               reduce using rule 26 (expr -> STR ( expr ) .)
    )               reduce using rule 26 (expr -> STR ( expr ) .)
    ,               reduce using rule 26 (expr -> STR ( expr ) .)
    ]               reduce using rule 26 (expr -> STR ( expr ) .)


state 117

    (27) expr -> ATOI ( expr ) .

    ;               reduce using rule 27 (expr -> ATOI ( expr ) .)
    +               reduce using rule 27 (expr -> ATOI ( expr ) .)
    -               reduce using rule 27 (expr -> ATOI ( expr ) .)
    *               reduce using rule 27 (expr -> ATOI ( expr ) .)
    /               reduce using rule 27 (expr -> ATOI ( expr ) .)
    %               reduce using rule 27 (expr -> ATOI ( expr ) .)
    OR              reduce using rule 27 (expr -> ATOI ( expr ) .)
    AND             reduce using rule 27 (expr -> ATOI ( expr ) .)
    >               reduce using rule 27 (expr -> ATOI ( expr ) .)
    <               reduce using rule 27 (expr -> ATOI ( expr ) .)
    GTE             reduce using rule 27 (expr -> ATOI ( expr ) .)
    LTE             reduce using rule 27 (expr -> ATOI ( expr ) .)
    EQ              reduce using rule 27 (expr -> ATOI ( expr ) .)
    NEQ             reduce using rule 27 (expr -> ATOI ( expr ) .)
    $               reduce using rule 27 (expr -> ATOI ( expr ) .)
    [               reduce using rule 27 (expr -> ATOI ( expr ) .)
    )               reduce using rule 27 (expr -> ATOI ( expr ) .)
    ,               reduce using rule 27 (expr -> ATOI ( expr ) .)
    ]               reduce using rule 27 (expr -> ATOI ( expr ) .)


state 118

    (7) stmt -> PRINT ( expr ) . ;

    ;               shift and go to state 129


state 119

    (20) stmt -> expr [ expr ] . = expr ;
    (45) expr -> expr [ expr ] .

    =               shift and go to state 130
    [               reduce using rule 45 (expr -> expr [ expr ] .)
    ;               reduce using rule 45 (expr -> expr [ expr ] .)
    +               reduce using rule 45 (expr -> expr [ expr ] .)
    -               reduce using rule 45 (expr -> expr [ expr ] .)
    *               reduce using rule 45 (expr -> expr [ expr ] .)
    /               reduce using rule 45 (expr -> expr [ expr ] .)
    %               reduce using rule 45 (expr -> expr [ expr ] .)
    OR              reduce using rule 45 (expr -> expr [ expr ] .)
    AND             reduce using rule 45 (expr -> expr [ expr ] .)
    >               reduce using rule 45 (expr -> expr [ expr ] .)
    <               reduce using rule 45 (expr -> expr [ expr ] .)
    GTE             reduce using rule 45 (expr -> expr [ expr ] .)
    LTE             reduce using rule 45 (expr -> expr [ expr ] .)
    EQ              reduce using rule 45 (expr -> expr [ expr ] .)
    NEQ             reduce using rule 45 (expr -> expr [ expr ] .)
    $               reduce using rule 45 (expr -> expr [ expr ] .)


state 120

    (8) stmt -> PRINTLN ( ) ; .

    PRINT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    PRINTLN         reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    WHILE           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    IF              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ID              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    RETURN          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    PRINTI          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    INPUT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STR             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ATOI            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    !               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    -               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STRING          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    NUM             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    TRUE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    FALSE           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    (               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    $end            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    DEF             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    }               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ELSE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)


state 121

    (9) stmt -> WHILE new_label ( expr . ) jz block
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 131
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 122

    (10) stmt -> IF ( expr ) . jz block
    (11) stmt -> IF ( expr ) . jz block ELSE jmp jz_label block
    (13) jz -> .

    {               reduce using rule 13 (jz -> .)
    PRINT           reduce using rule 13 (jz -> .)
    PRINTLN         reduce using rule 13 (jz -> .)
    WHILE           reduce using rule 13 (jz -> .)
    IF              reduce using rule 13 (jz -> .)
    ID              reduce using rule 13 (jz -> .)
    RETURN          reduce using rule 13 (jz -> .)
    PRINTI          reduce using rule 13 (jz -> .)
    INPUT           reduce using rule 13 (jz -> .)
    STR             reduce using rule 13 (jz -> .)
    ATOI            reduce using rule 13 (jz -> .)
    !               reduce using rule 13 (jz -> .)
    -               reduce using rule 13 (jz -> .)
    STRING          reduce using rule 13 (jz -> .)
    NUM             reduce using rule 13 (jz -> .)
    TRUE            reduce using rule 13 (jz -> .)
    FALSE           reduce using rule 13 (jz -> .)
    (               reduce using rule 13 (jz -> .)

    jz                             shift and go to state 132

state 123

    (19) stmt -> ID = expr ; .

    PRINT           reduce using rule 19 (stmt -> ID = expr ; .)
    PRINTLN         reduce using rule 19 (stmt -> ID = expr ; .)
    WHILE           reduce using rule 19 (stmt -> ID = expr ; .)
    IF              reduce using rule 19 (stmt -> ID = expr ; .)
    ID              reduce using rule 19 (stmt -> ID = expr ; .)
    RETURN          reduce using rule 19 (stmt -> ID = expr ; .)
    PRINTI          reduce using rule 19 (stmt -> ID = expr ; .)
    INPUT           reduce using rule 19 (stmt -> ID = expr ; .)
    STR             reduce using rule 19 (stmt -> ID = expr ; .)
    ATOI            reduce using rule 19 (stmt -> ID = expr ; .)
    !               reduce using rule 19 (stmt -> ID = expr ; .)
    -               reduce using rule 19 (stmt -> ID = expr ; .)
    STRING          reduce using rule 19 (stmt -> ID = expr ; .)
    NUM             reduce using rule 19 (stmt -> ID = expr ; .)
    TRUE            reduce using rule 19 (stmt -> ID = expr ; .)
    FALSE           reduce using rule 19 (stmt -> ID = expr ; .)
    (               reduce using rule 19 (stmt -> ID = expr ; .)
    $end            reduce using rule 19 (stmt -> ID = expr ; .)
    DEF             reduce using rule 19 (stmt -> ID = expr ; .)
    }               reduce using rule 19 (stmt -> ID = expr ; .)
    ELSE            reduce using rule 19 (stmt -> ID = expr ; .)


state 124

    (23) stmt -> PRINTI ( expr ) . ;

    ;               shift and go to state 133


state 125

    (4) fun -> DEF fun_name ( idlist ) block .

    DEF             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINT           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINTLN         reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    WHILE           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    IF              reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    ID              reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    RETURN          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    PRINTI          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    INPUT           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    STR             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    ATOI            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    !               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    -               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    STRING          reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    NUM             reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    TRUE            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    FALSE           reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    (               reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)
    $end            reduce using rule 4 (fun -> DEF fun_name ( idlist ) block .)


state 126

    (59) idlist -> idlist , ID .

    )               reduce using rule 59 (idlist -> idlist , ID .)
    ,               reduce using rule 59 (idlist -> idlist , ID .)


state 127

    (63) block -> { stmtlist . }
    (57) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . expr [ expr ] = expr ;
    (21) stmt -> . RETURN expr ;
    (22) stmt -> . RETURN ;
    (23) stmt -> . PRINTI ( expr ) ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    }               shift and go to state 134
    PRINT           shift and go to state 31
    PRINTLN         shift and go to state 33
    WHILE           shift and go to state 34
    IF              shift and go to state 35
    ID              shift and go to state 36
    RETURN          shift and go to state 37
    PRINTI          shift and go to state 38
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    stmt                           shift and go to state 30
    expr                           shift and go to state 32

state 128

    (61) exprlist -> exprlist , expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               reduce using rule 61 (exprlist -> exprlist , expr .)
    ,               reduce using rule 61 (exprlist -> exprlist , expr .)
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 129

    (7) stmt -> PRINT ( expr ) ; .

    PRINT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    PRINTLN         reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    WHILE           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    IF              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ID              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    RETURN          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    PRINTI          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    INPUT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STR             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ATOI            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    !               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    -               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STRING          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    NUM             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    TRUE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    FALSE           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    (               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    $end            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    DEF             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    }               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ELSE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)


state 130

    (20) stmt -> expr [ expr ] = . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    ID              shift and go to state 17
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 135

state 131

    (9) stmt -> WHILE new_label ( expr ) . jz block
    (13) jz -> .

    {               reduce using rule 13 (jz -> .)
    PRINT           reduce using rule 13 (jz -> .)
    PRINTLN         reduce using rule 13 (jz -> .)
    WHILE           reduce using rule 13 (jz -> .)
    IF              reduce using rule 13 (jz -> .)
    ID              reduce using rule 13 (jz -> .)
    RETURN          reduce using rule 13 (jz -> .)
    PRINTI          reduce using rule 13 (jz -> .)
    INPUT           reduce using rule 13 (jz -> .)
    STR             reduce using rule 13 (jz -> .)
    ATOI            reduce using rule 13 (jz -> .)
    !               reduce using rule 13 (jz -> .)
    -               reduce using rule 13 (jz -> .)
    STRING          reduce using rule 13 (jz -> .)
    NUM             reduce using rule 13 (jz -> .)
    TRUE            reduce using rule 13 (jz -> .)
    FALSE           reduce using rule 13 (jz -> .)
    (               reduce using rule 13 (jz -> .)

    jz                             shift and go to state 136

state 132

    (10) stmt -> IF ( expr ) jz . block
    (11) stmt -> IF ( expr ) jz . block ELSE jmp jz_label block
    (63) block -> . { stmtlist }
    (64) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . expr [ expr ] = expr ;
    (21) stmt -> . RETURN expr ;
    (22) stmt -> . RETURN ;
    (23) stmt -> . PRINTI ( expr ) ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    {               shift and go to state 111
    PRINT           shift and go to state 31
    PRINTLN         shift and go to state 33
    WHILE           shift and go to state 34
    IF              shift and go to state 35
    ID              shift and go to state 36
    RETURN          shift and go to state 37
    PRINTI          shift and go to state 38
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 32
    block                          shift and go to state 137
    stmt                           shift and go to state 112

state 133

    (23) stmt -> PRINTI ( expr ) ; .

    PRINT           reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    PRINTLN         reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    WHILE           reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    IF              reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    ID              reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    RETURN          reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    PRINTI          reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    INPUT           reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    STR             reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    ATOI            reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    !               reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    -               reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    STRING          reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    NUM             reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    TRUE            reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    FALSE           reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    (               reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    $end            reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    DEF             reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    }               reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)
    ELSE            reduce using rule 23 (stmt -> PRINTI ( expr ) ; .)


state 134

    (63) block -> { stmtlist } .

    DEF             reduce using rule 63 (block -> { stmtlist } .)
    PRINT           reduce using rule 63 (block -> { stmtlist } .)
    PRINTLN         reduce using rule 63 (block -> { stmtlist } .)
    WHILE           reduce using rule 63 (block -> { stmtlist } .)
    IF              reduce using rule 63 (block -> { stmtlist } .)
    ID              reduce using rule 63 (block -> { stmtlist } .)
    RETURN          reduce using rule 63 (block -> { stmtlist } .)
    PRINTI          reduce using rule 63 (block -> { stmtlist } .)
    INPUT           reduce using rule 63 (block -> { stmtlist } .)
    STR             reduce using rule 63 (block -> { stmtlist } .)
    ATOI            reduce using rule 63 (block -> { stmtlist } .)
    !               reduce using rule 63 (block -> { stmtlist } .)
    -               reduce using rule 63 (block -> { stmtlist } .)
    STRING          reduce using rule 63 (block -> { stmtlist } .)
    NUM             reduce using rule 63 (block -> { stmtlist } .)
    TRUE            reduce using rule 63 (block -> { stmtlist } .)
    FALSE           reduce using rule 63 (block -> { stmtlist } .)
    (               reduce using rule 63 (block -> { stmtlist } .)
    $end            reduce using rule 63 (block -> { stmtlist } .)
    ELSE            reduce using rule 63 (block -> { stmtlist } .)
    }               reduce using rule 63 (block -> { stmtlist } .)


state 135

    (20) stmt -> expr [ expr ] = expr . ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               shift and go to state 138
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    %               shift and go to state 46
    OR              shift and go to state 47
    AND             shift and go to state 48
    >               shift and go to state 49
    <               shift and go to state 50
    GTE             shift and go to state 51
    LTE             shift and go to state 52
    EQ              shift and go to state 53
    NEQ             shift and go to state 54
    $               shift and go to state 55
    [               shift and go to state 56


state 136

    (9) stmt -> WHILE new_label ( expr ) jz . block
    (63) block -> . { stmtlist }
    (64) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . expr [ expr ] = expr ;
    (21) stmt -> . RETURN expr ;
    (22) stmt -> . RETURN ;
    (23) stmt -> . PRINTI ( expr ) ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    {               shift and go to state 111
    PRINT           shift and go to state 31
    PRINTLN         shift and go to state 33
    WHILE           shift and go to state 34
    IF              shift and go to state 35
    ID              shift and go to state 36
    RETURN          shift and go to state 37
    PRINTI          shift and go to state 38
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 32
    block                          shift and go to state 139
    stmt                           shift and go to state 112

state 137

    (10) stmt -> IF ( expr ) jz block .
    (11) stmt -> IF ( expr ) jz block . ELSE jmp jz_label block

  ! shift/reduce conflict for ELSE resolved as shift
    PRINT           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    PRINTLN         reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    WHILE           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    IF              reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ID              reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    RETURN          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    PRINTI          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    INPUT           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    STR             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ATOI            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    !               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    -               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    STRING          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    NUM             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    TRUE            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    FALSE           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    (               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    $end            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    DEF             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    }               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ELSE            shift and go to state 140

  ! ELSE            [ reduce using rule 10 (stmt -> IF ( expr ) jz block .) ]


state 138

    (20) stmt -> expr [ expr ] = expr ; .

    PRINT           reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    PRINTLN         reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    WHILE           reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    IF              reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    ID              reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    RETURN          reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    PRINTI          reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    INPUT           reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    STR             reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    ATOI            reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    !               reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    -               reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    STRING          reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    NUM             reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    TRUE            reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    FALSE           reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    (               reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    $end            reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    DEF             reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    }               reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)
    ELSE            reduce using rule 20 (stmt -> expr [ expr ] = expr ; .)


state 139

    (9) stmt -> WHILE new_label ( expr ) jz block .

    PRINT           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    PRINTLN         reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    WHILE           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    IF              reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ID              reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    RETURN          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    PRINTI          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    INPUT           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    STR             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ATOI            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    !               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    -               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    STRING          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    NUM             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    TRUE            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    FALSE           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    (               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    $end            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    DEF             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    }               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ELSE            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)


state 140

    (11) stmt -> IF ( expr ) jz block ELSE . jmp jz_label block
    (12) jmp -> .

    {               reduce using rule 12 (jmp -> .)
    PRINT           reduce using rule 12 (jmp -> .)
    PRINTLN         reduce using rule 12 (jmp -> .)
    WHILE           reduce using rule 12 (jmp -> .)
    IF              reduce using rule 12 (jmp -> .)
    ID              reduce using rule 12 (jmp -> .)
    RETURN          reduce using rule 12 (jmp -> .)
    PRINTI          reduce using rule 12 (jmp -> .)
    INPUT           reduce using rule 12 (jmp -> .)
    STR             reduce using rule 12 (jmp -> .)
    ATOI            reduce using rule 12 (jmp -> .)
    !               reduce using rule 12 (jmp -> .)
    -               reduce using rule 12 (jmp -> .)
    STRING          reduce using rule 12 (jmp -> .)
    NUM             reduce using rule 12 (jmp -> .)
    TRUE            reduce using rule 12 (jmp -> .)
    FALSE           reduce using rule 12 (jmp -> .)
    (               reduce using rule 12 (jmp -> .)

    jmp                            shift and go to state 141

state 141

    (11) stmt -> IF ( expr ) jz block ELSE jmp . jz_label block
    (14) jz_label -> .

    {               reduce using rule 14 (jz_label -> .)
    PRINT           reduce using rule 14 (jz_label -> .)
    PRINTLN         reduce using rule 14 (jz_label -> .)
    WHILE           reduce using rule 14 (jz_label -> .)
    IF              reduce using rule 14 (jz_label -> .)
    ID              reduce using rule 14 (jz_label -> .)
    RETURN          reduce using rule 14 (jz_label -> .)
    PRINTI          reduce using rule 14 (jz_label -> .)
    INPUT           reduce using rule 14 (jz_label -> .)
    STR             reduce using rule 14 (jz_label -> .)
    ATOI            reduce using rule 14 (jz_label -> .)
    !               reduce using rule 14 (jz_label -> .)
    -               reduce using rule 14 (jz_label -> .)
    STRING          reduce using rule 14 (jz_label -> .)
    NUM             reduce using rule 14 (jz_label -> .)
    TRUE            reduce using rule 14 (jz_label -> .)
    FALSE           reduce using rule 14 (jz_label -> .)
    (               reduce using rule 14 (jz_label -> .)

    jz_label                       shift and go to state 142

state 142

    (11) stmt -> IF ( expr ) jz block ELSE jmp jz_label . block
    (63) block -> . { stmtlist }
    (64) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (19) stmt -> . ID = expr ;
    (20) stmt -> . expr [ expr ] = expr ;
    (21) stmt -> . RETURN expr ;
    (22) stmt -> . RETURN ;
    (23) stmt -> . PRINTI ( expr ) ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . TRUE
    (49) expr -> . FALSE
    (50) expr -> . ID ( exprlist )
    (51) expr -> . ID ( )
    (52) expr -> . ( expr )

    {               shift and go to state 111
    PRINT           shift and go to state 31
    PRINTLN         shift and go to state 33
    WHILE           shift and go to state 34
    IF              shift and go to state 35
    ID              shift and go to state 36
    RETURN          shift and go to state 37
    PRINTI          shift and go to state 38
    INPUT           shift and go to state 19
    STR             shift and go to state 21
    ATOI            shift and go to state 22
    !               shift and go to state 24
    -               shift and go to state 23
    STRING          shift and go to state 25
    NUM             shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    (               shift and go to state 20

    expr                           shift and go to state 32
    block                          shift and go to state 143
    stmt                           shift and go to state 112

state 143

    (11) stmt -> IF ( expr ) jz block ELSE jmp jz_label block .

    PRINT           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    PRINTLN         reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    WHILE           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    IF              reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ID              reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    RETURN          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    PRINTI          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    INPUT           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STR             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ATOI            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    !               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    -               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STRING          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    NUM             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    TRUE            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    FALSE           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    (               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    $end            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    DEF             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    }               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ELSE            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 137 resolved as shift
