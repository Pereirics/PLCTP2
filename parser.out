Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declist start funlist entrypoint stmtlist
Rule 2     start -> <empty>
Rule 3     entrypoint -> <empty>
Rule 4     fun -> DEF fun_name ( funargs ) ftype { stmtlist }
Rule 5     fun_name -> ID
Rule 6     ftype -> type
Rule 7     stmt -> PRINT ( expr ) ;
Rule 8     stmt -> PRINTLN ( ) ;
Rule 9     stmt -> WHILE new_label ( expr ) jz block
Rule 10    stmt -> IF ( expr ) jz block
Rule 11    stmt -> IF ( expr ) jz block ELSE jmp jz_label block
Rule 12    jmp -> <empty>
Rule 13    jz -> <empty>
Rule 14    jz_label -> <empty>
Rule 15    new_label -> <empty>
Rule 16    var_declare -> VAR ID [ NUM ] type ;
Rule 17    var_declare -> VAR ID [ NUM ] [ NUM ] type ;
Rule 18    var_declare -> VAR ID type = expr ;
Rule 19    var_declare -> VAR ID type ;
Rule 20    stmt -> ID = expr ;
Rule 21    stmt -> expr [ expr ] = expr ;
Rule 22    stmt -> RETURN expr ;
Rule 23    stmt -> RETURN ;
Rule 24    stmt -> expr ;
Rule 25    expr -> INPUT ( )
Rule 26    expr -> STR ( expr )
Rule 27    expr -> ATOI ( expr )
Rule 28    expr -> expr + expr
Rule 29    expr -> expr - expr
Rule 30    expr -> expr * expr
Rule 31    expr -> expr / expr
Rule 32    expr -> expr % expr
Rule 33    expr -> expr OR expr
Rule 34    expr -> expr AND expr
Rule 35    expr -> expr > expr
Rule 36    expr -> expr < expr
Rule 37    expr -> expr GTE expr
Rule 38    expr -> expr LTE expr
Rule 39    expr -> expr EQ expr
Rule 40    expr -> expr NEQ expr
Rule 41    expr -> expr $ expr
Rule 42    expr -> ! expr
Rule 43    expr -> - expr
Rule 44    expr -> ID
Rule 45    expr -> expr [ expr ]
Rule 46    expr -> STRING
Rule 47    expr -> NUM
Rule 48    expr -> ID ( fcall )
Rule 49    expr -> ( expr )
Rule 50    type -> STRINGTYPE
Rule 51    type -> INTTYPE
Rule 52    type -> VOIDTYPE
Rule 53    type -> [ type ]
Rule 54    declist -> declist var_declare
Rule 55    declist -> <empty>
Rule 56    funlist -> funlist fun
Rule 57    funlist -> <empty>
Rule 58    stmtlist -> stmtlist stmt
Rule 59    stmtlist -> <empty>
Rule 60    funargs -> idlist
Rule 61    funargs -> <empty>
Rule 62    idlist -> idlist , ID type
Rule 63    idlist -> ID type
Rule 64    fcall -> exprlist
Rule 65    fcall -> <empty>
Rule 66    exprlist -> exprlist , expr
Rule 67    exprlist -> expr
Rule 68    block -> { stmtlist }
Rule 69    block -> stmt

Terminals, with rules where they appear

!                    : 42
$                    : 41
%                    : 32
(                    : 4 7 8 9 10 11 25 26 27 48 49
)                    : 4 7 8 9 10 11 25 26 27 48 49
*                    : 30
+                    : 28
,                    : 62 66
-                    : 29 43
/                    : 31
;                    : 7 8 16 17 18 19 20 21 22 23 24
<                    : 36
=                    : 18 20 21
>                    : 35
AND                  : 34
ATOI                 : 27
DEF                  : 4
ELSE                 : 11
EQ                   : 39
GTE                  : 37
ID                   : 5 16 17 18 19 20 44 48 62 63
IF                   : 10 11
INPUT                : 25
INTTYPE              : 51
LTE                  : 38
NEQ                  : 40
NUM                  : 16 17 17 47
OR                   : 33
PRINT                : 7
PRINTLN              : 8
RETURN               : 22 23
STR                  : 26
STRING               : 46
STRINGTYPE           : 50
VAR                  : 16 17 18 19
VOIDTYPE             : 52
WHILE                : 9
[                    : 16 17 17 21 45 53
]                    : 16 17 17 21 45 53
error                : 
{                    : 4 68
}                    : 4 68

Nonterminals, with rules where they appear

block                : 9 10 11 11
declist              : 1 54
entrypoint           : 1
expr                 : 7 9 10 11 18 20 21 21 21 22 24 26 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 43 45 45 49 66 67
exprlist             : 64 66
fcall                : 48
ftype                : 4
fun                  : 56
fun_name             : 4
funargs              : 4
funlist              : 1 56
idlist               : 60 62
jmp                  : 11
jz                   : 9 10 11
jz_label             : 11
new_label            : 9
program              : 0
start                : 1
stmt                 : 58 69
stmtlist             : 1 4 58 68
type                 : 6 16 17 18 19 53 62 63
var_declare          : 54

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declist start funlist entrypoint stmtlist
    (54) declist -> . declist var_declare
    (55) declist -> .

    VAR             reduce using rule 55 (declist -> .)
    DEF             reduce using rule 55 (declist -> .)
    PRINT           reduce using rule 55 (declist -> .)
    PRINTLN         reduce using rule 55 (declist -> .)
    WHILE           reduce using rule 55 (declist -> .)
    IF              reduce using rule 55 (declist -> .)
    ID              reduce using rule 55 (declist -> .)
    RETURN          reduce using rule 55 (declist -> .)
    INPUT           reduce using rule 55 (declist -> .)
    STR             reduce using rule 55 (declist -> .)
    ATOI            reduce using rule 55 (declist -> .)
    !               reduce using rule 55 (declist -> .)
    -               reduce using rule 55 (declist -> .)
    STRING          reduce using rule 55 (declist -> .)
    NUM             reduce using rule 55 (declist -> .)
    (               reduce using rule 55 (declist -> .)
    $end            reduce using rule 55 (declist -> .)

    program                        shift and go to state 1
    declist                        shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> declist . start funlist entrypoint stmtlist
    (54) declist -> declist . var_declare
    (2) start -> .
    (16) var_declare -> . VAR ID [ NUM ] type ;
    (17) var_declare -> . VAR ID [ NUM ] [ NUM ] type ;
    (18) var_declare -> . VAR ID type = expr ;
    (19) var_declare -> . VAR ID type ;

    DEF             reduce using rule 2 (start -> .)
    PRINT           reduce using rule 2 (start -> .)
    PRINTLN         reduce using rule 2 (start -> .)
    WHILE           reduce using rule 2 (start -> .)
    IF              reduce using rule 2 (start -> .)
    ID              reduce using rule 2 (start -> .)
    RETURN          reduce using rule 2 (start -> .)
    INPUT           reduce using rule 2 (start -> .)
    STR             reduce using rule 2 (start -> .)
    ATOI            reduce using rule 2 (start -> .)
    !               reduce using rule 2 (start -> .)
    -               reduce using rule 2 (start -> .)
    STRING          reduce using rule 2 (start -> .)
    NUM             reduce using rule 2 (start -> .)
    (               reduce using rule 2 (start -> .)
    $end            reduce using rule 2 (start -> .)
    VAR             shift and go to state 5

    start                          shift and go to state 3
    var_declare                    shift and go to state 4

state 3

    (1) program -> declist start . funlist entrypoint stmtlist
    (56) funlist -> . funlist fun
    (57) funlist -> .

    DEF             reduce using rule 57 (funlist -> .)
    PRINT           reduce using rule 57 (funlist -> .)
    PRINTLN         reduce using rule 57 (funlist -> .)
    WHILE           reduce using rule 57 (funlist -> .)
    IF              reduce using rule 57 (funlist -> .)
    ID              reduce using rule 57 (funlist -> .)
    RETURN          reduce using rule 57 (funlist -> .)
    INPUT           reduce using rule 57 (funlist -> .)
    STR             reduce using rule 57 (funlist -> .)
    ATOI            reduce using rule 57 (funlist -> .)
    !               reduce using rule 57 (funlist -> .)
    -               reduce using rule 57 (funlist -> .)
    STRING          reduce using rule 57 (funlist -> .)
    NUM             reduce using rule 57 (funlist -> .)
    (               reduce using rule 57 (funlist -> .)
    $end            reduce using rule 57 (funlist -> .)

    funlist                        shift and go to state 6

state 4

    (54) declist -> declist var_declare .

    VAR             reduce using rule 54 (declist -> declist var_declare .)
    DEF             reduce using rule 54 (declist -> declist var_declare .)
    PRINT           reduce using rule 54 (declist -> declist var_declare .)
    PRINTLN         reduce using rule 54 (declist -> declist var_declare .)
    WHILE           reduce using rule 54 (declist -> declist var_declare .)
    IF              reduce using rule 54 (declist -> declist var_declare .)
    ID              reduce using rule 54 (declist -> declist var_declare .)
    RETURN          reduce using rule 54 (declist -> declist var_declare .)
    INPUT           reduce using rule 54 (declist -> declist var_declare .)
    STR             reduce using rule 54 (declist -> declist var_declare .)
    ATOI            reduce using rule 54 (declist -> declist var_declare .)
    !               reduce using rule 54 (declist -> declist var_declare .)
    -               reduce using rule 54 (declist -> declist var_declare .)
    STRING          reduce using rule 54 (declist -> declist var_declare .)
    NUM             reduce using rule 54 (declist -> declist var_declare .)
    (               reduce using rule 54 (declist -> declist var_declare .)
    $end            reduce using rule 54 (declist -> declist var_declare .)


state 5

    (16) var_declare -> VAR . ID [ NUM ] type ;
    (17) var_declare -> VAR . ID [ NUM ] [ NUM ] type ;
    (18) var_declare -> VAR . ID type = expr ;
    (19) var_declare -> VAR . ID type ;

    ID              shift and go to state 7


state 6

    (1) program -> declist start funlist . entrypoint stmtlist
    (56) funlist -> funlist . fun
    (3) entrypoint -> .
    (4) fun -> . DEF fun_name ( funargs ) ftype { stmtlist }

    PRINT           reduce using rule 3 (entrypoint -> .)
    PRINTLN         reduce using rule 3 (entrypoint -> .)
    WHILE           reduce using rule 3 (entrypoint -> .)
    IF              reduce using rule 3 (entrypoint -> .)
    ID              reduce using rule 3 (entrypoint -> .)
    RETURN          reduce using rule 3 (entrypoint -> .)
    INPUT           reduce using rule 3 (entrypoint -> .)
    STR             reduce using rule 3 (entrypoint -> .)
    ATOI            reduce using rule 3 (entrypoint -> .)
    !               reduce using rule 3 (entrypoint -> .)
    -               reduce using rule 3 (entrypoint -> .)
    STRING          reduce using rule 3 (entrypoint -> .)
    NUM             reduce using rule 3 (entrypoint -> .)
    (               reduce using rule 3 (entrypoint -> .)
    $end            reduce using rule 3 (entrypoint -> .)
    DEF             shift and go to state 10

    entrypoint                     shift and go to state 8
    fun                            shift and go to state 9

state 7

    (16) var_declare -> VAR ID . [ NUM ] type ;
    (17) var_declare -> VAR ID . [ NUM ] [ NUM ] type ;
    (18) var_declare -> VAR ID . type = expr ;
    (19) var_declare -> VAR ID . type ;
    (50) type -> . STRINGTYPE
    (51) type -> . INTTYPE
    (52) type -> . VOIDTYPE
    (53) type -> . [ type ]

    [               shift and go to state 11
    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15

    type                           shift and go to state 12

state 8

    (1) program -> declist start funlist entrypoint . stmtlist
    (58) stmtlist -> . stmtlist stmt
    (59) stmtlist -> .

    PRINT           reduce using rule 59 (stmtlist -> .)
    PRINTLN         reduce using rule 59 (stmtlist -> .)
    WHILE           reduce using rule 59 (stmtlist -> .)
    IF              reduce using rule 59 (stmtlist -> .)
    ID              reduce using rule 59 (stmtlist -> .)
    RETURN          reduce using rule 59 (stmtlist -> .)
    INPUT           reduce using rule 59 (stmtlist -> .)
    STR             reduce using rule 59 (stmtlist -> .)
    ATOI            reduce using rule 59 (stmtlist -> .)
    !               reduce using rule 59 (stmtlist -> .)
    -               reduce using rule 59 (stmtlist -> .)
    STRING          reduce using rule 59 (stmtlist -> .)
    NUM             reduce using rule 59 (stmtlist -> .)
    (               reduce using rule 59 (stmtlist -> .)
    $end            reduce using rule 59 (stmtlist -> .)

    stmtlist                       shift and go to state 16

state 9

    (56) funlist -> funlist fun .

    DEF             reduce using rule 56 (funlist -> funlist fun .)
    PRINT           reduce using rule 56 (funlist -> funlist fun .)
    PRINTLN         reduce using rule 56 (funlist -> funlist fun .)
    WHILE           reduce using rule 56 (funlist -> funlist fun .)
    IF              reduce using rule 56 (funlist -> funlist fun .)
    ID              reduce using rule 56 (funlist -> funlist fun .)
    RETURN          reduce using rule 56 (funlist -> funlist fun .)
    INPUT           reduce using rule 56 (funlist -> funlist fun .)
    STR             reduce using rule 56 (funlist -> funlist fun .)
    ATOI            reduce using rule 56 (funlist -> funlist fun .)
    !               reduce using rule 56 (funlist -> funlist fun .)
    -               reduce using rule 56 (funlist -> funlist fun .)
    STRING          reduce using rule 56 (funlist -> funlist fun .)
    NUM             reduce using rule 56 (funlist -> funlist fun .)
    (               reduce using rule 56 (funlist -> funlist fun .)
    $end            reduce using rule 56 (funlist -> funlist fun .)


state 10

    (4) fun -> DEF . fun_name ( funargs ) ftype { stmtlist }
    (5) fun_name -> . ID

    ID              shift and go to state 18

    fun_name                       shift and go to state 17

state 11

    (16) var_declare -> VAR ID [ . NUM ] type ;
    (17) var_declare -> VAR ID [ . NUM ] [ NUM ] type ;
    (53) type -> [ . type ]
    (50) type -> . STRINGTYPE
    (51) type -> . INTTYPE
    (52) type -> . VOIDTYPE
    (53) type -> . [ type ]

    NUM             shift and go to state 20
    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    [               shift and go to state 19

    type                           shift and go to state 21

state 12

    (18) var_declare -> VAR ID type . = expr ;
    (19) var_declare -> VAR ID type . ;

    =               shift and go to state 22
    ;               shift and go to state 23


state 13

    (50) type -> STRINGTYPE .

    =               reduce using rule 50 (type -> STRINGTYPE .)
    ;               reduce using rule 50 (type -> STRINGTYPE .)
    ]               reduce using rule 50 (type -> STRINGTYPE .)
    ,               reduce using rule 50 (type -> STRINGTYPE .)
    )               reduce using rule 50 (type -> STRINGTYPE .)
    {               reduce using rule 50 (type -> STRINGTYPE .)


state 14

    (51) type -> INTTYPE .

    =               reduce using rule 51 (type -> INTTYPE .)
    ;               reduce using rule 51 (type -> INTTYPE .)
    ]               reduce using rule 51 (type -> INTTYPE .)
    ,               reduce using rule 51 (type -> INTTYPE .)
    )               reduce using rule 51 (type -> INTTYPE .)
    {               reduce using rule 51 (type -> INTTYPE .)


state 15

    (52) type -> VOIDTYPE .

    =               reduce using rule 52 (type -> VOIDTYPE .)
    ;               reduce using rule 52 (type -> VOIDTYPE .)
    ]               reduce using rule 52 (type -> VOIDTYPE .)
    ,               reduce using rule 52 (type -> VOIDTYPE .)
    )               reduce using rule 52 (type -> VOIDTYPE .)
    {               reduce using rule 52 (type -> VOIDTYPE .)


state 16

    (1) program -> declist start funlist entrypoint stmtlist .
    (58) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . expr [ expr ] = expr ;
    (22) stmt -> . RETURN expr ;
    (23) stmt -> . RETURN ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    $end            reduce using rule 1 (program -> declist start funlist entrypoint stmtlist .)
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    stmt                           shift and go to state 24
    expr                           shift and go to state 27

state 17

    (4) fun -> DEF fun_name . ( funargs ) ftype { stmtlist }

    (               shift and go to state 40


state 18

    (5) fun_name -> ID .

    (               reduce using rule 5 (fun_name -> ID .)


state 19

    (53) type -> [ . type ]
    (50) type -> . STRINGTYPE
    (51) type -> . INTTYPE
    (52) type -> . VOIDTYPE
    (53) type -> . [ type ]

    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    [               shift and go to state 19

    type                           shift and go to state 21

state 20

    (16) var_declare -> VAR ID [ NUM . ] type ;
    (17) var_declare -> VAR ID [ NUM . ] [ NUM ] type ;

    ]               shift and go to state 41


state 21

    (53) type -> [ type . ]

    ]               shift and go to state 42


state 22

    (18) var_declare -> VAR ID type = . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 44

state 23

    (19) var_declare -> VAR ID type ; .

    VAR             reduce using rule 19 (var_declare -> VAR ID type ; .)
    DEF             reduce using rule 19 (var_declare -> VAR ID type ; .)
    PRINT           reduce using rule 19 (var_declare -> VAR ID type ; .)
    PRINTLN         reduce using rule 19 (var_declare -> VAR ID type ; .)
    WHILE           reduce using rule 19 (var_declare -> VAR ID type ; .)
    IF              reduce using rule 19 (var_declare -> VAR ID type ; .)
    ID              reduce using rule 19 (var_declare -> VAR ID type ; .)
    RETURN          reduce using rule 19 (var_declare -> VAR ID type ; .)
    INPUT           reduce using rule 19 (var_declare -> VAR ID type ; .)
    STR             reduce using rule 19 (var_declare -> VAR ID type ; .)
    ATOI            reduce using rule 19 (var_declare -> VAR ID type ; .)
    !               reduce using rule 19 (var_declare -> VAR ID type ; .)
    -               reduce using rule 19 (var_declare -> VAR ID type ; .)
    STRING          reduce using rule 19 (var_declare -> VAR ID type ; .)
    NUM             reduce using rule 19 (var_declare -> VAR ID type ; .)
    (               reduce using rule 19 (var_declare -> VAR ID type ; .)
    $end            reduce using rule 19 (var_declare -> VAR ID type ; .)


state 24

    (58) stmtlist -> stmtlist stmt .

    PRINT           reduce using rule 58 (stmtlist -> stmtlist stmt .)
    PRINTLN         reduce using rule 58 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 58 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 58 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 58 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 58 (stmtlist -> stmtlist stmt .)
    INPUT           reduce using rule 58 (stmtlist -> stmtlist stmt .)
    STR             reduce using rule 58 (stmtlist -> stmtlist stmt .)
    ATOI            reduce using rule 58 (stmtlist -> stmtlist stmt .)
    !               reduce using rule 58 (stmtlist -> stmtlist stmt .)
    -               reduce using rule 58 (stmtlist -> stmtlist stmt .)
    STRING          reduce using rule 58 (stmtlist -> stmtlist stmt .)
    NUM             reduce using rule 58 (stmtlist -> stmtlist stmt .)
    (               reduce using rule 58 (stmtlist -> stmtlist stmt .)
    $end            reduce using rule 58 (stmtlist -> stmtlist stmt .)
    }               reduce using rule 58 (stmtlist -> stmtlist stmt .)


state 25

    (7) stmt -> PRINT . ( expr ) ;

    (               shift and go to state 45


state 26

    (49) expr -> ( . expr )
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 46

state 27

    (21) stmt -> expr . [ expr ] = expr ;
    (24) stmt -> expr . ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               shift and go to state 47
    ;               shift and go to state 48
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62


state 28

    (8) stmt -> PRINTLN . ( ) ;

    (               shift and go to state 63


state 29

    (9) stmt -> WHILE . new_label ( expr ) jz block
    (15) new_label -> .

    (               reduce using rule 15 (new_label -> .)

    new_label                      shift and go to state 64

state 30

    (10) stmt -> IF . ( expr ) jz block
    (11) stmt -> IF . ( expr ) jz block ELSE jmp jz_label block

    (               shift and go to state 65


state 31

    (20) stmt -> ID . = expr ;
    (44) expr -> ID .
    (48) expr -> ID . ( fcall )

    =               shift and go to state 66
    [               reduce using rule 44 (expr -> ID .)
    ;               reduce using rule 44 (expr -> ID .)
    +               reduce using rule 44 (expr -> ID .)
    -               reduce using rule 44 (expr -> ID .)
    *               reduce using rule 44 (expr -> ID .)
    /               reduce using rule 44 (expr -> ID .)
    %               reduce using rule 44 (expr -> ID .)
    OR              reduce using rule 44 (expr -> ID .)
    AND             reduce using rule 44 (expr -> ID .)
    >               reduce using rule 44 (expr -> ID .)
    <               reduce using rule 44 (expr -> ID .)
    GTE             reduce using rule 44 (expr -> ID .)
    LTE             reduce using rule 44 (expr -> ID .)
    EQ              reduce using rule 44 (expr -> ID .)
    NEQ             reduce using rule 44 (expr -> ID .)
    $               reduce using rule 44 (expr -> ID .)
    (               shift and go to state 67


state 32

    (22) stmt -> RETURN . expr ;
    (23) stmt -> RETURN . ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    ;               shift and go to state 69
    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 68

state 33

    (25) expr -> INPUT . ( )

    (               shift and go to state 70


state 34

    (26) expr -> STR . ( expr )

    (               shift and go to state 71


state 35

    (27) expr -> ATOI . ( expr )

    (               shift and go to state 72


state 36

    (43) expr -> - . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 73

state 37

    (42) expr -> ! . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 74

state 38

    (46) expr -> STRING .

    [               reduce using rule 46 (expr -> STRING .)
    ;               reduce using rule 46 (expr -> STRING .)
    +               reduce using rule 46 (expr -> STRING .)
    -               reduce using rule 46 (expr -> STRING .)
    *               reduce using rule 46 (expr -> STRING .)
    /               reduce using rule 46 (expr -> STRING .)
    %               reduce using rule 46 (expr -> STRING .)
    OR              reduce using rule 46 (expr -> STRING .)
    AND             reduce using rule 46 (expr -> STRING .)
    >               reduce using rule 46 (expr -> STRING .)
    <               reduce using rule 46 (expr -> STRING .)
    GTE             reduce using rule 46 (expr -> STRING .)
    LTE             reduce using rule 46 (expr -> STRING .)
    EQ              reduce using rule 46 (expr -> STRING .)
    NEQ             reduce using rule 46 (expr -> STRING .)
    $               reduce using rule 46 (expr -> STRING .)
    )               reduce using rule 46 (expr -> STRING .)
    ]               reduce using rule 46 (expr -> STRING .)
    ,               reduce using rule 46 (expr -> STRING .)


state 39

    (47) expr -> NUM .

    [               reduce using rule 47 (expr -> NUM .)
    ;               reduce using rule 47 (expr -> NUM .)
    +               reduce using rule 47 (expr -> NUM .)
    -               reduce using rule 47 (expr -> NUM .)
    *               reduce using rule 47 (expr -> NUM .)
    /               reduce using rule 47 (expr -> NUM .)
    %               reduce using rule 47 (expr -> NUM .)
    OR              reduce using rule 47 (expr -> NUM .)
    AND             reduce using rule 47 (expr -> NUM .)
    >               reduce using rule 47 (expr -> NUM .)
    <               reduce using rule 47 (expr -> NUM .)
    GTE             reduce using rule 47 (expr -> NUM .)
    LTE             reduce using rule 47 (expr -> NUM .)
    EQ              reduce using rule 47 (expr -> NUM .)
    NEQ             reduce using rule 47 (expr -> NUM .)
    $               reduce using rule 47 (expr -> NUM .)
    )               reduce using rule 47 (expr -> NUM .)
    ]               reduce using rule 47 (expr -> NUM .)
    ,               reduce using rule 47 (expr -> NUM .)


state 40

    (4) fun -> DEF fun_name ( . funargs ) ftype { stmtlist }
    (60) funargs -> . idlist
    (61) funargs -> .
    (62) idlist -> . idlist , ID type
    (63) idlist -> . ID type

    )               reduce using rule 61 (funargs -> .)
    ID              shift and go to state 77

    funargs                        shift and go to state 75
    idlist                         shift and go to state 76

state 41

    (16) var_declare -> VAR ID [ NUM ] . type ;
    (17) var_declare -> VAR ID [ NUM ] . [ NUM ] type ;
    (50) type -> . STRINGTYPE
    (51) type -> . INTTYPE
    (52) type -> . VOIDTYPE
    (53) type -> . [ type ]

    [               shift and go to state 78
    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15

    type                           shift and go to state 79

state 42

    (53) type -> [ type ] .

    =               reduce using rule 53 (type -> [ type ] .)
    ;               reduce using rule 53 (type -> [ type ] .)
    ]               reduce using rule 53 (type -> [ type ] .)
    ,               reduce using rule 53 (type -> [ type ] .)
    )               reduce using rule 53 (type -> [ type ] .)
    {               reduce using rule 53 (type -> [ type ] .)


state 43

    (44) expr -> ID .
    (48) expr -> ID . ( fcall )

    ;               reduce using rule 44 (expr -> ID .)
    +               reduce using rule 44 (expr -> ID .)
    -               reduce using rule 44 (expr -> ID .)
    *               reduce using rule 44 (expr -> ID .)
    /               reduce using rule 44 (expr -> ID .)
    %               reduce using rule 44 (expr -> ID .)
    OR              reduce using rule 44 (expr -> ID .)
    AND             reduce using rule 44 (expr -> ID .)
    >               reduce using rule 44 (expr -> ID .)
    <               reduce using rule 44 (expr -> ID .)
    GTE             reduce using rule 44 (expr -> ID .)
    LTE             reduce using rule 44 (expr -> ID .)
    EQ              reduce using rule 44 (expr -> ID .)
    NEQ             reduce using rule 44 (expr -> ID .)
    $               reduce using rule 44 (expr -> ID .)
    [               reduce using rule 44 (expr -> ID .)
    )               reduce using rule 44 (expr -> ID .)
    ]               reduce using rule 44 (expr -> ID .)
    ,               reduce using rule 44 (expr -> ID .)
    (               shift and go to state 67


state 44

    (18) var_declare -> VAR ID type = expr . ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               shift and go to state 80
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 45

    (7) stmt -> PRINT ( . expr ) ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 82

state 46

    (49) expr -> ( expr . )
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 83
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 47

    (21) stmt -> expr [ . expr ] = expr ;
    (45) expr -> expr [ . expr ]
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 84

state 48

    (24) stmt -> expr ; .

    PRINT           reduce using rule 24 (stmt -> expr ; .)
    PRINTLN         reduce using rule 24 (stmt -> expr ; .)
    WHILE           reduce using rule 24 (stmt -> expr ; .)
    IF              reduce using rule 24 (stmt -> expr ; .)
    ID              reduce using rule 24 (stmt -> expr ; .)
    RETURN          reduce using rule 24 (stmt -> expr ; .)
    INPUT           reduce using rule 24 (stmt -> expr ; .)
    STR             reduce using rule 24 (stmt -> expr ; .)
    ATOI            reduce using rule 24 (stmt -> expr ; .)
    !               reduce using rule 24 (stmt -> expr ; .)
    -               reduce using rule 24 (stmt -> expr ; .)
    STRING          reduce using rule 24 (stmt -> expr ; .)
    NUM             reduce using rule 24 (stmt -> expr ; .)
    (               reduce using rule 24 (stmt -> expr ; .)
    $end            reduce using rule 24 (stmt -> expr ; .)
    ELSE            reduce using rule 24 (stmt -> expr ; .)
    }               reduce using rule 24 (stmt -> expr ; .)


state 49

    (28) expr -> expr + . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 85

state 50

    (29) expr -> expr - . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 86

state 51

    (30) expr -> expr * . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 87

state 52

    (31) expr -> expr / . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 88

state 53

    (32) expr -> expr % . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 89

state 54

    (33) expr -> expr OR . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 90

state 55

    (34) expr -> expr AND . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 91

state 56

    (35) expr -> expr > . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 92

state 57

    (36) expr -> expr < . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 93

state 58

    (37) expr -> expr GTE . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 94

state 59

    (38) expr -> expr LTE . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 95

state 60

    (39) expr -> expr EQ . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 96

state 61

    (40) expr -> expr NEQ . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 97

state 62

    (41) expr -> expr $ . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 98

state 63

    (8) stmt -> PRINTLN ( . ) ;

    )               shift and go to state 99


state 64

    (9) stmt -> WHILE new_label . ( expr ) jz block

    (               shift and go to state 100


state 65

    (10) stmt -> IF ( . expr ) jz block
    (11) stmt -> IF ( . expr ) jz block ELSE jmp jz_label block
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 101

state 66

    (20) stmt -> ID = . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 102

state 67

    (48) expr -> ID ( . fcall )
    (64) fcall -> . exprlist
    (65) fcall -> .
    (66) exprlist -> . exprlist , expr
    (67) exprlist -> . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    )               reduce using rule 65 (fcall -> .)
    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    fcall                          shift and go to state 103
    exprlist                       shift and go to state 104
    expr                           shift and go to state 105

state 68

    (22) stmt -> RETURN expr . ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               shift and go to state 106
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 69

    (23) stmt -> RETURN ; .

    PRINT           reduce using rule 23 (stmt -> RETURN ; .)
    PRINTLN         reduce using rule 23 (stmt -> RETURN ; .)
    WHILE           reduce using rule 23 (stmt -> RETURN ; .)
    IF              reduce using rule 23 (stmt -> RETURN ; .)
    ID              reduce using rule 23 (stmt -> RETURN ; .)
    RETURN          reduce using rule 23 (stmt -> RETURN ; .)
    INPUT           reduce using rule 23 (stmt -> RETURN ; .)
    STR             reduce using rule 23 (stmt -> RETURN ; .)
    ATOI            reduce using rule 23 (stmt -> RETURN ; .)
    !               reduce using rule 23 (stmt -> RETURN ; .)
    -               reduce using rule 23 (stmt -> RETURN ; .)
    STRING          reduce using rule 23 (stmt -> RETURN ; .)
    NUM             reduce using rule 23 (stmt -> RETURN ; .)
    (               reduce using rule 23 (stmt -> RETURN ; .)
    $end            reduce using rule 23 (stmt -> RETURN ; .)
    ELSE            reduce using rule 23 (stmt -> RETURN ; .)
    }               reduce using rule 23 (stmt -> RETURN ; .)


state 70

    (25) expr -> INPUT ( . )

    )               shift and go to state 107


state 71

    (26) expr -> STR ( . expr )
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 108

state 72

    (27) expr -> ATOI ( . expr )
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 109

state 73

    (43) expr -> - expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 43 (expr -> - expr .)
    ;               reduce using rule 43 (expr -> - expr .)
    +               reduce using rule 43 (expr -> - expr .)
    -               reduce using rule 43 (expr -> - expr .)
    *               reduce using rule 43 (expr -> - expr .)
    /               reduce using rule 43 (expr -> - expr .)
    %               reduce using rule 43 (expr -> - expr .)
    OR              reduce using rule 43 (expr -> - expr .)
    AND             reduce using rule 43 (expr -> - expr .)
    >               reduce using rule 43 (expr -> - expr .)
    <               reduce using rule 43 (expr -> - expr .)
    GTE             reduce using rule 43 (expr -> - expr .)
    LTE             reduce using rule 43 (expr -> - expr .)
    EQ              reduce using rule 43 (expr -> - expr .)
    NEQ             reduce using rule 43 (expr -> - expr .)
    $               reduce using rule 43 (expr -> - expr .)
    )               reduce using rule 43 (expr -> - expr .)
    ]               reduce using rule 43 (expr -> - expr .)
    ,               reduce using rule 43 (expr -> - expr .)

  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 51 ]
  ! /               [ shift and go to state 52 ]
  ! %               [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! $               [ shift and go to state 62 ]
  ! [               [ shift and go to state 81 ]


state 74

    (42) expr -> ! expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 42 (expr -> ! expr .)
    ;               reduce using rule 42 (expr -> ! expr .)
    +               reduce using rule 42 (expr -> ! expr .)
    -               reduce using rule 42 (expr -> ! expr .)
    *               reduce using rule 42 (expr -> ! expr .)
    /               reduce using rule 42 (expr -> ! expr .)
    %               reduce using rule 42 (expr -> ! expr .)
    OR              reduce using rule 42 (expr -> ! expr .)
    AND             reduce using rule 42 (expr -> ! expr .)
    >               reduce using rule 42 (expr -> ! expr .)
    <               reduce using rule 42 (expr -> ! expr .)
    GTE             reduce using rule 42 (expr -> ! expr .)
    LTE             reduce using rule 42 (expr -> ! expr .)
    EQ              reduce using rule 42 (expr -> ! expr .)
    NEQ             reduce using rule 42 (expr -> ! expr .)
    $               reduce using rule 42 (expr -> ! expr .)
    )               reduce using rule 42 (expr -> ! expr .)
    ]               reduce using rule 42 (expr -> ! expr .)
    ,               reduce using rule 42 (expr -> ! expr .)

  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 51 ]
  ! /               [ shift and go to state 52 ]
  ! %               [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! $               [ shift and go to state 62 ]
  ! [               [ shift and go to state 81 ]


state 75

    (4) fun -> DEF fun_name ( funargs . ) ftype { stmtlist }

    )               shift and go to state 110


state 76

    (60) funargs -> idlist .
    (62) idlist -> idlist . , ID type

    )               reduce using rule 60 (funargs -> idlist .)
    ,               shift and go to state 111


state 77

    (63) idlist -> ID . type
    (50) type -> . STRINGTYPE
    (51) type -> . INTTYPE
    (52) type -> . VOIDTYPE
    (53) type -> . [ type ]

    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    [               shift and go to state 19

    type                           shift and go to state 112

state 78

    (17) var_declare -> VAR ID [ NUM ] [ . NUM ] type ;
    (53) type -> [ . type ]
    (50) type -> . STRINGTYPE
    (51) type -> . INTTYPE
    (52) type -> . VOIDTYPE
    (53) type -> . [ type ]

    NUM             shift and go to state 113
    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    [               shift and go to state 19

    type                           shift and go to state 21

state 79

    (16) var_declare -> VAR ID [ NUM ] type . ;

    ;               shift and go to state 114


state 80

    (18) var_declare -> VAR ID type = expr ; .

    VAR             reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    DEF             reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    PRINT           reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    PRINTLN         reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    WHILE           reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    IF              reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    ID              reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    RETURN          reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    INPUT           reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    STR             reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    ATOI            reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    !               reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    -               reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    STRING          reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    NUM             reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    (               reduce using rule 18 (var_declare -> VAR ID type = expr ; .)
    $end            reduce using rule 18 (var_declare -> VAR ID type = expr ; .)


state 81

    (45) expr -> expr [ . expr ]
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 115

state 82

    (7) stmt -> PRINT ( expr . ) ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 116
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 83

    (49) expr -> ( expr ) .

    [               reduce using rule 49 (expr -> ( expr ) .)
    ;               reduce using rule 49 (expr -> ( expr ) .)
    +               reduce using rule 49 (expr -> ( expr ) .)
    -               reduce using rule 49 (expr -> ( expr ) .)
    *               reduce using rule 49 (expr -> ( expr ) .)
    /               reduce using rule 49 (expr -> ( expr ) .)
    %               reduce using rule 49 (expr -> ( expr ) .)
    OR              reduce using rule 49 (expr -> ( expr ) .)
    AND             reduce using rule 49 (expr -> ( expr ) .)
    >               reduce using rule 49 (expr -> ( expr ) .)
    <               reduce using rule 49 (expr -> ( expr ) .)
    GTE             reduce using rule 49 (expr -> ( expr ) .)
    LTE             reduce using rule 49 (expr -> ( expr ) .)
    EQ              reduce using rule 49 (expr -> ( expr ) .)
    NEQ             reduce using rule 49 (expr -> ( expr ) .)
    $               reduce using rule 49 (expr -> ( expr ) .)
    )               reduce using rule 49 (expr -> ( expr ) .)
    ]               reduce using rule 49 (expr -> ( expr ) .)
    ,               reduce using rule 49 (expr -> ( expr ) .)


state 84

    (21) stmt -> expr [ expr . ] = expr ;
    (45) expr -> expr [ expr . ]
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ]               shift and go to state 117
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 85

    (28) expr -> expr + expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 28 (expr -> expr + expr .)
    ;               reduce using rule 28 (expr -> expr + expr .)
    +               reduce using rule 28 (expr -> expr + expr .)
    -               reduce using rule 28 (expr -> expr + expr .)
    OR              reduce using rule 28 (expr -> expr + expr .)
    AND             reduce using rule 28 (expr -> expr + expr .)
    >               reduce using rule 28 (expr -> expr + expr .)
    <               reduce using rule 28 (expr -> expr + expr .)
    GTE             reduce using rule 28 (expr -> expr + expr .)
    LTE             reduce using rule 28 (expr -> expr + expr .)
    EQ              reduce using rule 28 (expr -> expr + expr .)
    NEQ             reduce using rule 28 (expr -> expr + expr .)
    $               reduce using rule 28 (expr -> expr + expr .)
    )               reduce using rule 28 (expr -> expr + expr .)
    ]               reduce using rule 28 (expr -> expr + expr .)
    ,               reduce using rule 28 (expr -> expr + expr .)
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53

  ! *               [ reduce using rule 28 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 28 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 28 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 50 ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! $               [ shift and go to state 62 ]
  ! [               [ shift and go to state 81 ]


state 86

    (29) expr -> expr - expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 29 (expr -> expr - expr .)
    ;               reduce using rule 29 (expr -> expr - expr .)
    +               reduce using rule 29 (expr -> expr - expr .)
    -               reduce using rule 29 (expr -> expr - expr .)
    OR              reduce using rule 29 (expr -> expr - expr .)
    AND             reduce using rule 29 (expr -> expr - expr .)
    >               reduce using rule 29 (expr -> expr - expr .)
    <               reduce using rule 29 (expr -> expr - expr .)
    GTE             reduce using rule 29 (expr -> expr - expr .)
    LTE             reduce using rule 29 (expr -> expr - expr .)
    EQ              reduce using rule 29 (expr -> expr - expr .)
    NEQ             reduce using rule 29 (expr -> expr - expr .)
    $               reduce using rule 29 (expr -> expr - expr .)
    )               reduce using rule 29 (expr -> expr - expr .)
    ]               reduce using rule 29 (expr -> expr - expr .)
    ,               reduce using rule 29 (expr -> expr - expr .)
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53

  ! *               [ reduce using rule 29 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 29 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 29 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 50 ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! $               [ shift and go to state 62 ]
  ! [               [ shift and go to state 81 ]


state 87

    (30) expr -> expr * expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 30 (expr -> expr * expr .)
    ;               reduce using rule 30 (expr -> expr * expr .)
    +               reduce using rule 30 (expr -> expr * expr .)
    -               reduce using rule 30 (expr -> expr * expr .)
    *               reduce using rule 30 (expr -> expr * expr .)
    /               reduce using rule 30 (expr -> expr * expr .)
    %               reduce using rule 30 (expr -> expr * expr .)
    OR              reduce using rule 30 (expr -> expr * expr .)
    AND             reduce using rule 30 (expr -> expr * expr .)
    >               reduce using rule 30 (expr -> expr * expr .)
    <               reduce using rule 30 (expr -> expr * expr .)
    GTE             reduce using rule 30 (expr -> expr * expr .)
    LTE             reduce using rule 30 (expr -> expr * expr .)
    EQ              reduce using rule 30 (expr -> expr * expr .)
    NEQ             reduce using rule 30 (expr -> expr * expr .)
    $               reduce using rule 30 (expr -> expr * expr .)
    )               reduce using rule 30 (expr -> expr * expr .)
    ]               reduce using rule 30 (expr -> expr * expr .)
    ,               reduce using rule 30 (expr -> expr * expr .)

  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 51 ]
  ! /               [ shift and go to state 52 ]
  ! %               [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! $               [ shift and go to state 62 ]
  ! [               [ shift and go to state 81 ]


state 88

    (31) expr -> expr / expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 31 (expr -> expr / expr .)
    ;               reduce using rule 31 (expr -> expr / expr .)
    +               reduce using rule 31 (expr -> expr / expr .)
    -               reduce using rule 31 (expr -> expr / expr .)
    *               reduce using rule 31 (expr -> expr / expr .)
    /               reduce using rule 31 (expr -> expr / expr .)
    %               reduce using rule 31 (expr -> expr / expr .)
    OR              reduce using rule 31 (expr -> expr / expr .)
    AND             reduce using rule 31 (expr -> expr / expr .)
    >               reduce using rule 31 (expr -> expr / expr .)
    <               reduce using rule 31 (expr -> expr / expr .)
    GTE             reduce using rule 31 (expr -> expr / expr .)
    LTE             reduce using rule 31 (expr -> expr / expr .)
    EQ              reduce using rule 31 (expr -> expr / expr .)
    NEQ             reduce using rule 31 (expr -> expr / expr .)
    $               reduce using rule 31 (expr -> expr / expr .)
    )               reduce using rule 31 (expr -> expr / expr .)
    ]               reduce using rule 31 (expr -> expr / expr .)
    ,               reduce using rule 31 (expr -> expr / expr .)

  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 51 ]
  ! /               [ shift and go to state 52 ]
  ! %               [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! $               [ shift and go to state 62 ]
  ! [               [ shift and go to state 81 ]


state 89

    (32) expr -> expr % expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 32 (expr -> expr % expr .)
    ;               reduce using rule 32 (expr -> expr % expr .)
    +               reduce using rule 32 (expr -> expr % expr .)
    -               reduce using rule 32 (expr -> expr % expr .)
    *               reduce using rule 32 (expr -> expr % expr .)
    /               reduce using rule 32 (expr -> expr % expr .)
    %               reduce using rule 32 (expr -> expr % expr .)
    OR              reduce using rule 32 (expr -> expr % expr .)
    AND             reduce using rule 32 (expr -> expr % expr .)
    >               reduce using rule 32 (expr -> expr % expr .)
    <               reduce using rule 32 (expr -> expr % expr .)
    GTE             reduce using rule 32 (expr -> expr % expr .)
    LTE             reduce using rule 32 (expr -> expr % expr .)
    EQ              reduce using rule 32 (expr -> expr % expr .)
    NEQ             reduce using rule 32 (expr -> expr % expr .)
    $               reduce using rule 32 (expr -> expr % expr .)
    )               reduce using rule 32 (expr -> expr % expr .)
    ]               reduce using rule 32 (expr -> expr % expr .)
    ,               reduce using rule 32 (expr -> expr % expr .)

  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 51 ]
  ! /               [ shift and go to state 52 ]
  ! %               [ shift and go to state 53 ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! $               [ shift and go to state 62 ]
  ! [               [ shift and go to state 81 ]


state 90

    (33) expr -> expr OR expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 33 (expr -> expr OR expr .)
    ;               reduce using rule 33 (expr -> expr OR expr .)
    OR              reduce using rule 33 (expr -> expr OR expr .)
    AND             reduce using rule 33 (expr -> expr OR expr .)
    EQ              reduce using rule 33 (expr -> expr OR expr .)
    NEQ             reduce using rule 33 (expr -> expr OR expr .)
    )               reduce using rule 33 (expr -> expr OR expr .)
    ]               reduce using rule 33 (expr -> expr OR expr .)
    ,               reduce using rule 33 (expr -> expr OR expr .)
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    $               shift and go to state 62

  ! +               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! -               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! *               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! /               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! %               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! >               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! <               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! GTE             [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! LTE             [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! $               [ reduce using rule 33 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! [               [ shift and go to state 81 ]


state 91

    (34) expr -> expr AND expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 34 (expr -> expr AND expr .)
    ;               reduce using rule 34 (expr -> expr AND expr .)
    OR              reduce using rule 34 (expr -> expr AND expr .)
    AND             reduce using rule 34 (expr -> expr AND expr .)
    EQ              reduce using rule 34 (expr -> expr AND expr .)
    NEQ             reduce using rule 34 (expr -> expr AND expr .)
    )               reduce using rule 34 (expr -> expr AND expr .)
    ]               reduce using rule 34 (expr -> expr AND expr .)
    ,               reduce using rule 34 (expr -> expr AND expr .)
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    $               shift and go to state 62

  ! +               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! -               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! *               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! /               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! %               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! >               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! <               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! GTE             [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! LTE             [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! $               [ reduce using rule 34 (expr -> expr AND expr .) ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! [               [ shift and go to state 81 ]


state 92

    (35) expr -> expr > expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 35 (expr -> expr > expr .)
    ;               reduce using rule 35 (expr -> expr > expr .)
    OR              reduce using rule 35 (expr -> expr > expr .)
    AND             reduce using rule 35 (expr -> expr > expr .)
    >               reduce using rule 35 (expr -> expr > expr .)
    <               reduce using rule 35 (expr -> expr > expr .)
    GTE             reduce using rule 35 (expr -> expr > expr .)
    LTE             reduce using rule 35 (expr -> expr > expr .)
    EQ              reduce using rule 35 (expr -> expr > expr .)
    NEQ             reduce using rule 35 (expr -> expr > expr .)
    )               reduce using rule 35 (expr -> expr > expr .)
    ]               reduce using rule 35 (expr -> expr > expr .)
    ,               reduce using rule 35 (expr -> expr > expr .)
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    $               shift and go to state 62

  ! +               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! %               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! $               [ reduce using rule 35 (expr -> expr > expr .) ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! [               [ shift and go to state 81 ]


state 93

    (36) expr -> expr < expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 36 (expr -> expr < expr .)
    ;               reduce using rule 36 (expr -> expr < expr .)
    OR              reduce using rule 36 (expr -> expr < expr .)
    AND             reduce using rule 36 (expr -> expr < expr .)
    >               reduce using rule 36 (expr -> expr < expr .)
    <               reduce using rule 36 (expr -> expr < expr .)
    GTE             reduce using rule 36 (expr -> expr < expr .)
    LTE             reduce using rule 36 (expr -> expr < expr .)
    EQ              reduce using rule 36 (expr -> expr < expr .)
    NEQ             reduce using rule 36 (expr -> expr < expr .)
    )               reduce using rule 36 (expr -> expr < expr .)
    ]               reduce using rule 36 (expr -> expr < expr .)
    ,               reduce using rule 36 (expr -> expr < expr .)
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    $               shift and go to state 62

  ! +               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! %               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! $               [ reduce using rule 36 (expr -> expr < expr .) ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! [               [ shift and go to state 81 ]


state 94

    (37) expr -> expr GTE expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 37 (expr -> expr GTE expr .)
    ;               reduce using rule 37 (expr -> expr GTE expr .)
    OR              reduce using rule 37 (expr -> expr GTE expr .)
    AND             reduce using rule 37 (expr -> expr GTE expr .)
    >               reduce using rule 37 (expr -> expr GTE expr .)
    <               reduce using rule 37 (expr -> expr GTE expr .)
    GTE             reduce using rule 37 (expr -> expr GTE expr .)
    LTE             reduce using rule 37 (expr -> expr GTE expr .)
    EQ              reduce using rule 37 (expr -> expr GTE expr .)
    NEQ             reduce using rule 37 (expr -> expr GTE expr .)
    )               reduce using rule 37 (expr -> expr GTE expr .)
    ]               reduce using rule 37 (expr -> expr GTE expr .)
    ,               reduce using rule 37 (expr -> expr GTE expr .)
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    $               shift and go to state 62

  ! +               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! -               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! *               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! /               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! %               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! $               [ reduce using rule 37 (expr -> expr GTE expr .) ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! [               [ shift and go to state 81 ]


state 95

    (38) expr -> expr LTE expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 38 (expr -> expr LTE expr .)
    ;               reduce using rule 38 (expr -> expr LTE expr .)
    OR              reduce using rule 38 (expr -> expr LTE expr .)
    AND             reduce using rule 38 (expr -> expr LTE expr .)
    >               reduce using rule 38 (expr -> expr LTE expr .)
    <               reduce using rule 38 (expr -> expr LTE expr .)
    GTE             reduce using rule 38 (expr -> expr LTE expr .)
    LTE             reduce using rule 38 (expr -> expr LTE expr .)
    EQ              reduce using rule 38 (expr -> expr LTE expr .)
    NEQ             reduce using rule 38 (expr -> expr LTE expr .)
    )               reduce using rule 38 (expr -> expr LTE expr .)
    ]               reduce using rule 38 (expr -> expr LTE expr .)
    ,               reduce using rule 38 (expr -> expr LTE expr .)
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    $               shift and go to state 62

  ! +               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! %               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! $               [ reduce using rule 38 (expr -> expr LTE expr .) ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! [               [ shift and go to state 81 ]


state 96

    (39) expr -> expr EQ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 39 (expr -> expr EQ expr .)
    ;               reduce using rule 39 (expr -> expr EQ expr .)
    OR              reduce using rule 39 (expr -> expr EQ expr .)
    AND             reduce using rule 39 (expr -> expr EQ expr .)
    EQ              reduce using rule 39 (expr -> expr EQ expr .)
    NEQ             reduce using rule 39 (expr -> expr EQ expr .)
    )               reduce using rule 39 (expr -> expr EQ expr .)
    ]               reduce using rule 39 (expr -> expr EQ expr .)
    ,               reduce using rule 39 (expr -> expr EQ expr .)
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    $               shift and go to state 62

  ! +               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! %               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! >               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! <               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! GTE             [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! LTE             [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! $               [ reduce using rule 39 (expr -> expr EQ expr .) ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! [               [ shift and go to state 81 ]


state 97

    (40) expr -> expr NEQ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 40 (expr -> expr NEQ expr .)
    ;               reduce using rule 40 (expr -> expr NEQ expr .)
    OR              reduce using rule 40 (expr -> expr NEQ expr .)
    AND             reduce using rule 40 (expr -> expr NEQ expr .)
    EQ              reduce using rule 40 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 40 (expr -> expr NEQ expr .)
    )               reduce using rule 40 (expr -> expr NEQ expr .)
    ]               reduce using rule 40 (expr -> expr NEQ expr .)
    ,               reduce using rule 40 (expr -> expr NEQ expr .)
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    $               shift and go to state 62

  ! +               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! %               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! >               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! <               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! GTE             [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! LTE             [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! $               [ reduce using rule 40 (expr -> expr NEQ expr .) ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! [               [ shift and go to state 81 ]


state 98

    (41) expr -> expr $ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    [               reduce using rule 41 (expr -> expr $ expr .)
    ;               reduce using rule 41 (expr -> expr $ expr .)
    +               reduce using rule 41 (expr -> expr $ expr .)
    -               reduce using rule 41 (expr -> expr $ expr .)
    OR              reduce using rule 41 (expr -> expr $ expr .)
    AND             reduce using rule 41 (expr -> expr $ expr .)
    >               reduce using rule 41 (expr -> expr $ expr .)
    <               reduce using rule 41 (expr -> expr $ expr .)
    GTE             reduce using rule 41 (expr -> expr $ expr .)
    LTE             reduce using rule 41 (expr -> expr $ expr .)
    EQ              reduce using rule 41 (expr -> expr $ expr .)
    NEQ             reduce using rule 41 (expr -> expr $ expr .)
    $               reduce using rule 41 (expr -> expr $ expr .)
    )               reduce using rule 41 (expr -> expr $ expr .)
    ]               reduce using rule 41 (expr -> expr $ expr .)
    ,               reduce using rule 41 (expr -> expr $ expr .)
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53

  ! *               [ reduce using rule 41 (expr -> expr $ expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr $ expr .) ]
  ! %               [ reduce using rule 41 (expr -> expr $ expr .) ]
  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 50 ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! >               [ shift and go to state 56 ]
  ! <               [ shift and go to state 57 ]
  ! GTE             [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 60 ]
  ! NEQ             [ shift and go to state 61 ]
  ! $               [ shift and go to state 62 ]
  ! [               [ shift and go to state 81 ]


state 99

    (8) stmt -> PRINTLN ( ) . ;

    ;               shift and go to state 118


state 100

    (9) stmt -> WHILE new_label ( . expr ) jz block
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 119

state 101

    (10) stmt -> IF ( expr . ) jz block
    (11) stmt -> IF ( expr . ) jz block ELSE jmp jz_label block
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 120
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 102

    (20) stmt -> ID = expr . ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               shift and go to state 121
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 103

    (48) expr -> ID ( fcall . )

    )               shift and go to state 122


state 104

    (64) fcall -> exprlist .
    (66) exprlist -> exprlist . , expr

    )               reduce using rule 64 (fcall -> exprlist .)
    ,               shift and go to state 123


state 105

    (67) exprlist -> expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ,               reduce using rule 67 (exprlist -> expr .)
    )               reduce using rule 67 (exprlist -> expr .)
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 106

    (22) stmt -> RETURN expr ; .

    PRINT           reduce using rule 22 (stmt -> RETURN expr ; .)
    PRINTLN         reduce using rule 22 (stmt -> RETURN expr ; .)
    WHILE           reduce using rule 22 (stmt -> RETURN expr ; .)
    IF              reduce using rule 22 (stmt -> RETURN expr ; .)
    ID              reduce using rule 22 (stmt -> RETURN expr ; .)
    RETURN          reduce using rule 22 (stmt -> RETURN expr ; .)
    INPUT           reduce using rule 22 (stmt -> RETURN expr ; .)
    STR             reduce using rule 22 (stmt -> RETURN expr ; .)
    ATOI            reduce using rule 22 (stmt -> RETURN expr ; .)
    !               reduce using rule 22 (stmt -> RETURN expr ; .)
    -               reduce using rule 22 (stmt -> RETURN expr ; .)
    STRING          reduce using rule 22 (stmt -> RETURN expr ; .)
    NUM             reduce using rule 22 (stmt -> RETURN expr ; .)
    (               reduce using rule 22 (stmt -> RETURN expr ; .)
    $end            reduce using rule 22 (stmt -> RETURN expr ; .)
    ELSE            reduce using rule 22 (stmt -> RETURN expr ; .)
    }               reduce using rule 22 (stmt -> RETURN expr ; .)


state 107

    (25) expr -> INPUT ( ) .

    [               reduce using rule 25 (expr -> INPUT ( ) .)
    ;               reduce using rule 25 (expr -> INPUT ( ) .)
    +               reduce using rule 25 (expr -> INPUT ( ) .)
    -               reduce using rule 25 (expr -> INPUT ( ) .)
    *               reduce using rule 25 (expr -> INPUT ( ) .)
    /               reduce using rule 25 (expr -> INPUT ( ) .)
    %               reduce using rule 25 (expr -> INPUT ( ) .)
    OR              reduce using rule 25 (expr -> INPUT ( ) .)
    AND             reduce using rule 25 (expr -> INPUT ( ) .)
    >               reduce using rule 25 (expr -> INPUT ( ) .)
    <               reduce using rule 25 (expr -> INPUT ( ) .)
    GTE             reduce using rule 25 (expr -> INPUT ( ) .)
    LTE             reduce using rule 25 (expr -> INPUT ( ) .)
    EQ              reduce using rule 25 (expr -> INPUT ( ) .)
    NEQ             reduce using rule 25 (expr -> INPUT ( ) .)
    $               reduce using rule 25 (expr -> INPUT ( ) .)
    )               reduce using rule 25 (expr -> INPUT ( ) .)
    ]               reduce using rule 25 (expr -> INPUT ( ) .)
    ,               reduce using rule 25 (expr -> INPUT ( ) .)


state 108

    (26) expr -> STR ( expr . )
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 124
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 109

    (27) expr -> ATOI ( expr . )
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 125
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 110

    (4) fun -> DEF fun_name ( funargs ) . ftype { stmtlist }
    (6) ftype -> . type
    (50) type -> . STRINGTYPE
    (51) type -> . INTTYPE
    (52) type -> . VOIDTYPE
    (53) type -> . [ type ]

    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    [               shift and go to state 19

    ftype                          shift and go to state 126
    type                           shift and go to state 127

state 111

    (62) idlist -> idlist , . ID type

    ID              shift and go to state 128


state 112

    (63) idlist -> ID type .

    ,               reduce using rule 63 (idlist -> ID type .)
    )               reduce using rule 63 (idlist -> ID type .)


state 113

    (17) var_declare -> VAR ID [ NUM ] [ NUM . ] type ;

    ]               shift and go to state 129


state 114

    (16) var_declare -> VAR ID [ NUM ] type ; .

    VAR             reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    DEF             reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    PRINT           reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    PRINTLN         reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    WHILE           reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    IF              reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    ID              reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    RETURN          reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    INPUT           reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    STR             reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    ATOI            reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    !               reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    -               reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    STRING          reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    NUM             reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    (               reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)
    $end            reduce using rule 16 (var_declare -> VAR ID [ NUM ] type ; .)


state 115

    (45) expr -> expr [ expr . ]
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ]               shift and go to state 130
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 116

    (7) stmt -> PRINT ( expr ) . ;

    ;               shift and go to state 131


state 117

    (21) stmt -> expr [ expr ] . = expr ;
    (45) expr -> expr [ expr ] .

    =               shift and go to state 132
    [               reduce using rule 45 (expr -> expr [ expr ] .)
    ;               reduce using rule 45 (expr -> expr [ expr ] .)
    +               reduce using rule 45 (expr -> expr [ expr ] .)
    -               reduce using rule 45 (expr -> expr [ expr ] .)
    *               reduce using rule 45 (expr -> expr [ expr ] .)
    /               reduce using rule 45 (expr -> expr [ expr ] .)
    %               reduce using rule 45 (expr -> expr [ expr ] .)
    OR              reduce using rule 45 (expr -> expr [ expr ] .)
    AND             reduce using rule 45 (expr -> expr [ expr ] .)
    >               reduce using rule 45 (expr -> expr [ expr ] .)
    <               reduce using rule 45 (expr -> expr [ expr ] .)
    GTE             reduce using rule 45 (expr -> expr [ expr ] .)
    LTE             reduce using rule 45 (expr -> expr [ expr ] .)
    EQ              reduce using rule 45 (expr -> expr [ expr ] .)
    NEQ             reduce using rule 45 (expr -> expr [ expr ] .)
    $               reduce using rule 45 (expr -> expr [ expr ] .)


state 118

    (8) stmt -> PRINTLN ( ) ; .

    PRINT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    PRINTLN         reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    WHILE           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    IF              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ID              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    RETURN          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    INPUT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STR             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ATOI            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    !               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    -               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STRING          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    NUM             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    (               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    $end            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ELSE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    }               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)


state 119

    (9) stmt -> WHILE new_label ( expr . ) jz block
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    )               shift and go to state 133
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 120

    (10) stmt -> IF ( expr ) . jz block
    (11) stmt -> IF ( expr ) . jz block ELSE jmp jz_label block
    (13) jz -> .

    {               reduce using rule 13 (jz -> .)
    PRINT           reduce using rule 13 (jz -> .)
    PRINTLN         reduce using rule 13 (jz -> .)
    WHILE           reduce using rule 13 (jz -> .)
    IF              reduce using rule 13 (jz -> .)
    ID              reduce using rule 13 (jz -> .)
    RETURN          reduce using rule 13 (jz -> .)
    INPUT           reduce using rule 13 (jz -> .)
    STR             reduce using rule 13 (jz -> .)
    ATOI            reduce using rule 13 (jz -> .)
    !               reduce using rule 13 (jz -> .)
    -               reduce using rule 13 (jz -> .)
    STRING          reduce using rule 13 (jz -> .)
    NUM             reduce using rule 13 (jz -> .)
    (               reduce using rule 13 (jz -> .)

    jz                             shift and go to state 134

state 121

    (20) stmt -> ID = expr ; .

    PRINT           reduce using rule 20 (stmt -> ID = expr ; .)
    PRINTLN         reduce using rule 20 (stmt -> ID = expr ; .)
    WHILE           reduce using rule 20 (stmt -> ID = expr ; .)
    IF              reduce using rule 20 (stmt -> ID = expr ; .)
    ID              reduce using rule 20 (stmt -> ID = expr ; .)
    RETURN          reduce using rule 20 (stmt -> ID = expr ; .)
    INPUT           reduce using rule 20 (stmt -> ID = expr ; .)
    STR             reduce using rule 20 (stmt -> ID = expr ; .)
    ATOI            reduce using rule 20 (stmt -> ID = expr ; .)
    !               reduce using rule 20 (stmt -> ID = expr ; .)
    -               reduce using rule 20 (stmt -> ID = expr ; .)
    STRING          reduce using rule 20 (stmt -> ID = expr ; .)
    NUM             reduce using rule 20 (stmt -> ID = expr ; .)
    (               reduce using rule 20 (stmt -> ID = expr ; .)
    $end            reduce using rule 20 (stmt -> ID = expr ; .)
    ELSE            reduce using rule 20 (stmt -> ID = expr ; .)
    }               reduce using rule 20 (stmt -> ID = expr ; .)


state 122

    (48) expr -> ID ( fcall ) .

    [               reduce using rule 48 (expr -> ID ( fcall ) .)
    ;               reduce using rule 48 (expr -> ID ( fcall ) .)
    +               reduce using rule 48 (expr -> ID ( fcall ) .)
    -               reduce using rule 48 (expr -> ID ( fcall ) .)
    *               reduce using rule 48 (expr -> ID ( fcall ) .)
    /               reduce using rule 48 (expr -> ID ( fcall ) .)
    %               reduce using rule 48 (expr -> ID ( fcall ) .)
    OR              reduce using rule 48 (expr -> ID ( fcall ) .)
    AND             reduce using rule 48 (expr -> ID ( fcall ) .)
    >               reduce using rule 48 (expr -> ID ( fcall ) .)
    <               reduce using rule 48 (expr -> ID ( fcall ) .)
    GTE             reduce using rule 48 (expr -> ID ( fcall ) .)
    LTE             reduce using rule 48 (expr -> ID ( fcall ) .)
    EQ              reduce using rule 48 (expr -> ID ( fcall ) .)
    NEQ             reduce using rule 48 (expr -> ID ( fcall ) .)
    $               reduce using rule 48 (expr -> ID ( fcall ) .)
    )               reduce using rule 48 (expr -> ID ( fcall ) .)
    ]               reduce using rule 48 (expr -> ID ( fcall ) .)
    ,               reduce using rule 48 (expr -> ID ( fcall ) .)


state 123

    (66) exprlist -> exprlist , . expr
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 135

state 124

    (26) expr -> STR ( expr ) .

    [               reduce using rule 26 (expr -> STR ( expr ) .)
    ;               reduce using rule 26 (expr -> STR ( expr ) .)
    +               reduce using rule 26 (expr -> STR ( expr ) .)
    -               reduce using rule 26 (expr -> STR ( expr ) .)
    *               reduce using rule 26 (expr -> STR ( expr ) .)
    /               reduce using rule 26 (expr -> STR ( expr ) .)
    %               reduce using rule 26 (expr -> STR ( expr ) .)
    OR              reduce using rule 26 (expr -> STR ( expr ) .)
    AND             reduce using rule 26 (expr -> STR ( expr ) .)
    >               reduce using rule 26 (expr -> STR ( expr ) .)
    <               reduce using rule 26 (expr -> STR ( expr ) .)
    GTE             reduce using rule 26 (expr -> STR ( expr ) .)
    LTE             reduce using rule 26 (expr -> STR ( expr ) .)
    EQ              reduce using rule 26 (expr -> STR ( expr ) .)
    NEQ             reduce using rule 26 (expr -> STR ( expr ) .)
    $               reduce using rule 26 (expr -> STR ( expr ) .)
    )               reduce using rule 26 (expr -> STR ( expr ) .)
    ]               reduce using rule 26 (expr -> STR ( expr ) .)
    ,               reduce using rule 26 (expr -> STR ( expr ) .)


state 125

    (27) expr -> ATOI ( expr ) .

    [               reduce using rule 27 (expr -> ATOI ( expr ) .)
    ;               reduce using rule 27 (expr -> ATOI ( expr ) .)
    +               reduce using rule 27 (expr -> ATOI ( expr ) .)
    -               reduce using rule 27 (expr -> ATOI ( expr ) .)
    *               reduce using rule 27 (expr -> ATOI ( expr ) .)
    /               reduce using rule 27 (expr -> ATOI ( expr ) .)
    %               reduce using rule 27 (expr -> ATOI ( expr ) .)
    OR              reduce using rule 27 (expr -> ATOI ( expr ) .)
    AND             reduce using rule 27 (expr -> ATOI ( expr ) .)
    >               reduce using rule 27 (expr -> ATOI ( expr ) .)
    <               reduce using rule 27 (expr -> ATOI ( expr ) .)
    GTE             reduce using rule 27 (expr -> ATOI ( expr ) .)
    LTE             reduce using rule 27 (expr -> ATOI ( expr ) .)
    EQ              reduce using rule 27 (expr -> ATOI ( expr ) .)
    NEQ             reduce using rule 27 (expr -> ATOI ( expr ) .)
    $               reduce using rule 27 (expr -> ATOI ( expr ) .)
    )               reduce using rule 27 (expr -> ATOI ( expr ) .)
    ]               reduce using rule 27 (expr -> ATOI ( expr ) .)
    ,               reduce using rule 27 (expr -> ATOI ( expr ) .)


state 126

    (4) fun -> DEF fun_name ( funargs ) ftype . { stmtlist }

    {               shift and go to state 136


state 127

    (6) ftype -> type .

    {               reduce using rule 6 (ftype -> type .)


state 128

    (62) idlist -> idlist , ID . type
    (50) type -> . STRINGTYPE
    (51) type -> . INTTYPE
    (52) type -> . VOIDTYPE
    (53) type -> . [ type ]

    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    [               shift and go to state 19

    type                           shift and go to state 137

state 129

    (17) var_declare -> VAR ID [ NUM ] [ NUM ] . type ;
    (50) type -> . STRINGTYPE
    (51) type -> . INTTYPE
    (52) type -> . VOIDTYPE
    (53) type -> . [ type ]

    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    [               shift and go to state 19

    type                           shift and go to state 138

state 130

    (45) expr -> expr [ expr ] .

    ;               reduce using rule 45 (expr -> expr [ expr ] .)
    +               reduce using rule 45 (expr -> expr [ expr ] .)
    -               reduce using rule 45 (expr -> expr [ expr ] .)
    *               reduce using rule 45 (expr -> expr [ expr ] .)
    /               reduce using rule 45 (expr -> expr [ expr ] .)
    %               reduce using rule 45 (expr -> expr [ expr ] .)
    OR              reduce using rule 45 (expr -> expr [ expr ] .)
    AND             reduce using rule 45 (expr -> expr [ expr ] .)
    >               reduce using rule 45 (expr -> expr [ expr ] .)
    <               reduce using rule 45 (expr -> expr [ expr ] .)
    GTE             reduce using rule 45 (expr -> expr [ expr ] .)
    LTE             reduce using rule 45 (expr -> expr [ expr ] .)
    EQ              reduce using rule 45 (expr -> expr [ expr ] .)
    NEQ             reduce using rule 45 (expr -> expr [ expr ] .)
    $               reduce using rule 45 (expr -> expr [ expr ] .)
    [               reduce using rule 45 (expr -> expr [ expr ] .)
    )               reduce using rule 45 (expr -> expr [ expr ] .)
    ]               reduce using rule 45 (expr -> expr [ expr ] .)
    ,               reduce using rule 45 (expr -> expr [ expr ] .)


state 131

    (7) stmt -> PRINT ( expr ) ; .

    PRINT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    PRINTLN         reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    WHILE           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    IF              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ID              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    RETURN          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    INPUT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STR             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ATOI            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    !               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    -               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STRING          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    NUM             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    (               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    $end            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ELSE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    }               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)


state 132

    (21) stmt -> expr [ expr ] = . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    ID              shift and go to state 43
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 139

state 133

    (9) stmt -> WHILE new_label ( expr ) . jz block
    (13) jz -> .

    {               reduce using rule 13 (jz -> .)
    PRINT           reduce using rule 13 (jz -> .)
    PRINTLN         reduce using rule 13 (jz -> .)
    WHILE           reduce using rule 13 (jz -> .)
    IF              reduce using rule 13 (jz -> .)
    ID              reduce using rule 13 (jz -> .)
    RETURN          reduce using rule 13 (jz -> .)
    INPUT           reduce using rule 13 (jz -> .)
    STR             reduce using rule 13 (jz -> .)
    ATOI            reduce using rule 13 (jz -> .)
    !               reduce using rule 13 (jz -> .)
    -               reduce using rule 13 (jz -> .)
    STRING          reduce using rule 13 (jz -> .)
    NUM             reduce using rule 13 (jz -> .)
    (               reduce using rule 13 (jz -> .)

    jz                             shift and go to state 140

state 134

    (10) stmt -> IF ( expr ) jz . block
    (11) stmt -> IF ( expr ) jz . block ELSE jmp jz_label block
    (68) block -> . { stmtlist }
    (69) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . expr [ expr ] = expr ;
    (22) stmt -> . RETURN expr ;
    (23) stmt -> . RETURN ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    {               shift and go to state 142
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 27
    block                          shift and go to state 141
    stmt                           shift and go to state 143

state 135

    (66) exprlist -> exprlist , expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ,               reduce using rule 66 (exprlist -> exprlist , expr .)
    )               reduce using rule 66 (exprlist -> exprlist , expr .)
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 136

    (4) fun -> DEF fun_name ( funargs ) ftype { . stmtlist }
    (58) stmtlist -> . stmtlist stmt
    (59) stmtlist -> .

    }               reduce using rule 59 (stmtlist -> .)
    PRINT           reduce using rule 59 (stmtlist -> .)
    PRINTLN         reduce using rule 59 (stmtlist -> .)
    WHILE           reduce using rule 59 (stmtlist -> .)
    IF              reduce using rule 59 (stmtlist -> .)
    ID              reduce using rule 59 (stmtlist -> .)
    RETURN          reduce using rule 59 (stmtlist -> .)
    INPUT           reduce using rule 59 (stmtlist -> .)
    STR             reduce using rule 59 (stmtlist -> .)
    ATOI            reduce using rule 59 (stmtlist -> .)
    !               reduce using rule 59 (stmtlist -> .)
    -               reduce using rule 59 (stmtlist -> .)
    STRING          reduce using rule 59 (stmtlist -> .)
    NUM             reduce using rule 59 (stmtlist -> .)
    (               reduce using rule 59 (stmtlist -> .)

    stmtlist                       shift and go to state 144

state 137

    (62) idlist -> idlist , ID type .

    ,               reduce using rule 62 (idlist -> idlist , ID type .)
    )               reduce using rule 62 (idlist -> idlist , ID type .)


state 138

    (17) var_declare -> VAR ID [ NUM ] [ NUM ] type . ;

    ;               shift and go to state 145


state 139

    (21) stmt -> expr [ expr ] = expr . ;
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (32) expr -> expr . % expr
    (33) expr -> expr . OR expr
    (34) expr -> expr . AND expr
    (35) expr -> expr . > expr
    (36) expr -> expr . < expr
    (37) expr -> expr . GTE expr
    (38) expr -> expr . LTE expr
    (39) expr -> expr . EQ expr
    (40) expr -> expr . NEQ expr
    (41) expr -> expr . $ expr
    (45) expr -> expr . [ expr ]

    ;               shift and go to state 146
    +               shift and go to state 49
    -               shift and go to state 50
    *               shift and go to state 51
    /               shift and go to state 52
    %               shift and go to state 53
    OR              shift and go to state 54
    AND             shift and go to state 55
    >               shift and go to state 56
    <               shift and go to state 57
    GTE             shift and go to state 58
    LTE             shift and go to state 59
    EQ              shift and go to state 60
    NEQ             shift and go to state 61
    $               shift and go to state 62
    [               shift and go to state 81


state 140

    (9) stmt -> WHILE new_label ( expr ) jz . block
    (68) block -> . { stmtlist }
    (69) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . expr [ expr ] = expr ;
    (22) stmt -> . RETURN expr ;
    (23) stmt -> . RETURN ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    {               shift and go to state 142
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 27
    block                          shift and go to state 147
    stmt                           shift and go to state 143

state 141

    (10) stmt -> IF ( expr ) jz block .
    (11) stmt -> IF ( expr ) jz block . ELSE jmp jz_label block

  ! shift/reduce conflict for ELSE resolved as shift
    PRINT           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    PRINTLN         reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    WHILE           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    IF              reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ID              reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    RETURN          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    INPUT           reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    STR             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ATOI            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    !               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    -               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    STRING          reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    NUM             reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    (               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    $end            reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    }               reduce using rule 10 (stmt -> IF ( expr ) jz block .)
    ELSE            shift and go to state 148

  ! ELSE            [ reduce using rule 10 (stmt -> IF ( expr ) jz block .) ]


state 142

    (68) block -> { . stmtlist }
    (58) stmtlist -> . stmtlist stmt
    (59) stmtlist -> .

    }               reduce using rule 59 (stmtlist -> .)
    PRINT           reduce using rule 59 (stmtlist -> .)
    PRINTLN         reduce using rule 59 (stmtlist -> .)
    WHILE           reduce using rule 59 (stmtlist -> .)
    IF              reduce using rule 59 (stmtlist -> .)
    ID              reduce using rule 59 (stmtlist -> .)
    RETURN          reduce using rule 59 (stmtlist -> .)
    INPUT           reduce using rule 59 (stmtlist -> .)
    STR             reduce using rule 59 (stmtlist -> .)
    ATOI            reduce using rule 59 (stmtlist -> .)
    !               reduce using rule 59 (stmtlist -> .)
    -               reduce using rule 59 (stmtlist -> .)
    STRING          reduce using rule 59 (stmtlist -> .)
    NUM             reduce using rule 59 (stmtlist -> .)
    (               reduce using rule 59 (stmtlist -> .)

    stmtlist                       shift and go to state 149

state 143

    (69) block -> stmt .

    ELSE            reduce using rule 69 (block -> stmt .)
    PRINT           reduce using rule 69 (block -> stmt .)
    PRINTLN         reduce using rule 69 (block -> stmt .)
    WHILE           reduce using rule 69 (block -> stmt .)
    IF              reduce using rule 69 (block -> stmt .)
    ID              reduce using rule 69 (block -> stmt .)
    RETURN          reduce using rule 69 (block -> stmt .)
    INPUT           reduce using rule 69 (block -> stmt .)
    STR             reduce using rule 69 (block -> stmt .)
    ATOI            reduce using rule 69 (block -> stmt .)
    !               reduce using rule 69 (block -> stmt .)
    -               reduce using rule 69 (block -> stmt .)
    STRING          reduce using rule 69 (block -> stmt .)
    NUM             reduce using rule 69 (block -> stmt .)
    (               reduce using rule 69 (block -> stmt .)
    $end            reduce using rule 69 (block -> stmt .)
    }               reduce using rule 69 (block -> stmt .)


state 144

    (4) fun -> DEF fun_name ( funargs ) ftype { stmtlist . }
    (58) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . expr [ expr ] = expr ;
    (22) stmt -> . RETURN expr ;
    (23) stmt -> . RETURN ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    }               shift and go to state 150
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    stmt                           shift and go to state 24
    expr                           shift and go to state 27

state 145

    (17) var_declare -> VAR ID [ NUM ] [ NUM ] type ; .

    VAR             reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    DEF             reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    PRINT           reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    PRINTLN         reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    WHILE           reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    IF              reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    ID              reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    RETURN          reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    INPUT           reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    STR             reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    ATOI            reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    !               reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    -               reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    STRING          reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    NUM             reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    (               reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    $end            reduce using rule 17 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)


state 146

    (21) stmt -> expr [ expr ] = expr ; .

    PRINT           reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    PRINTLN         reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    WHILE           reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    IF              reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    ID              reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    RETURN          reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    INPUT           reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    STR             reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    ATOI            reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    !               reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    -               reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    STRING          reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    NUM             reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    (               reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    $end            reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    ELSE            reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)
    }               reduce using rule 21 (stmt -> expr [ expr ] = expr ; .)


state 147

    (9) stmt -> WHILE new_label ( expr ) jz block .

    PRINT           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    PRINTLN         reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    WHILE           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    IF              reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ID              reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    RETURN          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    INPUT           reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    STR             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ATOI            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    !               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    -               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    STRING          reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    NUM             reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    (               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    $end            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    ELSE            reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)
    }               reduce using rule 9 (stmt -> WHILE new_label ( expr ) jz block .)


state 148

    (11) stmt -> IF ( expr ) jz block ELSE . jmp jz_label block
    (12) jmp -> .

    {               reduce using rule 12 (jmp -> .)
    PRINT           reduce using rule 12 (jmp -> .)
    PRINTLN         reduce using rule 12 (jmp -> .)
    WHILE           reduce using rule 12 (jmp -> .)
    IF              reduce using rule 12 (jmp -> .)
    ID              reduce using rule 12 (jmp -> .)
    RETURN          reduce using rule 12 (jmp -> .)
    INPUT           reduce using rule 12 (jmp -> .)
    STR             reduce using rule 12 (jmp -> .)
    ATOI            reduce using rule 12 (jmp -> .)
    !               reduce using rule 12 (jmp -> .)
    -               reduce using rule 12 (jmp -> .)
    STRING          reduce using rule 12 (jmp -> .)
    NUM             reduce using rule 12 (jmp -> .)
    (               reduce using rule 12 (jmp -> .)

    jmp                            shift and go to state 151

state 149

    (68) block -> { stmtlist . }
    (58) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . expr [ expr ] = expr ;
    (22) stmt -> . RETURN expr ;
    (23) stmt -> . RETURN ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    }               shift and go to state 152
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    stmt                           shift and go to state 24
    expr                           shift and go to state 27

state 150

    (4) fun -> DEF fun_name ( funargs ) ftype { stmtlist } .

    DEF             reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    PRINT           reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    PRINTLN         reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    WHILE           reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    IF              reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    ID              reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    RETURN          reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    INPUT           reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    STR             reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    ATOI            reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    !               reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    -               reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    STRING          reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    NUM             reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    (               reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    $end            reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)


state 151

    (11) stmt -> IF ( expr ) jz block ELSE jmp . jz_label block
    (14) jz_label -> .

    {               reduce using rule 14 (jz_label -> .)
    PRINT           reduce using rule 14 (jz_label -> .)
    PRINTLN         reduce using rule 14 (jz_label -> .)
    WHILE           reduce using rule 14 (jz_label -> .)
    IF              reduce using rule 14 (jz_label -> .)
    ID              reduce using rule 14 (jz_label -> .)
    RETURN          reduce using rule 14 (jz_label -> .)
    INPUT           reduce using rule 14 (jz_label -> .)
    STR             reduce using rule 14 (jz_label -> .)
    ATOI            reduce using rule 14 (jz_label -> .)
    !               reduce using rule 14 (jz_label -> .)
    -               reduce using rule 14 (jz_label -> .)
    STRING          reduce using rule 14 (jz_label -> .)
    NUM             reduce using rule 14 (jz_label -> .)
    (               reduce using rule 14 (jz_label -> .)

    jz_label                       shift and go to state 153

state 152

    (68) block -> { stmtlist } .

    ELSE            reduce using rule 68 (block -> { stmtlist } .)
    PRINT           reduce using rule 68 (block -> { stmtlist } .)
    PRINTLN         reduce using rule 68 (block -> { stmtlist } .)
    WHILE           reduce using rule 68 (block -> { stmtlist } .)
    IF              reduce using rule 68 (block -> { stmtlist } .)
    ID              reduce using rule 68 (block -> { stmtlist } .)
    RETURN          reduce using rule 68 (block -> { stmtlist } .)
    INPUT           reduce using rule 68 (block -> { stmtlist } .)
    STR             reduce using rule 68 (block -> { stmtlist } .)
    ATOI            reduce using rule 68 (block -> { stmtlist } .)
    !               reduce using rule 68 (block -> { stmtlist } .)
    -               reduce using rule 68 (block -> { stmtlist } .)
    STRING          reduce using rule 68 (block -> { stmtlist } .)
    NUM             reduce using rule 68 (block -> { stmtlist } .)
    (               reduce using rule 68 (block -> { stmtlist } .)
    $end            reduce using rule 68 (block -> { stmtlist } .)
    }               reduce using rule 68 (block -> { stmtlist } .)


state 153

    (11) stmt -> IF ( expr ) jz block ELSE jmp jz_label . block
    (68) block -> . { stmtlist }
    (69) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . WHILE new_label ( expr ) jz block
    (10) stmt -> . IF ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (20) stmt -> . ID = expr ;
    (21) stmt -> . expr [ expr ] = expr ;
    (22) stmt -> . RETURN expr ;
    (23) stmt -> . RETURN ;
    (24) stmt -> . expr ;
    (25) expr -> . INPUT ( )
    (26) expr -> . STR ( expr )
    (27) expr -> . ATOI ( expr )
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . expr % expr
    (33) expr -> . expr OR expr
    (34) expr -> . expr AND expr
    (35) expr -> . expr > expr
    (36) expr -> . expr < expr
    (37) expr -> . expr GTE expr
    (38) expr -> . expr LTE expr
    (39) expr -> . expr EQ expr
    (40) expr -> . expr NEQ expr
    (41) expr -> . expr $ expr
    (42) expr -> . ! expr
    (43) expr -> . - expr
    (44) expr -> . ID
    (45) expr -> . expr [ expr ]
    (46) expr -> . STRING
    (47) expr -> . NUM
    (48) expr -> . ID ( fcall )
    (49) expr -> . ( expr )

    {               shift and go to state 142
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STR             shift and go to state 34
    ATOI            shift and go to state 35
    !               shift and go to state 37
    -               shift and go to state 36
    STRING          shift and go to state 38
    NUM             shift and go to state 39
    (               shift and go to state 26

    expr                           shift and go to state 27
    block                          shift and go to state 154
    stmt                           shift and go to state 143

state 154

    (11) stmt -> IF ( expr ) jz block ELSE jmp jz_label block .

    PRINT           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    PRINTLN         reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    WHILE           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    IF              reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ID              reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    RETURN          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    INPUT           reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STR             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ATOI            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    !               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    -               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STRING          reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    NUM             reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    (               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    $end            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ELSE            reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    }               reduce using rule 11 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 141 resolved as shift
